<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SAM</name>
    </assembly>
    <members>
        <member name="T:DeepSpaceLabs.SAM.ActiveGrid">
            <summary>
            The Active Grid is the collection of cells which are currently "active" in the scene, as determined by your players position in 
            the scene. Like the World, the Active Grid can have 1 or more Groupings, each with their own grid, which form a direct connection with the World Groupings 
            on the World the Active Grid is synced to.
            <para>
            >Note, however, it is not necessary to have an equal number of Groupings on the Active Grid and World.
            </para>
            <para>
            If the Active Grid has less groupings, then some groupings from the World will never be loaded (unless they are loaded via other Active Grids or 
            World Regions).
            </para>
            <para>
            If the Active Grid has more groupings, then the cells from the additional groupings will be updated but won't actually result in World Cells 
            being loaded. It should be noted that since the Active Grid is actually made up of 1 or more grids, "Active Grids" may be a more accurate name for the class.
            </para>
            <para>
            The behavior described above allows the Active Grid to be used with different Worlds with different numbering of Groupings. Syncing to a new 
            World can result in some Groupings that were not being used previously to start being used, and vice versa.
            </para>
            <para>
            Typically, active cells are passed to the World so that it can choose to load any associated World Cells, however it is possible to have 
            active cells that are not passed to the World (by disabling Update World on the Grouping), though the use cases for that are limited.
            </para>
            <para>
            An Active Grid should only be disabled (or the game object the component is on disabled) if it is being 
            used as a prototype to create Active Grids 
            at runtime. Do not disable an Active Grid with the intention of enabling/using it 
            at a later time, as this will not work properly. Instead, you should create the Active Grid via the 
            Component Manager's 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.CreateNonPersistentActiveGridUsingIPlayer(System.Int32,DeepSpaceLabs.SAM.World,DeepSpaceLabs.SAM.IPlayer,DeepSpaceLabs.SAM.PlayerMover)" href="ComponentManager.html#CreateNonPersistentActiveGridUsingTransform">CreateNonPersistentActiveGrid</see> 
            method when it is needed, and destroy it via the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.DestroyActiveGrid(System.Int32)" href="ComponentManager.html#DestroyActiveGrid">DestroyActiveGrid</see> or 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.DestroyActiveGridAndWaitForCellUsersToBeRemoved(System.Int32)" href="ComponentManager.html#DestroyActiveGridAndWaitForCellUsersToBeRemoved">DestroyActiveGridAndWaitForCellUsersToBeRemoved</see>
            methods when it is no longer needed.
            </para>
            </summary>
            <title>ActiveGrid Class</title>
            <category>Primary Components</category>
            <navigationName>ActiveGrid</navigationName>
            <fileName>ActiveGrid.html</fileName>
            <syntax>
            public sealed partial class ActiveGrid : MonoBehaviour, <see href = "IIdentifiable.html">IIdentifiable</see>, <see cref="T:DeepSpaceLabs.SAM.IWorldUser" href="IWorldUser.html">IWorldUser</see>
            </syntax>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ActiveGrid.CellPlayerIsInChanged">
            <summary>
            An event that can be subscribed to in order to receive 
            notifications when the cell the player is in changes. Please keep the following points in mind:
            <br></br>
            <para indented="true">
            1) This event will fire upon initialization of the Active Grid or when the Active Grid syncs to a new World, because the initial cell the player is in usually 
            needs to be known by listeners interested in monitoring whether the cell the player is in changes.
            </para>
            <br></br>
            <para indented="true">
            2) Please note, any reference values stored in this event are immedidately nulled out after all listeners have been notified of the 
            event, therefore, if you wish to reference the objects after your listener method has been called, you will need to save a 
            reference to the object(s) yourself. In addition, any non reference values cannot be considered accurate after your listener 
            method has completed, so again, store the values if you wish to save them.
            </para>
            <br></br>
            <para indented="true">
            3) Since an Active Grid can be synced to a world with multiple World Groupings, the cell that changes is tied 
            to a specific active grid grouping, which is associated with a specific world grouping. You can retrieve these values using the 
            ActiveGridGroupingIndex and WorldGroupingIndex properties respectively. Multiple 
            events can be fired in a single frame, one for each grouping that is set to fire the event.
            </para>
            <br></br>
            <para indented="true">
            4) The cell in question is the 
            Endless Grid Cell the player is in, which can change, among other reasons, as the 
            result of a world shift. In this case, the StreamableGridCellPlayerIsIn and 
            WorldCellPlayerIsIn will remain the same as before the event was fired. In other situations, the 
            WorldCell will change but StreamableGridCellPlayerIsIn will remain the same (if the player 
            is transported to different Endless Grid Cell that is associated with the same Streamable Grid Cell as the 
            previous Endless Grid Cell the player was on).
            </para>
            <br></br>
            <para indented="true">
            5) When the Active Grid becomes desynced from a World, this event fires with the CausedByDesync property set to true, WorldCellPlayerIsIn 
            set to null, and EndlessGridCellPlayerIsIn/StreamableGridCellPlayerIsIn values invalid. You should think of the Cell the player is in under 
            these circumstances to be null.
            </para>
            <br></br>
            <para indented="true">
            If this event is fired as a result of the Player being synced to an entirely new world, a CellPlayerIsInChangedEventArgs will be triggered with the World 
            set to the new World and WorldCellPlayerIsIn, EndlessGridCellPlayerIsIn, and StreamableGridCellPlayerIsIn will be set and/or valid.
            </para>
            <br></br>
            <para indented="true">
            6) The WorldCellPlayerIsIn property will also return null if a World Cell cannot be retrieved 
            from the World for a given cell. This can occur if that cell on the World is not active, either 
            because the component manager has not been initialized or had time to fully load the world 
            objects, that cell is simply empty, or this Active Grid and any other World users are not 
            "using" that cell (which can occur, for instance, if the Active Grid's Monitor 
            Inner Area Boundaries option is disabled). In any case, EndlessGridCellPlayerIsIn and 
            StreamableGridCellPlayerIsIn will still be valid.
            </para>
            <br></br>
            <para indented="true">
            7) The event args are reused for each event, so once a new event fires the 
            WorldCellPlayerIsIn, EndlessGridCellPlayerIsIn, StreamableGridCellPlayerIsIn, WorldGroupingIndex, and ReasonForNullWorldCell 
            values will no longer be accurate for the previous event (though some values may be the same, depending upon 
            the situation which caused the new event to fire).
            </para>
            <br></br>
            <para indented="true">
            8) Depending upon your loading blueprint, a change in the cell the player is may not result in 
            a change in the world (in situations where your inner area is not a single cell). You should not rely on 
            this event to tell you when the world has been updated, as even in situations where the world will be 
            updated, there is no guarantee that the update will be complete before this event fires.
            </para>
            <br></br>
            <para indented="true">
            9) The event utilizes 
            <see cref="T:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs" href="CellPlayerIsInChangedEventArgs.html">
            CellPlayerIsInChangedEventArgs</see> and subscribers must have a signature of 
            void MethodName(object sender, CellPlayerIsInChangedEventArgs paramaterName).
            </para>
            <para>
            This event can also be subscribed to at the Component Manager Level, which removes the limitation of needing to subscribe to a 
            specific Active Grid. Via the Component Manager, you can set up a subscriber such that it is called under any of the following 
            circumstances:
            <br></br>
            </para>
            <para indented="true">
            1) When any Active Grid in the scene fires the event for any World Grouping.
            </para>
            <para indented="true">
            2) When any Active Grid in the scene fires the event for a particular World Grouping.
            </para>
            <para indented="true">
            3) When any Active Grid synced with a particular World fires the event for any World Grouping.
            </para>
            <para indented="true">
            4) When any Active Grid synced with a particular World fires the event for a particular World Grouping.
            </para>
            <para>
            Use the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.SubscribeToCellPlayerIsInChangedEvents(DeepSpaceLabs.SAM.World,System.Int32,System.Action{System.Object,DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs})" href="ComponentManager.html#SubscribeToCellPlayerIsInChangedEvents">SubscribeToCellPlayerIsInChangedEvents</see> and 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.UnsubscribeToCellPlayerIsInChangedEvents(DeepSpaceLabs.SAM.World,System.Int32,System.Action{System.Object,DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs})" href="ComponentManager.html#UnsubscribeToCellPlayerIsInChangedEvents">UnsubscribeToCellPlayerIsInChangedEvents</see> methods for this purpose.
            </para>
            </summary>
            <validSubscriber>
            void MethodName(object sender, <see cref="T:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs" href="CellPlayerIsInChangedEventArgs.html">CellPlayerIsInChangedEventArgs</see> parameterName)
            </validSubscriber>
            <displayName>CellPlayerIsInChanged</displayName>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ActiveGrid.PlayerMovedByGrid">
            <summary>
            An event that can be subscribed to in order to receive notifications when the player is 
            moved by the Active Grid. This is most useful when trying to sync an action to the player being 
            moved during one of the Active Grids move methods.
            <para>
            Please note, the Player object stored in this event is immedidately nulled out after all listeners have been notified of the 
            event, therefore, if you wish to reference the object after your listener method has been called, you will need to save a 
            reference to the object yourself.
            </para>
            <para>
            Also note, the event is not fired upon Component Manager initialization for Active Grids, even though the location of the player 
            may change due to save data or an attempt to align the player with a terrain. It is only called during runtime after initialization.
            </para>
            <para>
            The event utilizes 
            <see cref="T:DeepSpaceLabs.SAM.PlayerMovedByGridEventArgs" href="PlayerMovedByGridEventArgs.html">PlayerMovedByGridEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, PlayerMovedByGridEventArgs paramaterName).
            </para>
            </summary>
            <validSubscriber>
            void MethodName(object sender, <see cref="T:DeepSpaceLabs.SAM.PlayerMovedByGridEventArgs" href="PlayerMovedByGridEventArgs.html">PlayerMovedByGridEventArgs</see> parameterName)
            </validSubscriber>
            <displayName>PlayerMovedByGrid</displayName>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ActiveGrid.WorldSyncedToChanged">
            <summary>
            An event that can be subscribed to in order to receive notifications when the World the Active Grid is synced to changes. 
            This occurs when the Active Grid is first initialized and a valid World is 
            present, or when manually changing the World via the API. When the sync occurs as a result of using the 
            TryMovePlayerToLocationOnNewWorld method, 
            the sync "occurs" when the player is moved, otherwise the sync occurs just before the 
            coroutine that triggered the sync exits.
            <para>
            This event can also be fired when desyncing from a World and not syncing to a different world, in which case the NewWorld property will be null. In this case, you should not use the 
            <see cref="!:WorldSyncedToChangedEventArgs.GetWorldCellPlayerIsStartingIn" href="WorldSyncedToChangedEventArgs.html#GetWorldCellPlayerIsStartingIn">GetWorldCellPlayerIsStartingIn</see> and 
            <see cref="!:WorldSyncedToChangedEventArgs.GetEndlessGridCellPlayerIsStartingIn" href="WorldSyncedToChangedEventArgs.html#GetEndlessGridCellPlayerIsStartingIn">GetEndlessGridCellPlayerIsStartingIn</see>, 
            as they will not be valid and will likely throw exceptions.
            </para>
            <para>
            In addition to containing references to the 
            old and new World, it also contains the starting <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cells</see> 
            for the player, for each layer on the new world 
            (use the <see cref="!:WorldSyncedToChangedEventArgs.GetWorldCellPlayerIsStartingIn" href="WorldSyncedToChangedEventArgs.html#GetWorldCellPlayerIsStartingIn">GetWorldCellPlayerIsStartingIn</see> 
            method to retreive the cells. Using this 
            in conjuction with the CellPlayerIsInChanged event will allow you to fully track which cell the player is in for one or all layers. Do 
            note, however, that the World Cells may be null in some instances, and you should account for this by checking for null. You can use 
            the Endless Grid Cell values instead when a World Cell is null.
            </para>
            <para>
            In addition, the args contain the <see cref="!:WorldSyncedToChangedEventArgs.GetEndlessGridCellPlayerIsStartingIn" href="WorldSyncedToChangedEventArgs.html#GetEndlessGridCellPlayerIsStartingIn">GetEndlessGridCellPlayerIsStartingIn</see> method 
            for retrieving the Endless Grid cell that the player is in. This can be used if the World Cell value is null, which can occur 
            in some situations and should be accounted for. Using the Endless Grid Cell, you can query the World for useful information, such 
            as the bounds of the cell.
            </para>
            <para>
            Please note, any reference values stored in this event are immedidately nulled out after all listeners have been notified of the 
            event, therefore, if you wish to reference the objects after your listener method has been called, you will need to save a 
            reference to the object(s) yourself. In addition, non reference values should be considered <b>invalid</b> after the listeners have been 
            notified.
            </para>
            <para>
            The event utilizes 
            <see cref="T:DeepSpaceLabs.SAM.WorldSyncedToChangedEventArgs" href="WorldSyncedToChangedEventArgs.html">WorldSyncedToChangedEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, WorldSyncedToChangedEventArgs paramaterName). The sender 
            is the Active Grid which is firing the event, so you are free to cast the sender to an ActiveGrid object if you need the 
            reference for some reason.
            </para>
            </summary>
            <validSubscriber>
            void MethodName(object sender, <see cref="T:DeepSpaceLabs.SAM.WorldSyncedToChangedEventArgs" href="WorldSyncedToChangedEventArgs.html">WorldSyncedToChangedEventArgs</see> parameterName)
            </validSubscriber>
            <displayName>WorldSyncedToChanged</displayName>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.SyncedGroupings">
            <summary>
            Gets the number of synced groupings, which is dependent upon the number of groupings on the World the Active Grid is 
            currently synced to that could be matched (by Grouping Name) to Groupings on this Active Grid. 
            <para>
            If you want to know the number of groupings that are configured on the Active Grid (via the inspector), 
            use <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.ConfiguredGroupings" href="ActiveGrid.html#ConfiguredGroupings">ConfiguredGroupings</see> property instead.
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.ConfiguredGroupings">
            <summary>
            Gets the number of groupings configured on the Active Grid via the inspector. This may be different than the number of 
            <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.SyncedGroupings" href="ActiveGrid.html#SyncedGroupings">SyncedGroupings</see>, which is dependent upon the World the Active Grid is currently synced to.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.CreatedAtRuntime">
            <summary>
            Gets a value indicating whether the Active Grid was created at runtime. If false, it means the Active Grid was added 
            in the inspector by the dev (not as a prototype).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.ID">
            <summary>
            Gets the identification number of the Active Grid.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.IsActiveGridPersistent">
            <summary>
            Gets a value indicating whether the Active Grid is persistent between game sessions. Note, non prototype 
            Active Grids added in the editor are always persistent.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.IsInitialized">
            <summary>
            Gets a value indicating whether the Active Grid has been initialized. The Grid is initialized automatically 
            by the Component Manager when it is initialized.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.IsBusy">
            <summary>
            Gets a value indicating whether the Current Active Grid is busy. "Busy" simply means a 
            multi frame action (aka, a coroutine method)
            is currently being executed (such as the method <see href = "#TryMovePlayerToLocation">TryMovePlayerToLocation</see>).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.LoadingBlueprintRepository">
            <summary>
            Gets the Loading Blueprint Repository assigned to this Active Grid.
            </summary>
            <type link="LoadingBlueprintRepository.html">LoadingBlueprintRepository</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.Player">
            <summary>
            Gets the Current Player associated with the Active Grid.
            </summary>
            <type link="IPlayer.html">IPlayer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.PlayerMover">
            <summary>
            Gets the Current Player Mover associated with the Active Grid.
            </summary>
            <type link="PlayerMover.html">PlayerMover</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.PlayerReadyToBeMoved">
            <summary>
            During an Active Grid operation where the player needs to be moved and 
            true was passed in for waitForCommandBeforeMovingPlayer, this can be used to 
            determine whether the player is ready to be moved. This will be true if the area 
            the player is being moved to has successfully been loaded.
            <para>
            This is most useful when trying to sync other actions/events to 
            the player being moved (such as a portal effect or transport sound).
            </para>
            <para>
            To use it effectively, you'd call StartCoroutine(any Active Grid Method that moves the player, such as 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocation(DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Boolean,System.Boolean,System.Double)" href="#TryMovePlayerToLocation">TryMovePlayerToLocation</see>). When you are ready 
            for the player to be moved, you query this property to make sure the area to move the player to has been loaded. 
            Once this returns true, you play your effect/sound and call the same Active Grid's 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.InitiatePendingMove" href="#InitiatePendingMove">InitiatePendingMove</see> 
            method at the appropriate time during that 
            effect/sound.
            </para>
            <para>
            The player will be moved either in the same frame or a couple of frames after, depending on whether a Player Mover 
            component is linked to the Active Grid. In the case of the latter, the player should not notice the delay.
            </para>
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ActiveGrid.WorldSyncedTo">
            <summary>
            Gets the Current World the Active Grid is synced to.
            </summary>
            <type link = "World.html">World</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.GetGroupingIndexUsingGroupingName(System.String)">
            <summary>
            Gets the index of the Grouping indicated by groupingName. 
            </summary>
            <param name="groupingName" type="string">
            The name of the Grouping.
            </param>
            <displayName id="GetGroupingIndexUsingGroupingName">
            GetGroupingIndexUsingGroupingName(string)
            </displayName>
            <syntax>
            public int GetGroupingIndexUsingGroupingName(string groupingName)
            </syntax>
            <returns type="int">
            The index of the grouping as it appears in the inspector, or -1 if no Grouping with the groupingName exist on this Active Grid.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.IsGroupingSynced(System.Int32)">
            <summary>
            Gets a value indicating whether the Active Grid Grouping specified is currently synced to a World Grouping.
            <para>
            This will be true if the Active Grid is synced to a World and that World contains a World Grouping with 
            the same Grouping Name as the specified Active Grid Grouping.
            </para>
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <syntax>public bool IsGroupingSynced(int activeGridGrouping)</syntax>
            <displayName id="IsGroupingSynced">IsGroupingSynced(int)</displayName>
            <returns type = "bool">
            True if the Active Grid Grouping is synced to a World Grouping, false otherwise.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.IsUpdatingWorld(System.Int32)">
            <summary>
            Gets the value of Update World (as shown in the inspector) for an Active Grid Grouping. 
            Note that even if this value is true, it doesn't necessarily mean that 
            the Grouping will be updating the World on its Active Cells. For example, if the Grouping could not be matched to a 
            World Grouping, it will be idle.
            <para>
            If you are trying to determine if the Grouping is actually synced to a World Grouping and has Active Cells 
            currently registered with the World, use 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.HasCellsRegistered(System.Int32)" href="#HasCellsRegistered">HasCellsRegistered</see> instead.
            </para>
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <syntax>public bool IsUpdatingWorld(int activeGridGrouping)</syntax>
            <displayName id="IsUpdatingWorld">IsUpdatingWorld(int)</displayName>
            <returns type = "bool">
            True if the World is being updated about the active grid cells for the layer, false otherwise.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.IsAutoTrackingEnabled(System.Int32)">
            <summary>
            Gets the value of Enable Auto Tracking (as shown in the inpsector) for an Active Grid Grouping. This value 
            indicates whether the Player's position is being automatically tracked in 
            order to update the Active Cells used by the specified Grouping on this Active Grid.
            <para>
            With Auto Tracking disabled, the Cells for the grouping will be set based on the 
            initial position of the player, but will never be updated afterwards. Therefore, it is rare that you would want 
            to disable Auto Tracking!
            </para>
            <para>
            Note that in order for actual World Cell's and Asset Chunks to be loaded, 'Update World' 
            must also be enabled for the grouping specified, and the Grouping must be synced to a matching World Grouping on the World.
            </para>
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <syntax>public bool IsAutoTrackingEnabled(int activeGridGrouping)</syntax>
            <displayName id="IsAutoTrackingEnabled">IsAutoTrackingEnabled(int)</displayName>
            <returns type = "bool">
            True if auto tracking is enabled, false otherwise.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.HasCellsRegistered(System.Int32)">
            <summary>
            Gets a value indicating whether the Active Grid Grouping specified is currently synced to a World Grouping and 
            has Active Cells registered with the World.
            <para>
            To have Active Cells registered with the World simply means that the Grouping has notified the World 
            that those Cells are in use. This may or may not result in equivalent World Cells being loaded, 
            depending on if there are other users of the same Cells but of a higher quality LOD.
            </para>
            <para>
            To be honest, it's not clear how this information might be useful to you, but it's there if you need it.
            </para>
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <syntax>public bool HasCellsRegistered(int activeGridGrouping)</syntax>
            <displayName id="HasCellsRegistered">HasCellsRegistered(int)</displayName>
            <returns type = "bool">
            True if the cell users are loaded for the World Grouping specified, false otherwise.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.ArePlayerCellChangeEventsEnabledForGrouping(System.Int32)">
            <summary>
            Queries whether a particular Active Grid Grouping will fire events whenever the cell the player is in changes on that grouping.
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <returns type="bool">
            True if events are enabled, false otherwise.
            </returns>
            <displayName id="ArePlayerCellChangeEventsEnabledForGrouping">
            ArePlayerCellChangeEventsEnabledForGrouping(int)
            </displayName>
            <syntax>
            public bool ArePlayerCellChangeEventsEnabledForGrouping(int activeGridGrouping)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.AreActiveGridMovedEventsEnabledForGrouping(System.Int32)">
            <summary>
            Queries whether a particular Active Grid Grouping will fire events whenever that grouping's grid of Active Cells moves/changes.
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <returns type="bool">
            True if events are enabled, false otherwise.
            </returns>
            <displayName id="AreActiveGridMovedEventsEnabledForGrouping">
            AreActiveGridMovedEventsEnabledForGrouping(int)
            </displayName>
            <syntax>
            public bool AreActiveGridMovedEventsEnabledForGrouping(int activeGridGrouping)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.GetDistanceFromInnerAreaOfGrid(DeepSpaceLabs.SAM.Cell,System.Int32,DeepSpaceLabs.SAM.DistanceCheckMethod,System.Int32)">
            <summary>
            Gets the distance that an endless grid cell is from the inner area of the Active Cells of the specified Active 
            Grid Grouping Grouping specified (if no grouping is specified, uses Grouping 1).
            <para>
            You can use this info for a variety of purposes, for instance you could modify 
            loaded terrains to use a lower resolution 
            at runtime if they are farther from the grids center (although it would be better 
            to use a loading blueprint that makes use of LODs for this purpose).
            </para>
            <para>
            Note that if you are not sure whether the Active Grid Grouping is currently synced to a World Grouping, you should place 
            the calling code in a try/catch statement and look for a InvalidOperationException. When this exception is thrown, you can 
            disregard it and exit whatever code is trying to use the distance.
            </para>
            </summary>
            <param name="cellOnEndlessGrid" type="Cell" link="Cell.html">
            The cell whose distance from the inner area you want. It should be one based and a cell on your World's Endless Grid.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone, which will be used to find the correct Inner Area to perform the Distance check with.
            </param>
            <param name="distanceCheckMethod" type="DistanceCheckMethod" link="DistanceCheckMethod.html">
            The method used to calculate the distance.
            </param>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <returns type="int">
            0 will be returned if the cell is part of the inner area, otherwise the distance of the cell's row, column, and layer (if 3D) from the 
            Inner Area are computed separately, and the largest distance is returned.
            </returns>
            <syntax>
            public int GetDistanceFromInnerAreaOfGrid(Cell cellOnEndlessGrid, int zoneIndex, DistanceCheckMethod distanceCheckMethod, int activeGridGrouping = 1)
            </syntax>
            <displayName id="GetDistanceFromInnerAreaOfGrid1">
            GetDistanceFromInnerAreaOfGrid(Cell, int, DistanceCheckMethod, [int])
            </displayName>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException">
            Thrown if the method is called before the Active Grid is initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called for an Active Grid Grouping that is not synced to a World Grouping.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.GetDistanceFromInnerAreaOfGrid(DeepSpaceLabs.SAM.WorldCell,DeepSpaceLabs.SAM.DistanceCheckMethod)">
            <summary>
            Gets the distance that a World Cell is from the inner area of the Active Cells that belong to the World Grouping and Zone that 
            the input World Cell belongs to.
            <para>
            You can use this info for a variety of purposes, for instance you could modify 
            loaded terrains to use a lower resolution 
            at runtime if they are farther from the grids center (although it would be better 
            to use a loading blueprint that makes use of LODs for this purpose).
            </para>
            <para>
            Note that if you are not sure whether the Active Grid Grouping is currently synced to the World Grouping of the Zone the 
            World Cell is part of, you should place 
            the calling code in a try/catch statement and look for a InvalidOperationException. When this exception is thrown, you can 
            disregard it and exit whatever code is trying to use the distance.
            </para>
            </summary>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            The World Cell whose distance from the inner area you want.
            </param>
            <param name="distanceCheckMethod" type="DistanceCheckMethod" link="DistanceCheckMethod.html">
            The method used to calculate the distance.
            </param>
            <returns type="int">
            The calculated distance.
            <para>
            If the Active Grid is synced to separate repeated/endless instances of the World Cell's Zone, a distance value is computed for each, and 
            the smallest computed distance is returned.
            </para>
            </returns>
            <syntax>
            public int GetDistanceFromInnerAreaOfGrid(WorldCell worldCell, DistanceCheckMethod distanceCheckMethod)
            </syntax>
            <displayName id="GetDistanceFromInnerAreaOfGrid2">
            GetDistanceFromInnerAreaOfGrid(WorldCell, DistanceCheckMethod)
            </displayName>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException">
            Thrown if the method is called before the Active Grid is initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called for an Active Grid Grouping that is not synced to a World Grouping.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.GetFallbackLoadingBlueprintOfGrouping(System.Int32)">
            <summary>
            Gets the Fallback Loading Blueprint associated with a specific World Grouping.
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <returns type="LoadingBlueprint" link="LoadingBlueprint.html">
            The loading blueprint associated with the World Grouping.
            </returns>
            <displayName id="GetFallbackLoadingBlueprintOfGrouping">
            GetFallbackLoadingBlueprintOfGrouping(int)
            </displayName>
            <syntax>
            public LoadingBlueprint GetFallbackLoadingBlueprintOfGrouping(int activeGridGrouping)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called before the Active Grid has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.GetRegisteredActiveCells(System.Int32,System.Collections.Generic.ICollection{DeepSpaceLabs.SAM.ZoneGroupingLODCell},System.Boolean)">
            <summary>
            Fills the input cells collection with all currently registered active ZoneGroupingLODCells associated with the input Active Grid Grouping. 
            These are the Cells the Grouping has registered itself as a user of with the World.
            <para>
            Note, if the Grouping is not currently synced to a World Grouping, or is not currently updating the World with its 
            Active Cells, no cells will be added to the cells collection, but it will still be cleared if clearCollectionIfNotEmpty is true.
            </para>
            </summary>
            <param name="activeGridGrouping" type="int">
            The index of the Active Grid Grouping you are inquiring about, as shown in the Active Grid inspector.
            </param>
            <param name="cells" type="ICollection&lt;ZoneGroupingLODCell&gt;" link="ZoneGroupingLODCell.html">
            A container for storing the currently active cells. The container can be a lists, hashset, or any other 
            collection that implements ICollection&lt;ZoneGroupingLODCell&gt;
            </param>
            <param name="clearCollectionIfNotEmpty" type="bool">
            Whether the cells collection should be cleared if it is not already empty, before adding the active cells.
            </param>
            <displayName id="GetRegisteredActiveCells">
            GetRegisteredActiveCells(int, ICollection&lt;ZoneGroupingLODCell&gt;, bool)
            </displayName>
            <syntax>
            public void GetRegisteredActiveCells(int activeGridGrouping, ICollection&lt;ZoneGroupingLODCell&gt; cells, bool clearCollectionIfNotEmpty)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.PreInitialize_SetWorld(DeepSpaceLabs.SAM.World,System.Boolean)">
            <summary>
            Sets the initial World for the Active Grid to use. This must be called before the Active Grid has been 
            initialized, and if the Active Grid is persistent, the world must also be persistent.
            <para>Note, this will not fire the ActiveGridSyncedToNewWorld event.</para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world for the Active Grid to use.
            </param>
            <param name="overwriteWorldFromPersistentData" type="bool">
            If true, the passed in World will be used regardless of whether persistent data exist for the 
            Active Grid. If false, the passed 
            in world will be used if a) no persistent data exist for the Active Grid, or b) persistent data 
            exist, but no world was found 
            in the data (happens when active grid was synced to a non persistent world when data was saved).
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the Active has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the Active Grid has already been initialized.
            </exception>
            <displayName id="PreInitialize_SetWorld">
            PreInitialize_SetWorld(World, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetWorld(World world, bool overwriteWorldFromPersistentData)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.PreInitialize_SetPlayer(UnityEngine.Transform,DeepSpaceLabs.SAM.PlayerMover,System.Boolean,System.Boolean)">
            <summary>
            Sets the player that the Active Grid will track in order to perform shifts (both normal shifts and 
            origin resetting). You must call this method before the Active Grid is initialized. While the Player's positional data 
            will be saved with SAM's save data (so long as this Active Grid is persistent), the actualy Player object will not, as 
            there is no way to save the reference. As such, you need to call this method each session.
            </summary>
            <param name="newPlayer" type="Transform">
            The player transform to set.
            </param>
            <param name="newPlayerMover" type="PlayerMover" link="PlayerMover.html">
            The player mover object associated with the player. This is only used with 
            origin resetting to avoid physics issues when moving the player, therefore it can be left null if 
            no special handling needs to take place when modifying the player position. Note that even if you have a Player Mover 
            assigned via the Active Grid inspector, it will be overriden with this value, even if the value is null.
            </param>
            <param name="overrideIgnorePlayerPositionInPersistentData" type="bool">
            By default, the Player's position (which is always saved with SAM save data when the Player is linked to a persistent Active Grid) 
            is loaded in with SAM's save data and used to position the Player. The Active Grid has an option that you can set in its Inspector called 
            "Ignore Player Position In Persistent Data" which counters this behaviour, in situations where it would be problematic to let  
            SAM set the Player Position.
            <para>
            If you want to override this Inspector value, you can pass in true for this option, and then provide a new value for 
            ignorePlayerPositionInPersistentData. Keep in mind that this new value will only be used for the current session. It is not saved 
            with SAM's persistent save data. This should not be problematic as you will need to set the player manually using 
            this method for each new gaming session, so you can override it each time you do so.
            </para>
            </param>
            <param name="ignorePlayerPositionInPersistentData" type="bool">
            If overrideIgnorePlayerPositionInPersistentData is true, this value is used to determine whether the Player's positional data stored 
            in SAM's persistent save data will be ignored. The value you set is used only for this session, so for each new session where 
            you call this method, you should pass in the same value. See the info for overrideIgnorePlayerPositionInPersistentData for more information.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the Active has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when null is passed in for newPlayer.
            </exception>
            <displayName id="PreInitialize_SetPlayer1">
            PreInitialize_SetPlayer(Transform, PlayerMover, bool, [bool])
            </displayName>
            <syntax>
            public void PreInitialize_SetPlayer(Transform newPlayer, PlayerMover newPlayerMover, bool overrideIgnorePlayerPositionInPersistentData, bool ignorePlayerPositionInPersistentData = false)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.PreInitialize_SetPlayer(DeepSpaceLabs.SAM.IPlayer,DeepSpaceLabs.SAM.PlayerMover,System.Boolean,System.Boolean)">
            <summary>
            Sets the player that the Active Grid will track in order to perform shifts (both normal shifts and 
            origin resetting). You must call this method before the Active Grid is initialized. While the Player's positional data 
            will be saved with SAM's save data (so long as this Active Grid is persistent), the actualy Player object will not, as 
            there is no way to save the reference. As such, you need to call this method each session.
            <para>
            With this method, you can pass in a class deriving from CustomPlayer, or any other class that implements the IPlayer interface. These 
            types can be used in systems where the Player is not associated with the traditional Transform component. These types of players 
            are especially useful when you want to use doubles to track player position data.
            </para>
            </summary>
            <param name="newPlayer" type="IPlayer" link="IPlayer.html">
            The player to set.
            </param>
            <param name="newPlayerMover" type="PlayerMover" link="PlayerMover.html">
            The player mover object associated with the player. This is only used with 
            origin resetting to avoid physics issues when moving the player, therefore it can be left null if 
            no special handling needs to take place when modifying the player position. Note that even if you have a Player Mover 
            assigned via the Active Grid inspector, it will be overriden with this value, even if the value is null.
            </param>
            <param name="overrideIgnorePlayerPositionInPersistentData" type="bool">
            By default, the Player's position (which is always saved with SAM save data when the Player is linked to a persistent Active Grid) 
            is loaded in with SAM's save data and used to position the Player. The Active Grid has an option that you can set in its Inspector called 
            "Ignore Player Position In Persistent Data" which counters this behaviour, in situations where it would be problematic to let  
            SAM set the Player Position.
            <para>
            If you want to override this Inspector value, you can pass in true for this option, and then provide a new value for 
            ignorePlayerPositionInPersistentData. Keep in mind that this new value will only be used for the current session. It is not saved 
            with SAM's persistent save data. This should not be problematic as you will need to set the player manually using 
            this method for each new gaming session, so you can override it each time you do so.
            </para>
            </param>
            <param name="ignorePlayerPositionInPersistentData" type="bool">
            If overrideIgnorePlayerPositionInPersistentData is true, this value is used to determine whether the Player's positional data stored 
            in SAM's persistent save data will be ignored. The value you set is used only for this session, so for each new session where 
            you call this method, you should pass in the same value. See the info for overrideIgnorePlayerPositionInPersistentData for more information.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the Active has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when null is passed in for newPlayer.
            </exception>
            <displayName id="PreInitialize_SetPlayer2">
            PreInitialize_SetPlayer(IPlayer, PlayerMover, bool, [bool])
            </displayName>
            <syntax>
            public void PreInitialize_SetPlayer(IPlayer newPlayer, PlayerMover newPlayerMover, bool overrideIgnorePlayerPositionInPersistentData, bool ignorePlayerPositionInPersistentData = false)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.PreInitialize_SetLoadingBlueprintByID(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Changes either the Fallback <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> used by the 
            Active Grid Grouping indicated (if zoneName is null), or the Loading Blueprint Override for a specific Zone only (if zoneName is not null).
            <para>
            This allows for the initial 
            blueprint to be different than what it normally is. This method is recommended over the other PreInitialize_SetLoadingBlueprint... 
            methods as the ID is more consistent (names can be changed and the Blueprint Index may change as a result of Blueprints 
            being removed, but the ID will remain the same forever unlesss the Blueprint itself is removed).
            </para>
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController class, if you need to save 
            different data in different places (on the server, on a file on the users system, etc.). Note, if all your data is stored in the same place, you are 
            better off using a custom class that derives from IPersistentDataController, and then set it up to save data to that location.
            </para>
            <para>
            This must be called before the Active Grid has been initialized.
            </para>
            <para>
            If zoneName is not null, the Blueprint will only apply to the Zone specified. If a Zone Blueprint Override already exists 
            (because it was added in the inspector), it will be updated 
            with the new Blueprint, otherwise a new runtime only override will be added. 
            If at some point you don't wish for this override to apply any longer, you must 
            remove it (after which, when synced to the specified Zone, the Fallback Loading Blueprint for the Active Grid Grouping will be used).
            </para>
            <para>
            If zoneName is null, the blueprint change is applied to the Fallback Loading Blueprint for the Active Grid Grouping specified. This Grouping will 
            use that Blueprint when synced to any Zone that does not have a Zone Blueprint Override.
            </para>
            <para>
            Changes made here will be saved when saving persistent data, unless overwriteLoadingBlueprintFromPersistentData is false and you load 
            persistent data after calling this method.
            </para>
            </summary>
            <param name="groupingIndex" type="int">
            The index of the Active Grid Grouping to change.
            </param>
            <param name="loadingBlueprintID" type="int">
            The ID of the Loading Blueprint. This can be seen in the Loading Blueprint Repository Inspector, in the parentheses after the Blueprint Type.
            </param>
            <param name="overwritePersistentDataSettings" type="bool">
             When zoneName is null, determines whether the new loading blueprint you indicated should overwrite the fallback loading blueprint 
            found in persistent data for this Active Grid Grouping (if any exist).
            <para>
            When zoneName is not null, this determines whether the blueprint you indicated should overwrite the loading blueprint found in 
            persistent data, when a Zone Blueprint Override exists in that data. It will also determine whether removed overrides for the Zone found 
            in persistent data will be honored. If you pass in true and a removed override is found, that removed override will be ignored and 
            so the Blueprint specified here will remain in use until you remove the override for the zone. If you pass in false and a removed override 
            is found, the override will be removed, cancelling out the blueprint set here.
            </para>
            </param>
            <param name="zoneName" type="[string]">
            The name of the Zone to apply this blueprint to, or null if you want the blueprint to be applied to the Fallback Loading Blueprint for the 
            Active Grid Grouping instead.
            </param>
            <displayName id="PreInitialize_SetLoadingBlueprintByID">
            PreInitialize_SetLoadingBlueprintByID(int, int, bool, [string])
            </displayName>
            <syntax>
            public void PreInitialize_SetLoadingBlueprintByID(int groupingIndex, int loadingBlueprintID, bool overwritePersistentDataSettings, string zoneName = null)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the Active has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the ID does not correspond to a valid blueprint in the repository.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.PreInitialize_SetLoadingBlueprintByIndex(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Changes either the Fallback <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> used by the 
            Active Grid Grouping indicated (if zoneName is null), or the Loading Blueprint Override for a specific Zone only (if zoneName is not null).
            <para>
            This allows for the initial 
            blueprint to be different than what it normally is.
            </para>
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController class, if you need to save 
            different data in different places (on the server, on a file on the users system, etc.). Note, if all your data is stored in the same place, you are 
            better off using a custom class that derives from IPersistentDataController, and then set it up to save data to that location.
            </para>
            <para>
            This must be called before the Active Grid has been initialized.
            </para>
            <para>
            If zoneName is not null, the Blueprint will only apply to the Zone specified. If a Zone Blueprint Override already exists 
            (because it was added in the inspector), it will be updated 
            with the new Blueprint, otherwise a new runtime only override will be added. 
            If at some point you don't wish for this override to apply any longer, you must 
            remove it (after which, when synced to the specified Zone, the Fallback Loading Blueprint for the Active Grid Grouping will be used).
            </para>
            <para>
            If zoneName is null, the blueprint change is applied to the Fallback Loading Blueprint for the Active Grid Grouping specified. This Grouping will 
            use that Blueprint when synced to any Zone that does not have a Zone Blueprint Override.
            </para>
            <para>
            Changes made here will be saved when saving persistent data, unless overwriteLoadingBlueprintFromPersistentData is false and you load 
            persistent data after calling this method.
            </para>
            </summary>
            <param name="groupingIndex" type="int">
            The index of the Active Grid Grouping to change.
            </param>
            <param name="loadingBlueprintIndex" type="int">
            The index of the new loading blueprint to use. You can find this index by looking at the 
            inspector of the <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.LoadingBlueprintRepository" href="LoadingBlueprintRepository.html">Loading Blueprint Repository</see> connected to 
            this Active Grid (the only you assigned in this Active Grid's inspector). The index is found to the left of each loading blueprint name.
            </param>
            <param name="overwritePersistentDataSettings" type="bool">
             When zoneName is null, determines whether the new loading blueprint you indicated should overwrite the fallback loading blueprint 
            found in persistent data for this Active Grid Grouping (if any exist).
            <para>
            When zoneName is not null, this determines whether the blueprint you indicated should overwrite the loading blueprint found in 
            persistent data, when a Zone Blueprint Override exists in that data. It will also determine whether removed overrides for the Zone found 
            in persistent data will be honored. If you pass in true and a removed override is found, that removed override will be ignored and 
            so the Blueprint specified here will remain in use until you remove the override for the zone. If you pass in false and a removed override 
            is found, the override will be removed, cancelling out the blueprint set here.
            </para>
            </param>
            <param name="zoneName" type="[string]">
            The name of the Zone to apply this blueprint to, or null if you want the blueprint to be applied to the Fallback Loading Blueprint for the 
            Active Grid Grouping instead.
            </param>
            <displayName id="PreInitialize_SetLoadingBlueprintByIndex">
            PreInitialize_SetLoadingBlueprintByIndex(int, int, bool, [string])
            </displayName>
            <syntax>
            public void PreInitialize_SetLoadingBlueprintByIndex(int groupingIndex, int loadingBlueprintIndex, bool overwritePersistentDataSettings, string zoneName = null)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the Active has been initialized.
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if the index is not valid (less than 1 or greater than the number of blueprints in the respository)
            </exception>
            <exception cref="T:System.NullReferenceException">
            Thrown if the index points to a null blueprint, which should never happen. If it does, please contact me!!
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.PreInitialize_SetLoadingBlueprintByName(System.Int32,System.String,System.Boolean,System.String)">
            <summary>
            Changes either the Fallback <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> used by the 
            Active Grid Grouping indicated (if zoneName is null), or the Loading Blueprint Override for a specific Zone only (if zoneName is not null).
            <para>
            This allows for the initial 
            blueprint to be different than what it normally is.
            </para>
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController class, if you need to save 
            different data in different places (on the server, on a file on the users system, etc.). Note, if all your data is stored in the same place, you are 
            better off using a custom class that derives from IPersistentDataController, and then set it up to save data to that location.
            </para>
            <para>
            This must be called before the Active Grid has been initialized.
            </para>
            <para>
            If zoneName is not null, the Blueprint will only apply to the Zone specified. If a Zone Blueprint Override already exists 
            (because it was added in the inspector), it will be updated 
            with the new Blueprint, otherwise a new runtime only override will be added. 
            If at some point you don't wish for this override to apply any longer, you must 
            remove it (after which, when synced to the specified Zone, the Fallback Loading Blueprint for the Active Grid Grouping will be used).
            </para>
            <para>
            If zoneName is null, the blueprint change is applied to the Fallback Loading Blueprint for the Active Grid Grouping specified. This Grouping will 
            use that Blueprint when synced to any Zone that does not have a Zone Blueprint Override.
            </para>
            <para>
            Changes made here will be saved when saving persistent data, unless overwriteLoadingBlueprintFromPersistentData is false and you load 
            persistent data after calling this method.
            </para>
            </summary>
            <param name="groupingIndex" type="int">
            The index of the Active Grid Grouping to change.
            </param>
            <param name="loadingBlueprintName" type="string">
            The name of the new loading blueprint to use. This must match one of the Loading Blueprints in the 
            <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.LoadingBlueprintRepository" href="LoadingBlueprintRepository.html">Loading Blueprint Repository</see> connected to 
            this Active Grid via the Active Grid's inspector.
            </param>
            <param name="overwritePersistentDataSettings" type="bool">
            When zoneName is null, determines whether the new loading blueprint you indicated should overwrite the fallback loading blueprint 
            found in persistent data for this Active Grid Grouping (if any exist).
            <para>
            When zoneName is not null, this determines whether the blueprint you indicated should overwrite the loading blueprint found in 
            persistent data, when a Zone Blueprint Override exists in that data. It will also determine whether removed overrides for the Zone found 
            in persistent data will be honored. If you pass in true and a removed override is found, that removed override will be ignored and 
            so the Blueprint specified here will remain in use until you remove the override for the zone. If you pass in false and a removed override 
            is found, the override will be removed, cancelling out the blueprint set here.
            </para>
            </param>
            <param name="zoneName" type="[string]">
            The name of the Zone to apply this blueprint to, or null if you want the blueprint to be applied to the Fallback Loading Blueprint for the 
            Active Grid Grouping instead.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the Active Grid has been initialized.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidNameException" link="InvalidNameException.html">
            Thrown if the name does not correspond to a valid loading blueprint on the repository.
            </exception>
            <displayName id="PreInitialize_SetLoadingBlueprintByName">
            PreInitialize_SetLoadingBlueprintByName(int, string, bool, [string])
            </displayName>
            <syntax>
            public void PreInitialize_SetLoadingBlueprintByName(int groupingIndex, string loadingBlueprintName, bool overwritePersistentDataSettings, string zoneName = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.PreInitialize_RemoveZoneBlueprintOverride(System.Int32,System.Boolean,System.String)">
            <summary>
            Attempts to remove a Zone Blueprint Override which has been added in the inspector or added via a call to one of the PreInitialize_SetLoadingBlueprint... 
            methods (in which a zoneName was been passed in).
            </summary>
            <param name="groupingIndex" type="int">
            The index of the Active Grid Grouping to change.
            </param>
            <param name="overwritePersistentDataSettings" type="bool">
            Whether the removal operation should override any persistent data settings that have or may be loaded. If you pass in true and 
            a Zone Blueprint Override exist for the specified zoneName, that Blueprint will not be applied since the override technically no longer 
            exist. Conversely, if you pass in false and a Zone Blueprint Override exists, that Blueprint will be applied and this removal operation will 
            be "canceled out" so to speak.
            </param>
            <param name="zoneName" type="string">
            The name of the Zone whose override should be removed.
            </param>
            <displayName id="PreInitialize_RemoveZoneBlueprintOverride">
            PreInitialize_RemoveZoneBlueprintOverride(int, bool, string)
            </displayName>
            <syntax>
            public void PreInitialize_RemoveZoneBlueprintOverride(int groupingIndex, bool overwritePersistentDataSettings, string zoneName)
            </syntax>
             <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the Active Grid has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerAndChangeOriginCellOfWorld(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Double,System.Boolean)">
            <summary>
            Tries to change the Origin Cell of the synced to World to the passed in newOriginCell while moving the player to a new location in the World. 
            Unlike the World's ChangeOriginCell method, this method 
            offers more options for how the Player will be moved, allowing you to position the player exactly as you want once the Origin Cell 
            change is complete.
            <para>
            However, the process of doing this is not as seamless as the normal Origin Cell change process, as the current cells associated 
            with the player's current position are removed at the same time as new cells at the new position are added; as such, it's very 
            likely the player will notice what's going on. As such, this method should only be used with some kind of obfuscation technique to hide 
            what's happening in the game world from the player. At the very least, you should usually disable the player's movement while the method is executing (to 
            keep them from falling through the world when the old cells are removed), however this is up to you.
            </para>
            <para>
            It should be noted that when the World's Origin Change Strategy is set to Duplicate World, the method will only complete execution after the 
            old World Cells (and Asset Chunks) that used the previous Origin Cell are removed. This is necessary to ensure the player is not re-activated while 
            lingering Assets are left in the scene, however it may throw off the timing of the Player being moved. If this is a concern for you, you should switch 
            to using a World Shifter to perform the Origin Cell change.
            </para>
            <para>
            The main purpose of this method is to allow you to change the player's position within the game world while simultaneously 
            updating the Origin Cell of the world, in a manner that avoids asset chunks being moved outside of the valid floating point range, which may cause 
            issues for your game. It's useful in situations where you can obfuscate the game world, for instance imagine a Skyrim like fast travel system where a 
            loading screen is displayed when fast travel is used. If you need a method that doesnt invovle obfuscating the game world, you will need to use a 
            combination of a manual World Cell Origin change via the World's 
            <see cref="M:DeepSpaceLabs.SAM.World.ChangeOriginCell(DeepSpaceLabs.SAM.Cell)" href="World.html#ChangeOriginCell">ChangeOriginCell</see> method, followed by a call to this Active Grid's 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocation(DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Boolean,System.Boolean,System.Double)" href="ActiveGrid.html#TryMovePlayerToLocation">TryMovePlayerToLocation</see>. This technique will take longer 
            and the player and game world may temporarily travel outside the valid floating point range, but unfortunately it is the only way to execute an 
            Origin Cell change and player movement in game, without obfuscating the game world. Do note, if using the Duplicate World origin change strategy, you 
            will need to make sure to choose a new Origin Cell that doesn't result in overlap between the new world cells (using the new Origin Cell) and the 
            old world cells (which are only removed after the new world is constructed).
            </para>
            <para>
            Do note that this method will trigger a normal Origin Cell Change on the World, which has the following consequences:
            </para>
            <para>
            1) If a World Shifter is being used by the World and it is set to shift the Player's position, it will do so as normal. Any movement 
            performed by this method will take place after, so the final position of the player will be correctly set to whatever 
            you set here (assuming overridePostChangePlayerPosition is true).
            </para>
            <para>
            2) Any IWorldUsers registered with the World will be notified of the Origin Cell Change, and their appropriate callback methods will be invoked as 
            a result. This includes any Active Grids registered with the World, including the one you call the TryChangeOriginCellOfWorld method with. When 
            overridePostChangePlayerPosition is true, however, the Active Grid will not move the player within its Origin Cell Changed callback methods, 
            even when Move Player After Origin Cell Change is enabled, as doing so would be redundant.
            </para>
            <para>
            With that said, it is very likely to be impossible to keep the player from noticeing the processing of the 
            Origin Cell change, and as such it usually is a good idea to obscure the world in some way while the 
            origin update is in progress, with a loading screen or some kind of visual effect.
            </para>
            There are also options to manually move the player with this method, however this move will be carried out through a simple 
            IPlayer.Position set operation rather than using the Player Mover (if attached), and will be performed after the 
            player position is shifted during the Origin Cell Change operation.
            <para>
            In situations where you are not using a loading screen, it may make more sense to utilize the 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocation(DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Boolean,System.Boolean,System.Double)" href="#TryMovePlayerToLocation">TryMovePlayerToLocation</see> 
            method instead, as there is less disruption to the currently loaded World Cells, and so 
            the player should not notice the world being updated during
            the move process. Note, however, if you are using an exceptionally large world, moving the player to a location very far 
            from the origin may not be possible due to floating point issues, in which case this Origin Cell change method will need 
            to be used instead.
            </para>
            </summary>
            <param name="newOriginCell" type="Cell" link="Cell.html">
            The Endless Grid Cell which will become the Origin Cell of the World the Active Grid is currently synced to. 
            Note, this can be a cell with indexes outside the 
            range of the Streamable Grid this Active Grid is synced to if using an endless world.
            </param>
            <param name="playerPositionAfterChange" type="Vector3Double" link="Vector3Double.html">
            If movePlayerAfterChange is true, the player will be moved to this location. The location can either be 
            an absolute position in the scene, or a position relative to the new Origin Cell. You can control which 
            behaviour is used using the positionRelativeToOriginCell argument.
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If movePlayerAfterChange and setPlayerYPositionBasedOnTerrain are true, the player's y location will be 
            set based on the terrain whose bounds the player is within (i.e, the y location in playerPositionAfterChange 
            will be ignored).
            <para>
            Note that this value will apply to any future automatic movements of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <param name="playerYOffset" type="double">
            If movePlayerAfterChange and setPlayerYPositionBasedOnTerrain are true, 
            you can pass in an offset value which will be added to the player's calculated 
            position (based on the terrain). This is necessary since setting the player's 
            y position to the calculated position would likely cause the player to 
            overlap the terrain, which is not ideal.
            <para>
            Note that this value applies to any future automatic movement of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <param name="positionRelativeToOriginCell" type="bool">
            Is the playerPositionAfterChange relative to scene space (false) or the new Origin Cell (true). If 
            setPlayerYPositionBasedOnTerrain is false, this also dictates whether the y value of 
            playerPositionAfterChange is relative to the WorldSyncedTo or Origin Cell.
            <para>
            If the position is relative 
            to the Origin Cell, then the final position the player will be moved to is 
            playerPositionAfterChange + OriginCell.position. If the position is relative to scene space, then 
            playerPositionAfterChange is the position the player will be moved to.
            </para>
            <para>
            Note, if the Origin Cell's position is x = 0, y = 0, and z = 0, then the player's position after the change will be the same regardless of this value.
            </para>
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryChangeOriginCellOfWorld(Cell newOriginCell, Vector3Double playerPositionAfterChange, bool setPlayerYPositionBasedOnTerrain = false, double playerYOffset = 1f, bool positionRelativeToOriginCell = false)
            </syntax>
            <displayName id = "TryChangeOriginCellOfWorld">
            TryChangeOriginCellOfWorld(Cell, Vector3Double, [bool], [double], [bool])
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the <see href="YieldInstruction.html">YieldInstruction</see> page for more info.</returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when a WorldSyncedTo is not associated with the grid, when the Active Grid has not been initialized yet, 
            when this method is called while the 
            Active Grid is busy executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with 
            "Try"), when setPlayerYPositionBasedOnTerrain is true but the Current WorldSyncedTo does not use Unity Terrain or chunks 
            are not enabled on the Active Grid, or when a player is not associated with the grid but movePlayerAfterChange is true.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocation(DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Boolean,System.Boolean,System.Double)">
            <summary>
            Tries to move the player associated with this Active Grid to the location specified.
            <para>
            This method fully loads the cells (and objects if necessary) around the target location before 
            moving the player (this occurs over several frames).
            </para>
            <para>
            Once loaded, if waitForCommandBeforeMovingPlayer is true, this method will yield until 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.InitiatePendingMove" href="#InitiatePendingMove">InitiatePendingMove</see> is called. If false, this method
            will move the player immediately after the objects at the new location are loaded.
            </para>
            <para>
            If waitForCommandBeforeMovingPlayer is true, you can query the PlayerReadyToBeMoved property to make sure the 
            Active Grid has loaded the new area before calling InitiatePendingMove (otherwise, there is no guarantee the player 
            will be moved immediately after calling InitiatePendingMove).
            </para>
            <para>
            Depending on the <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.PlayerMover" href = "PlayerMover.html">PlayerMover</see>
            used by this Active Grid, the actual move operation may also take several frames.
            </para>
            <para
            >This method, like all Try methods in this API, will throw an exception when
            a coroutine operation is Currently being executed by this Active Grid. 
            The best way to account for this possibility is to simply
            check to make sure the Active Grid is not busy before calling this move method, which you can do by checking
            the Active Grid's <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.IsBusy" href = "#IsBusy">IsBusy</see> property.
            </para>
            </summary>
            <param name="location" type = "Vector3Double">
            The location to move the player to.
            </param>
            <param name="waitForCommandBeforeMovingPlayer" type = "bool">
            If true, the new area that the player will be moved to will be loaded, but the actual move operation will
            be delayed until the <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.InitiatePendingMove" href = "#InitiatePendingMove">InitiatePendingMove</see> 
            method is called. If false, the move will be performed immediately after the new area is loaded.
            </param>
            <param name="waitForOldObjectsToBeRemoved" type="bool">
            If true, the coroutine will not exit/yield break until the pre move objects that are no longer needed are removed.
            <para>
            This is mostly useful if displaying a loading screen and you only want to remove the 
            loading screen when the WorldSyncedTo 
            is completely up to date, or if you think the old objects might intersect with the new ones, which would look quite bad to the player if seen.
            </para>
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If true, the y value in location will be ignored and the y position to move the player to will be calculated based on the 
            height of the terrain at the location to move the player to. Only set this to true if you know the Active Grid is synced 
            to a WorldSyncedTo that is using Terrains. If there is no terrain at the location, the location's y value will be used.
            <para>
            Note that this value applies to any future automatic movement of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <param name="playerYOffset" type="double">
            When setPlayerYPositionBasedOnTerrain is true, this value can be used to ensure the 
            player does not overlap the terrain. A value of 1, for instance, 
            will place the player 1 unit above the terrain's height. You will need to experiment 
            to find the best value, as it will depend largely upon the 
            shape and height of your player's collider.
            <para>
            Note that this value applies to any future automatic movement of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryMovePlayerToLocation(Vector3Double location, bool waitForCommandBeforeMovingPlayer, bool waitForOldObjectsToBeRemoved, bool setPlayerYPositionBasedOnTerrain = false, double playerYOffset = 1f)
            </syntax>
            <displayName id = "TryMovePlayerToLocation">
            TryMovePlayerToLocation(Vector3Double, bool, bool, [bool], [double])
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when no player or WorldSyncedTo is associated with the grid, when the Active Grid has not been initialized yet, 
            or when this method is called while the 
            Active Grid is busy executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with 
            "Try"), or when setPlayerYPositionBasedOnTerrain is true but the Current WorldSyncedTo does not use Unity Terrain or chunks 
            are not enabled on the Active Grid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocationOnNewWorld(DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.World,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Int32)">
            <summary>
            Tries to move the player associated with this Active Grid to the location specified on the new World, 
            and if the move is successful, syncs the Active Grid to this new World.
            <para>
            This method fully loads the cells (and objects if necessary) around the target location before 
            moving the player (this occurs over several frames).
            </para>
            <para>
            Once loaded, if waitForCommandBeforeMovingPlayer is true, this method will yield until 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.InitiatePendingMove" href="#InitiatePendingMove">InitiatePendingMove</see> is called. If false, this method
            will move the player immediately after the objects at the new location are loaded.
            </para>
            <para>
            If waitForCommandBeforeMovingPlayer is true, you can query the <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.PlayerReadyToBeMoved" href="#PlayerReadyToBeMoved">PlayerReadyToBeMoved</see> property to make sure the 
            Active Grid has loaded the new area before calling InitiatePendingMove (otherwise, there is no guarantee the player 
            will be moved immediately after calling InitiatePendingMove).
            </para>
            <para>
            Depending on the <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.PlayerMover" href = "PlayerMover.html">PlayerMover</see>
            used by this Active Grid, the actual move operation may also take several frames.
            </para>
            <para>
            This method, like all Try methods in this API, will throw an exception when
            a coroutine operation is currently being executed by this Active Grid. 
            The best way to account for this possibility is to simply
            check to make sure the Active Grid is not busy before calling this method, which you can do by checking
            the Active Grid's <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.IsBusy" href = "#IsBusy">IsBusy</see> property.
            </para>
            </summary>
            <param name="location" type = "Vector3Double">
            The location to move the player to.
            </param>
            <param name = "newWorldToSyncTo" type = "World" link = "World.html">
            The new World to sync to.
            </param>
            <param name="waitForCommandBeforeMovingPlayer" type = "bool">
            If true, the new area that the player will be moved to will be loaded, but the actual move operation will
            be delayed until the <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.InitiatePendingMove" href = "#InitiatePendingMove">InitiatePendingMove</see> method 
            is called. If false, the move will be performed immediately after the new area is loaded.
            </param>
            <param name = "allowGridToRecenterWorld" type = "bool">
            If true, the grid will be permitted to force the World To re-center itself when the player crosses the re-centering boundary (assuming 
            'Allow Active Grid Re-Centering' is enabled on the World).
            </param>
            <param name="waitForOldObjectsToBeRemoved" type="bool">
            If true, the coroutine will not exit/yield break until the pre sync/move objects that 
            are no longer needed are removed.
            <para>
            This is mostly useful if displaying a loading screen and you only want to remove the 
            loading screen when the WorldSyncedTo 
            is completely up to date, or if you think the old objects might intersect with the new ones, which would look quite bad to the player if seen.
            </para>
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If true, the y value in location will be ignored and the y position to move the player to will be calculated based on the 
            height of the terrain at the location to move the player to. Only set this to true if you know 
            the newWorldToSyncTo uses Terrain. If there is no terrain at the location, the location's y value will be used.
            <para>
            Note that this value applies to any future automatic movement of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <param name="playerYOffset" type="double">
            When setPlayerYPositionBasedOnTerrain is true, this value can be used to ensure the player does not overlap the terrain. 
            A value of 1, for instance, 
            will place the player 1 unit above the terrain's height. You will need to experiment to find the best value, as it 
            will depend largely upon the shape and height of your player's collider.
            <para>
            Note that this value applies to any future automatic movement of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <param name="groupingWithTerrainToAlignPlayerTo" type="int">
            The World Grouping on the new world that contains the terrain to align the player to. This is usually the base World Grouping (Layer 1)
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when no player is associated with the grid, when the Active Grid has not been initialized yet, or when this 
            method is called while the Active Grid is busy 
            executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with "Try"), or 
            when setPlayerYPositionBasedOnTerrain is true but the new WorldSyncedTo to sync to does not use Unity Terrain or chunks 
            are not enabled on the Active Grid.
            </exception>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryMovePlayerToLocationOnNewWorld(Vector3Double location, World newWorldToSyncTo, bool waitForCommandBeforeMovingPlayer, bool allowGridToRecenterWorld, bool waitForOldObjectsToBeRemoved, bool setPlayerYPositionBasedOnTerrain = false, double playerYOffset = 1f, int groupingWithTerrainToAlignPlayerTo = 1)
            </syntax>
            <displayName id = "TryMovePlayerToLocationOnNewWorld">
            TryMovePlayerToLocationOnNewWorld(Vector3Double, World, bool, bool, bool, [bool], [double], [int])
            </displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TrySyncToNewWorldAroundPlayer(DeepSpaceLabs.SAM.World,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Boolean,System.Int32)">
            <summary>
            Tries to sync to the new WorldSyncedTo at the player's Current position.
            <para>
            This method fully loads the cells (and objects if necessary) of the new WorldSyncedTo, and then removes the 
            cells (and objects) of the old WorldSyncedTo.
            </para>
            <para>
            This method, like all Try methods in this API, will throw an exception when
            a coroutine operation is Currently being executed by this Active Grid. 
            The best way to account for this possibility is to simply
            check to make sure the Active Grid is not busy before calling this method, which you can do by checking
            the Active Grid's <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.IsBusy" href = "#IsBusy">IsBusy</see> property.
            </para>
            </summary>
            <param name = "newWorldToSyncTo" type = "World" link = "World.html">
            The new World to sync to.
            </param>
            <param name = "allowGridToRecenterWorld" type = "bool">
            If true, the grid will be permitted to force the World To re-center itself when the player crosses the re-centering boundary (assuming 
            'Allow Active Grid Re-Centering' is enabled on the World).
            </param>
            <param name="waitForOldObjectsToBeRemoved" type="bool">
            If true, the coroutine will not exit/yield break until the pre sync objects that are 
            no longer needed are removed.
            <para>
            This is mostly useful if displaying a loading screen and you only want to remove 
            the loading screen when the scene is completely up to date. This is especially useful for this method because it's almost guaranteed that the new objects 
            will intersect the old objects, which if seen by the player, would look quite bad.
            </para>
            </param>
            <param name="setPlayerYPositionBasedOnTerrain" type="bool">
            If true, once the new WorldSyncedTo is loaded, the y position of the player will be 
            adjusted to that of the terrain the player is on (plus the playerYOffset).
            If a Player Mover exist on the Active Grid, it will be used to move the player.
            <para>
            Note that this value applies to any future automatic movement of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <param name="playerYOffset" type="double">
            When setPlayerYPositionBasedOnTerrain is true, this value can be used to ensure 
            the player does not overlap the terrain. A value of 1, for instance, 
            will place the player 1 unit above the terrain's height. You will need to experiment 
            to find the best value, as it will depend largely upon the 
            shape and height of your player's collider.
            <para>
            Note that this value applies to any future automatic movement of the player by the Active Grid, such 
            as when a world shift occurs.
            </para>
            </param>
            <param name="waitForCommandBeforeMovingPlayer" type="bool">
            This variable only applies when setPlayerYPositionBasedOnTerrain is true, otherwise the player will not be moved at all 
            and this variable will not be useful. When setPlayerYPositionBasedOnTerrain, this controls whether the method should 
            wait for a manual move command before changing the player's y position. This move command is supplied via the 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.InitiatePendingMove" href = "#InitiatePendingMove">InitiatePendingMove</see> method, which you will 
            call.
            <para>
            If waitForCommandBeforeMovingPlayer is true, you should query the PlayerReadyToBeMoved property to make sure the 
            Active Grid has loaded the new area before calling InitiatePendingMove (otherwise, there is no guarantee the player 
            will be moved immediately after calling InitiatePendingMove).
            </para>
            </param>
            <param name="groupingWithTerrainToAlignPlayerTo" type="int">
            The World Grouping on the new world that contains the terrain to align the player to. This is usually the base World Grouping (Grouping 1)
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TrySyncToNewWorldAroundPlayer(World newWorldToSyncTo, bool allowGridToRecenterWorld, bool waitForOldObjectsToBeRemoved, bool setPlayerYPositionBasedOnTerrain = false, double playerYOffset = 1f, bool waitForCommandBeforeMovingPlayer = false, int groupingWithTerrainToAlignPlayerTo = 1)
            </syntax>
            <displayName id = "TrySyncToNewWorldAroundPlayer">
            TrySyncToNewWorldAroundPlayer(World, bool, bool, [bool], [double], [bool], [int])
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.RequiredComponentNotFoundException" link = "RequiredComponentNotFoundException.html">
            Thrown when a Player Transform has not been supplied to the Active Grid.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when no player is associated with the grid, when the Active Grid has not been initialized yet, when this 
            method is called while the Active Grid is busy
            executing a multi frame action (check IsBusy before calling ActiveGrid methods that begin with "Try"), or 
            when setPlayerYPositionBasedOnTerrain is true but the new WorldSyncedTo to 
            sync to does not use Unity Terrain or chunks 
            are not enabled on the Active Grid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryDesyncFromCurrentWorld">
            <summary>
            Tries to de-sync the Active Grid from the World it is Currently synced to.
            </summary>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called before the grid has been initialized or 
            while the Active Grid is busy executing a multi frame action. 
            Check IsBusy before calling ActiveGrid methods that begin with "Try".
            </exception>
            <displayName id="TryDesyncFromCurrentWorld">TryDesyncFromCurrentWorld()</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; TryDesyncFromCurrentWorld()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean)">
            <summary>
            Attempts to set the "Update World" property of all Groupings on the Active Grid. Pass in true if you want all Groupings 
            to update the World the Active Grid is synced to, or false if you do not want them to update the World.
            <para>
            With world upates enabled, the Active Grid will update the World on which cells are loaded for each Active Grid Grouping that 
            has a matching Grouping on the World.
            </para>
            <para>
            It does this when the Active Grid is initially initilized (by sending the list of cells that are initially 
            loaded on the World Grouping based on the player's initial position), and also when the collection of cells tracked by 
            the Active Grid are updated dynamically as a result of the player moving across the current inner area boundary of 
            each Active Grid Grouping (however, this only occurs if 'Enable Auto Tracking' is enabled for each layer).
            </para>
            <para>
            The inner area boundary is calculated using the Loading Blueprint used by the Active Grid Grouping, 
            as well as the dimensions of the cells on the same World Grouping on the World the Active Grid is sycned 
            to (more specifically, the Streamable Grid of the World Grouping).
            </para>
            <para>
            This method will likely result in World Cells on the WorldSyncedTo to be loaded or unloaded, however using this 
            by itself will not allow you to track when that happens. This method will also not allow for the player to be 
            aligned to a Terrain when worldShouldBeUpdated. If you need player alignment to be performed, or need to know 
            when the World Cells are loaded/unloaded as a result of Update World being set, you should use the 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(System.Boolean)" href="#TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate1">TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate</see> 
            method instead.
            </para>
            <para>
            Note that it's possible that the Active Grid has Groupings that cannot be matched to the World. In this case, all groupings 
            on the Active Grouping are updated, even if a Grouping does not have a matching Grouping on the World. In this way, if the 
            Active Grid becomes synced to a World that does have a matching Grouping, the value you set will be applied to it.
            </para>
            </summary>
            <param name="worldShouldBeUpdated" type="bool">
            Whether the world should be updated for all Groupings of the Active Grid.
            </param>
            <displayName id="TrySetIfWorldShouldBeUpdated1">
            TrySetIfWorldShouldBeUpdated(bool)
            </displayName>
            <syntax>
            public void TrySetIfWorldShouldBeUpdated(bool worldShouldBeUpdated)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the Active Grid has not been initialized or if the method is called while the Active Grid 
            is already busy. You should always check if the Active Grid is busy 
            before calling any method that begins with Try!
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(System.Boolean)">
            <summary>
            Attempts to set the "Update World" property of all Groupings on the Active Grid. Pass in true if you want all Groupings 
            to update the World the Active Grid is synced to, or false if you do not want them to update the World.
            <para>
            With world upates enabled, the Active Grid will update the World on which cells are loaded for each Active Grid Grouping that 
            has a matching Grouping on the World.
            </para>
            <para>
            It does this immediately (by sending the list of cells that are currently 
            'loaded' on the Layer), and also when the collection of cells tracked by 
            each Active Grid Grouping is updated dynamically as a result of the player moving across the current inner area boundary of 
            that Grouping (however, this only occurs if 'Enable Auto Tracking' is enabled for each layer).
            </para>
            <para>
            The inner area boundary is calculated using the Loading Blueprint used by the Active Grid Grouping, 
            as well as the dimensions of the cells on the matching World Grouping for each Active Grid Grouping.
            </para>
            <para>
            This method is the same as 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean)" href="#TrySetIfWorldShouldBeUpdated1">TrySetIfWorldShouldBeUpdated</see>, 
            except that this method will wait for the World the Active Grid is synced to to complete a full update. This ensures that 
            the World Cells on the WorldSyncedTo associated with the cells of the Active Grid are either loaded (when worldShouldBeUpdated 
            is true) or unloaded (when worldShouldBeUpdated is false). This allows you to wait for the game world to either be 
            loaded (and in a playable state) or unloaded before continuing with some other action (such as removing a loading screen).
            </para>
            <para>
            In addition, when worldShouldBeUpdated is true and Align Player To Terrain is enabled in the inspector of this 
            Active Grid, after waiting for a world update, the method will align the player to the Terrain. This is not done 
            with the normal 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean)" href="#TrySetIfWorldShouldBeUpdated1">TrySetIfWorldShouldBeUpdated</see> 
            method, so if you need the player to be aligned to the Terrain, you must use this coroutine method, regardless of 
            whether you care about waiting for a World update.
            </para>
            </summary>
            <param name="worldShouldBeUpdated" type="bool">
            Whether the world should be updated for all Groupings of the Active Grid.
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(bool worldShouldBeUpdated)
            </syntax>
            <displayName id = "TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate1">
            TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(bool)
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the Active Grid has not been initialized or if the method is called while the Active Grid 
            is already busy. You should always check if the Active Grid is busy 
            before calling any method that begins with Try!
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean,System.Int32)">
            <summary>
            Attempts to set the "Update World" property of a single Grouping on the Active Grid. Pass in true if you want the Grouping  
            to update the World the Active Grid is synced to, or false if you do not want it to update the World.
            <para>
            With world upates enabled, the Active Grid will update the World on which cells are loaded for the Active Grid Grouping. 
            It does this when the Active Grid is initially initilized (by sending the list of cells that are initially 
            loaded on the World Grouping based on the player's initial position), and also when the collection of cells tracked by 
            the Active Grid are updated dynamically as a result of the player moving across the current inner area boundary of 
            the Active Grid Grouping (however, this only occurs if 'Enable Auto Tracking' is enabled for the Layer).
            </para>
            <para>
            The inner area boundary is calculated using the Loading Blueprint used by the Active Grid Grouping, 
            as well as the dimensions of the cells on the same World Grouping on the World the Active Grid is sycned 
            to (more specifically, the Streamable Grid of the World Grouping).
            </para>
            </summary>
            <param name="worldShouldBeUpdated" type="bool">
            Whether the world should be updated for the Grouping of the Active Grid.
            </param>
            <param name="groupingIndex" type="int">
            The index of the Grouping on the Active Grid whose "Update World" property will be set.
            </param>
            <displayName id="TrySetIfWorldShouldBeUpdated2">
            TrySetIfWorldShouldBeUpdated(bool, int)
            </displayName>
            <syntax>
            public void TrySetIfWorldShouldBeUpdated(bool worldShouldBeUpdated, int groupingIndex)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the Active Grid has not been initialized or if the method is called while the Active Grid 
            is already busy. You should always check if the Active Grid is busy 
            before calling any method that begins with Try!
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(System.Boolean,System.Int32)">
            <summary>
            Attempts to set the "Update World" property of a single Grouping on the Active Grid. Pass in true if you want the Grouping  
            to update the World the Active Grid is synced to, or false if you do not want it to update the World.
            <para>
            With world upates enabled, the Active Grid will update the World on which cells are loaded for the Active Grid Grouping. 
            It does this immediately (by sending the list of cells that are currently 
            'loaded' on the Grouping), and also when the collection of cells tracked by 
            the Active Grid are updated dynamically as a result of the player moving across the current inner area boundary of 
            the Active Grid Grouping (however, this only occurs if 'Enable Auto Tracking' is enabled for the Grouping).
            </para>
            <para>
            The inner area boundary is calculated using the Loading Blueprint used by the Active Grid Grouping, 
            as well as the dimensions of the cells on the same World Grouping on the World the Active Grid is sycned 
            to (more specifically, the Streamable Grid of the World Grouping).
            </para>
            <para>
            This method is the same as 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean,System.Int32)" href="#TrySetIfWorldShouldBeUpdated2">TrySetIfWorldShouldBeUpdated</see>, 
            except that the method will wait for the World the Active Grid is synced to to complete a full update. This ensures that 
            the World Cells on the WorldSyncedTo associated with the cells of the Active Grid are either loaded (when worldShouldBeUpdated 
            is true) or unloaded (when worldShouldBeUpdated is false). This allows you to wait for the game world to either be 
            loaded (and in a playable state) or unloaded before continuing with some other action (such as removing a loading screen).
            </para>
            <para>
            In addition, when worldShouldBeUpdated is true, Align Player To Terrain is enabled in the inspector of this 
            Active Grid, and the World Grouping passed in is the same layer assigned to the 'World Grouping With Terrain To Align Player To' 
            field, after waiting for a world update, the method will align the player to the Terrain. This is not done 
            with the normal 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean,System.Int32)" href="#TrySetIfWorldShouldBeUpdated2">TrySetIfWorldShouldBeUpdated</see> 
            method, so if you need the player to be aligned to the Terrain, you must use this coroutine method, regardless of 
            whether you care about waiting for a World update.
            </para>
            </summary>
            <param name="worldShouldBeUpdated" type="bool">
            Whether the world should be updated for the Grouping of the Active Grid.
            </param>
            <param name="groupingIndex" type="int">
            The index of the Grouping on the Active Grid whose "Update World" property will be set.
            </param>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(bool worldShouldBeUpdated, int groupingIndex)
            </syntax>
            <displayName id = "TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate2">
            TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(bool, int)
            </displayName>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the Active Grid has not been initialized or if the method is called while the Active Grid 
            is already busy. You should always check if the Active Grid is busy 
            before calling any method that begins with Try!
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.SetAutoTracking(System.Boolean)">
            <summary>
            Sets Auto Tracking (true means enabled, false means disabled) for all Groupings on the Active Grid 
            (note, tracking only takes place when the grid is synced to a World). 
            Auto Tracking enables the tracking of the player to determine if they cross 
            the inner area boundary of one or more Groupings on the Active Grid.
            <para>
            When the player crosses the boundary for a Grouping the cells of the Active Grid on that Grouping  
            are dynamically updated based on the position 
            of the player. In addition, when 'Update World' is enabled on a Grouping, the Active Grid updates the 
            same Grouping on the World it is synced to so that it can update its World Cells appropriately, 
            which effectively enables dynamic loading and world updates.
            </para>
            </summary>
            <param name="autoTracking" type = "bool">
            Pass in true to enable auto tracking, or false to disable it.
            </param>
            <syntax>public void SetAutoTracking(bool autoTracking)</syntax>
            <displayName id = "SetAutoTracking1">SetAutoTracking(bool)</displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.SetAutoTracking(System.Boolean,System.Int32)">
            <summary>
            Sets Auto Tracking (true means enabled, false means disabled) for a single Groupings on the Active Grid (note, tracking only 
            takes place when the grid is synced to a World). 
            Auto Tracking enables the tracking of the player to determine if they cross the inner area boundary of the 
            Groupings on the Active Grid.
            <para>
            When the player crosses the boundary for the Grouping, the cells of the Active Grid on that Grouping 
            are dynamically updated based on the position 
            of the player. In addition, when 'Update World' is enabled on the Grouping, the Active Grid updates the 
            same Grouping on the World it is synced to so that it can update its World Cells appropriately, which effectively enables 
            dynamic loading and world updates.
            </para>
            </summary>
            <param name="autoTracking" type = "bool">
            Pass in true to enable auto tracking, or false to disable it.
            </param>
            <param name="groupingIndex" type="int">
            The index of the grouping whose auto tracking should be enabled or disabled.
            </param>
            <syntax>public void SetAutoTracking(bool autoTracking, int groupingIndex)</syntax>
            <displayName id = "SetAutoTracking2">SetAutoTracking(bool, int)</displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.AllowGridToRecenterWorldWhenSynced">
            <summary>
            Allows the grid to recenter the World it is synced to by triggering an Origin Cell changes in the World.
            <para>
            This only has an effect when the grid is synced to a World with 'Allow Active Grid Re-Centering' enabled.
            </para>
            </summary>
            <syntax>public void AllowGridToRecenterWorldWhenSynced()</syntax>
            <displayName id = "AllowGridToRecenterWorldWhenSynced">AllowGridToRecenterWorldWhenSynced()</displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.ProhibitGridFromFromRecenteringWorldWhenSynced">
            <summary>
            Stops this Active Grid from being able to trigger World Re-Centering in any Worlds it is synced to.
            </summary>
            <syntax>public void ProhibitGridFromFromRecenteringWorldWhenSynced()</syntax>
            <displayName id = "ProhibitGridFromFromRecenteringWorldWhenSynced">ProhibitGridFromFromRecenteringWorldWhenSynced()</displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryChangeLoadingBlueprintByID(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Tries to change the Fallback <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> (if zoneName is null)
            of the indicated Active Grid Grouping, or it tries to change/add a Zone Blueprint Override (if zoneName is not null).
            <para>
            The change persist between sessions if the Active Grid is persistent and 
            optionally refreshes the World the Active Grid is synced to so it will be made up entirely of the Asset Chunks  
            associated with the new loading blueprint (if there is overlap between the blueprints, 
            some chunks may remain after the refresh). This refresh only occurs if an actual Blueprint change is detected.
            </para>
            <para>
            This method will throw an exception if the Active Grid is already busy, so you should query the IsBusy property 
            to make sure it is not before calling this method.
            </para>
            </summary>
            <param name="loadingBlueprintID" type="int">
            The ID of the Loading Blueprint. This can be seen in the Loading Blueprint Repository Inspector, in the parentheses after the Blueprint Type.
            </param>
            <param name="groupingIndex" type="int">
            The Active Grid Grouping whose loading blueprint will be changed.
            </param>
            <param name="refreshWorld" type="bool">
            If true, the objects associated with the previous blueprint are completely unloaded, and the objects related to 
            the new blueprint are loaded. Only occurs if an actual Blueprint change is detected.
            <para>
            If false, the objects will be refreshed the next time the player crosses a loading 
            boundary or during a world origin reset. If no world is synced to the Active Grid, or the Active Grid Grouping is not 
            synced to a World Grouping, this option will do nothing.
            </para>
            <para>
            Also note, when true this method will finish executing only after the world has been updated to reflect the new blueprint, 
            so it's useful to make use of this when you want to display a loading screen or otherwise pause the 
            game to wait for the world to update.
            </para>
            </param>
            <param name="zoneName" type="[string]">
            An optional Zone to apply the blueprint to. If null, the blueprint change will be applied to the Fallback Loading Blueprint of the Active 
            Grid Grouping specified. If not null, the blueprint change will be applied to an existing Zone Blueprint Override matching the zoneName, or a 
            new Override will be created if one does not already exist.
            <para>
            For the latter case, any time the Active Grid Grouping is synced to the Zone, the blueprint applied to the Override will be used. If you want to 
            stop using this blueprint, you must call 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryRemoveZoneBlueprintOverride(System.Int32,System.String,System.Boolean)" href="#TryRemoveZoneBlueprintOverride">TryRemoveZoneBlueprintOverride</see>!
            </para>
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the Active Grid has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called when IsBusy is already true or if the ID does not correspond to a valid Blueprint in the Repository.
            </exception>
            <exception cref="T:System.NullReferenceException">
            Thrown if the index points to a null blueprint, which should never happen. If it does, please contact me!!
            </exception>
            <displayName id="TryChangeLoadingBlueprintByID">
            TryChangeLoadingBlueprintByID(int, int, bool, [string])
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryChangeLoadingBlueprintByID(int loadingBlueprintID, int groupingIndex, bool refreshWorld, string zoneName = null)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryChangeLoadingBlueprintByIndex(System.Int32,System.Int32,System.Boolean,System.String)">
            <summary>
            Tries to change the Fallback <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> (if zoneName is null)
            of the indicated Active Grid Grouping, or it tries to change/add a Zone Blueprint Override (if zoneName is not null).
            <para>
            The change persist between sessions if the Active Grid is persistent and 
            optionally refreshes the World the Active Grid is synced to so it will be made up entirely of the Asset Chunks  
            associated with the new loading blueprint (if there is overlap between the blueprints, 
            some chunks may remain after the refresh). This refresh only occurs if an actual Blueprint change is detected.
            </para>
            <para>
            This method will throw an exception if the Active Grid is already busy, so you should query the IsBusy property 
            to make sure it is not before calling this method.
            </para>
            </summary>
            <param name="loadingBlueprintIndex" type="int">
            The index of the new loading blueprint. This index must correspond to a valid blueprint on the 
            <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.LoadingBlueprintRepository" href="LoadingBlueprintRepository.html">Loading Blueprint Repository</see> 
            connected to this Active Grid.
            </param>
            <param name="groupingIndex" type="int">
            The Active Grid Grouping whose loading blueprint will be changed.
            </param>
            <param name="refreshWorld" type="bool">
            If true, the objects associated with the previous blueprint are completely unloaded, and the objects related to 
            the new blueprint are loaded. Only occurs if an actual Blueprint change is detected.
            <para>
            If false, the objects will be refreshed the next time the player crosses a loading 
            boundary or during a world origin reset. If no world is synced to the Active Grid, or the Active Grid Grouping is not 
            synced to a World Grouping, this option will do nothing.
            </para>
            <para>
            Also note, when true this method will finish executing only after the world has been updated to reflect the new blueprint, 
            so it's useful to make use of this when you want to display a loading screen or otherwise pause the 
            game to wait for the world to update.
            </para>
            </param>
            <param name="zoneName" type="[string]">
            An optional Zone to apply the blueprint to. If null, the blueprint change will be applied to the Fallback Loading Blueprint of the Active 
            Grid Grouping specified. If not null, the blueprint change will be applied to an existing Zone Blueprint Override matching the zoneName, or a 
            new Override will be created if one does not already exist.
            <para>
            For the latter case, any time the Active Grid Grouping is synced to the Zone, the blueprint applied to the Override will be used. If you want to 
            stop using this blueprint, you must call 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryRemoveZoneBlueprintOverride(System.Int32,System.String,System.Boolean)" href="#TryRemoveZoneBlueprintOverride">TryRemoveZoneBlueprintOverride</see>!
            </para>
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the Active Grid has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called when IsBusy is already true.
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if the index is not valid (less than 1 or greater than the number of blueprints in the respository)
            </exception>
            <exception cref="T:System.NullReferenceException">
            Thrown if the index points to a null blueprint, which should never happen. If it does, please contact me!!
            </exception>
            <displayName id="TryChangeLoadingBlueprintByIndex">
            TryChangeLoadingBlueprintByIndex(int, int, bool, [string])
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryChangeLoadingBlueprintByIndex(int loadingBlueprintIndex, int groupingIndex, bool refreshWorld, string zoneName = null)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryChangeLoadingBlueprintByName(System.String,System.Int32,System.Boolean,System.String)">
            <summary>
            Tries to change the Fallback <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> (if zoneName is null)
            of the indicated Active Grid Grouping, or it tries to change/add a Zone Blueprint Override (if zoneName is not null).
            <para>
            The change persist between sessions if the Active Grid is persistent and 
            optionally refreshes the World the Active Grid is synced to so it will be made up entirely of the Asset Chunks  
            associated with the new loading blueprint (if there is overlap between the blueprints, 
            some chunks may remain after the refresh). This refresh only occurs if an actual Blueprint change is detected.
            </para>
            <para>
            This method will throw an exception if the Active Grid is already busy, so you should query the IsBusy property 
            to make sure it is not before calling this method.
            </para>
            </summary>
            <param name="loadingBlueprintName" type="string">
            The name of the new loading blueprint. This name must correspond to a valid blueprint on the 
            <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.LoadingBlueprintRepository" href="LoadingBlueprintRepository.html">Loading Blueprint Repository</see> connected 
            to this Active Grid.
            </param>
            <param name="groupingIndex" type="int">
            The Active Grid Grouping whose loading blueprint will be changed.
            </param>
            <param name="refreshWorld" type="bool">
            If true, the objects associated with the previous blueprint are completely unloaded, and the objects related to 
            the new blueprint are loaded. Only occurs if an actual Blueprint change is detected.
            <para>
            If false, the objects will be refreshed the next time the player crosses a loading 
            boundary or during a world origin reset. If no world is synced to the Active Grid, or the Active Grid Grouping is not 
            synced to a World Grouping, this option will do nothing.
            </para>
            <para>
            Also note, when true this method will finish executing only after the world has been updated to reflect the new blueprint, 
            so it's useful to make use of this when you want to display a loading screen or otherwise pause the 
            game to wait for the world to update.
            </para>
            </param>
            <param name="zoneName" type="[string]">
            An optional Zone to apply the blueprint to. If null, the blueprint change will be applied to the Fallback Loading Blueprint of the Active 
            Grid Grouping specified. If not null, the blueprint change will be applied to an existing Zone Blueprint Override matching the zoneName, or a 
            new Override will be created if one does not already exist.
            <para>
            For the latter case, any time the Active Grid Grouping is synced to the Zone, the blueprint applied to the Override will be used. If you want to 
            stop using this blueprint, you must call 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryRemoveZoneBlueprintOverride(System.Int32,System.String,System.Boolean)" href="#TryRemoveZoneBlueprintOverride">TryRemoveZoneBlueprintOverride</see>!
            </para>
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the Active Grid has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called when IsBusy is already true.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidNameException" link="InvalidNameException.html">
            Thrown if the name does not correspond to a valid loading blueprint on the repository.
            </exception>
            <displayName id="TryChangeLoadingBlueprintByName">
            TryChangeLoadingBlueprintByName(string, int, bool, [string])
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryChangeLoadingBlueprintByName(string loadingBlueprintName, int groupingIndex, bool refreshWorld, string zoneName = null)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryRemoveZoneBlueprintOverride(System.Int32,System.String,System.Boolean)">
            <summary>
            Tries to remove a Zone Blueprint Override for the zoneName on the indicated Active Grid Grouping
            (change persist between sessions if the Active Grid is persistent) and 
            optionally refreshes the World the Active Grid is synced to so it will be made up entirely of the Asset Chunks  
            associated with the new loading blueprint (if there is overlap between the blueprints, 
            some chunks may remain after the refresh).
            <para>
            This method will throw an exception if the Active Grid is already busy, so you should query the IsBusy property 
            to make sure it is not before calling this method.
            </para>
            </summary>
            <param name="groupingIndex" type="int">
            The Active Grid Grouping whose Zone Blueprint Override will be removed.
            </param>
            <param name="zoneName" type="string">
            The name of the Zone to remove the override for. If an override for this Zone does not exists, nothing will happen and the method will 
            return with a SimpleYieldBreakEquivalentEnumerator object.
            </param>
            <param name="refreshWorld" type="bool">
            If true and the removal of the override results in a change of Blueprint, and thus a change in cells loaded for the Zone in question, 
            the World will be updated with the changed cells.
            <para>
            If false, the objects will be refreshed the next time the player crosses a loading 
            boundary or during a world origin change. If no world is synced to the Active Grid, or the Active Grid Grouping is not 
            synced to a World Grouping, this option will do nothing.
            </para>
            <para>
            Also note, when true this method will finish executing only after the world has been updated to reflect the new blueprint, 
            so it's useful to make use of this when you want to display a loading screen or otherwise pause the 
            game to wait for the world to update.
            </para>
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the Active Grid has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called when IsBusy is already true.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidNameException" link="InvalidNameException.html">
            Thrown if the name does not correspond to a valid loading blueprint on the repository.
            </exception>
            <displayName id="TryRemoveZoneBlueprintOverride">
            TryRemoveZoneBlueprintOverride(int, string, bool)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryRemoveZoneBlueprintOverride(int groupingIndex, string zoneName, bool refreshWorld)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryChangeLoadingBlueprintsByID(System.Int32[],System.Int32[],System.Boolean)">
            <summary>
            Tries to change the <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> 
            of the indicated Active Grid Groupings
            (change persist between sessions if the Active Grid is persistent) and 
            optionally refreshes the World the Active Grid is synced to so it will be made up entirely of the Asset Chunks  
            associated with the new loading blueprints (if there is overlap between the blueprints, 
            some chunks may remain after the refresh).
            <para>
            This method will throw an exception if the Active Grid is already busy, so you should query the IsBusy property 
            to make sure it is not before calling this method.
            </para>
            </summary>
            <param name="loadingBlueprintIDs" type="int[]">
            The IDs of the Loading Blueprints. These can be seen in the Loading Blueprint Repository Inspector, in the parentheses after the Blueprint Type.
            </param>
            <param name="groupingIndexes" type="int[]">
            An array of Active Grid Grouping indexes whose loading blueprints will be changed.
            </param>
            <param name="refreshWorld" type="bool">
            If true, the objects associated with the previous blueprints are completely unloaded, and the objects related to 
            the new blueprints are loaded.
            <para>
            If false, the objects will be refreshed the next time the player crosses a loading 
            boundary or during a world origin reset. If no world is synced to the Active Grid, or no Active Grid Groupings are 
            synced to a World Grouping, this option will do nothing.
            </para>
            <para>
            Also note, when true this method will finish executing only after the world has been updated to reflect the new blueprints, 
            so it's useful to make use of this when you want to display a loading screen or otherwise pause the 
            game to wait for the world to update.
            </para>
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the Active Grid has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called when IsBusy is already true or if one of the ID's do not correspond to a valid Blueprint.
            </exception>
            <exception cref="T:System.NullReferenceException">
            Thrown if the index points to a null blueprint, which should never happen. If it does, please contact me!!
            </exception>
            <displayName id="TryChangeLoadingBlueprintsByID">
            TryChangeLoadingBlueprintsByID(int[], int[], bool)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryChangeLoadingBlueprintsByID(int[] loadingBlueprintIDs, int[] groupingIndexes, bool refreshWorld)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryChangeLoadingBlueprintsByIndex(System.Int32[],System.Int32[],System.Boolean)">
            <summary>
            Tries to change the <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> 
            of the indicated Active Grid Groupings
            (change persist between sessions if the Active Grid is persistent) and 
            optionally refreshes the World the Active Grid is synced to so it will be made up entirely of the Asset Chunks  
            associated with the new loading blueprints (if there is overlap between the blueprints, 
            some chunks may remain after the refresh).
            <para>
            This method will throw an exception if the Active Grid is already busy, so you should query the IsBusy property 
            to make sure it is not before calling this method.
            </para>
            </summary>
            <param name="loadingBlueprintIndexes" type="int[]">
            The indexes of the new loading blueprints. These indexes must correspond to a valid blueprint on the 
            <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.LoadingBlueprintRepository" href="LoadingBlueprintRepository.html">Loading Blueprint Repository</see> connected 
            to this Active Grid, and the length of the array must be the same as the groupingIndexes array 
            (The loading blueprint index at array index 0 of loadingBlueprintIndexes is used for the World Grouping identified by array index 0 of groupingIndexes).
            </param>
            <param name="groupingIndexes" type="int[]">
            An array of Active Grid Grouping indexes whose loading blueprints will be changed.
            </param>
            <param name="refreshWorld" type="bool">
            If true, the objects associated with the previous blueprints are completely unloaded, and the objects related to 
            the new blueprints are loaded.
            <para>
            If false, the objects will be refreshed the next time the player crosses a loading 
            boundary or during a world origin reset. If no world is synced to the Active Grid, or no Active Grid Groupings are 
            synced to a World Grouping, this option will do nothing.
            </para>
            <para>
            Also note, when true this method will finish executing only after the world has been updated to reflect the new blueprints, 
            so it's useful to make use of this when you want to display a loading screen or otherwise pause the 
            game to wait for the world to update.
            </para>
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the Active Grid has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called when IsBusy is already true.
            </exception>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if the index is not valid (less than 1 or greater than the number of blueprints in the respository)
            </exception>
            <exception cref="T:System.NullReferenceException">
            Thrown if the index points to a null blueprint, which should never happen. If it does, please contact me!!
            </exception>
            <displayName id="TryChangeLoadingBlueprintsByIndex">
            TryChangeLoadingBlueprintsByIndex(int[], int[], bool)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryChangeLoadingBlueprintsByIndex(int[] loadingBlueprintIndexes, int[] groupingIndexes, bool refreshWorld)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.TryChangeLoadingBlueprintsByName(System.String[],System.Int32[],System.Boolean)">
            <summary>
            Tries to change the <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see> 
            of the indicated Active Grid Groupings
            (change persist between sessions if the Active Grid is persistent) and 
            optionally refreshes the World the Active Grid is synced to so it will be made up entirely of the Asset Chunks  
            associated with the new loading blueprints (if there is overlap between the blueprints, 
            some chunks may remain after the refresh).
            <para>
            This method will throw an exception if the Active Grid is already busy, so you should query the IsBusy property 
            to make sure it is not before calling this method.
            </para>
            </summary>
            <param name="loadingBlueprintNames" type="string[]">
            The names of the new loading blueprints. These names must correspond to a valid blueprint on the 
            <see cref="P:DeepSpaceLabs.SAM.ActiveGrid.LoadingBlueprintRepository" href="LoadingBlueprintRepository.html">Loading Blueprint Repository</see> connected 
            to this Active Grid, and the length of the array must be the same as the groupingIndexes array 
            (The loading blueprint name at array index 0 of loadingBlueprintIndexes is used for the World Grouping identified by array index 0 of groupingIndexes).
            </param>
            <param name="groupingIndexes" type="int[]">
            An array of Active Grid Grouping indexes whose loading blueprints will be changed.
            </param>
            <param name="refreshWorld" type="bool">
            If true, the objects associated with the previous blueprints are completely unloaded, and the objects related to 
            the new blueprints are loaded.
            <para>
            If false, the objects will be refreshed the next time the player crosses a loading 
            boundary or during a world origin reset. If no world is synced to the Active Grid, or no Active Grid Groupings are 
            synced to a World Grouping, this option will do nothing.
            </para>
            <para>
            Also note, when true this method will finish executing only after the world has been updated to reflect the new blueprints, 
            so it's useful to make use of this when you want to display a loading screen or otherwise pause the 
            game to wait for the world to update.
            </para>
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the Active Grid has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called when IsBusy is already true.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidNameException" link="InvalidNameException.html">
            Thrown if ones of the names does not correspond to a valid Blueprint.
            </exception>
            <exception cref="T:System.NullReferenceException">
            Thrown if the index points to a null blueprint, which should never happen. If it does, please contact me!!
            </exception>
            <displayName id="TryChangeLoadingBlueprintsByName">
            TryChangeLoadingBlueprintsByName(string[], int[], bool)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TryChangeLoadingBlueprintsByName(string[] loadingBlueprintNames, int[] groupingIndexes, bool refreshWorld)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGrid.InitiatePendingMove">
            <summary>
            Tells a pending move operation that it is okay to proceed. This is used in conjunction with passing in true 
            for the waitForCommandBeforeMovingPlayer parameter of the 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocation(DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Boolean,System.Boolean,System.Double)" href = "#TryMovePlayerToLocation">TryMovePlayerToLocation</see> and  
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocationOnNewWorld(DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.World,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Double,System.Int32)" href = "#TryMovePlayerToLocationOnNewWorld">
            TryMovePlayerToLocationOnNewWorld
            </see> methods.
            <para>
            This allows you to gain greater control over when the move operation is executed, which is useful in many situations, such as 
            situations where you need to perform some logic before the player can be moved successfully.
            </para>
            <para>
            In order to use this strategy correctly, you should query the PlayerReadyToBeMoved property and wait for it to return true. Once 
            it returns true, indicating that the player is ready to be moved, you should perform whatever logic you need to in order to 
            ensure the player move operation is successful. Once that logic is performed, call this method and the Active Grid will then 
            care out the actual move operation, using the PlayerMover (if assigned), or directly setting the IPlayer.Position property (if 
            no PlayerMover is assigned).
            </para>
            </summary>
            <syntax>public void InitiatePendingMove()</syntax>
            <displayName id = "InitiatePendingMove">InitiatePendingMove()</displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGridUpdateToggle.SetActiveGridInfo(System.Boolean,System.Int32,DeepSpaceLabs.SAM.ActiveGrid)">
            <summary>
            Can be used to set the Active Grid at runtime.
            </summary>
            <param name="setActiveGridUsingID" type="bool">
            Whether to set the Active Grid using it's ID. Pass in false with a valid ActiveGrid to use a hard reference instead.
            </param>
            <param name="activeGridID" type="int">
            The ID of the Active Grid to use, if setActiveGridUsingID is true.
            </param>
            <param name="activeGrid" type="ActiveGrid" link="ActiveGrid.html">
            The Active Grid to use, if setActiveGridUsingID is false.
            </param>
            <displayName id="SetActiveGridInfo">
            SetActiveGridInfo(bool, [int], [ActiveGrid])
            </displayName>
            <syntax>
            public void SetActiveGridInfo(bool setActiveGridUsingID, int activeGridID = 0, ActiveGrid activeGrid = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGridUpdateToggle.EnableUpdates">
            <summary>
            
            </summary>
            <param name="name" type="type" link="Name.html">
            Description
            </param>
            <displayName id="MethodName">
            MethodName(ParamType)
            </displayName>
            <syntax>
            public ReturnType MethodName(ParamType paramName)
            </syntax>
            <returns type="type">
            Description
            </returns>
            <exception name="ExceptionName">
            Description
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ActiveGridUpdateToggle.DisableUpdates">
            <summary>
            
            </summary>
            <param name="name" type="type" link="Name.html">
            Description
            </param>
            <displayName id="MethodName">
            MethodName(ParamType)
            </displayName>
            <syntax>
            public ReturnType MethodName(ParamType paramName)
            </syntax>
            <returns type="type">
            Description
            </returns>
            <exception name="ExceptionName">
            Description
            </exception>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkTimingData">
            <summary>
            Holds Asset Chunk specific Timing Data.
            <para>
            You won't use this class directly. Instead, it is created/managed by the ConditionalMembers class, which makes using of timing data only 
            in the editor or within a Development Build (for performance reasons).
            </para>
            <para>
            All timing data is an average of 1 or more samples, unless timing data is not available because an operation was never carried out for the 
            asset chunk, in which case Samples will be 0.
            </para>
            </summary>
            <title>ChunkTimingData Class</title>
            <category>Secondary Non Components</category>
            <navigationName>ChunkTimingData</navigationName>
            <fileName>ChunkTimingData.html</fileName>
            <syntax>
            public class ChunkTimingData
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.WorldID">
            <summary>
            Gets the ID of the World this timing data is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.ZoneIndex">
            <summary>
            Gets the index of the Zone this timing data is associated with.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.WorldGroupingIndex">
            <summary>
            Gets the index of the World Grouping this timing data is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.LevelOfDetail">
            <summary>
            Gets the Level of Detail (LOD Group) this timing data is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.CellOnStreamableGrid">
            <summary>
            Gets the Streamable Grid Cell this timing data is associated with.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.ChunkIndex">
            <summary>
            Gets the index of the asset chunk in relation to other Asset Chunks on the same World Cell.
            </summary>
            /// <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.Configure">
            <summary>
            Timing Data tracking the time it takes to configure this asset chunk. For Prefab based asset chunks, configuration involves the 
            instantiation of the asset chunks from their source assets, and so the timings will usually be higher than scene based asset chunks.
            </summary>
            <type link="TimingData.html">TimingData</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.Activate">
            <summary>
            Timing Data tracking operations involving the activation of the Asset Chunk.
            </summary>
            <type link="TimingData.html">TimingData</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkTimingData.Deactivate">
            <summary>
            Timing Data tracking operations involving the deactivation of the Asset Chunk.
            </summary>
            <type link="TimingData.html">TimingData</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkTimingData.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,DeepSpaceLabs.SAM.Cell,System.Int32)">
            <summary>
            Initializes a new instance of a ChunkTimingData object.
            </summary>
            <param name="worldID" type="int">
            The ID of the World this timing data is associated with.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone this timing data is associated with.
            </param>
            <param name="worldGroupingIndex" type="int">
            The index of the World Grouping this timing data is associated with.
            </param>
            <param name="levelOfDetail" type="int">
            The Level of Detail (LOD Group) this timing data is associated with.
            </param>
            <param name="cellOnStreamableGrid" type="Cell" link="Cell.html">
            The Streamable Grid Cell this timing data is associated with.
            </param>
            <param name="chunkIndex" type="int">
            The index of the asset chunk in relation to other Asset Chunks on the same World Cell.
            </param>
            <displayName id="ChunkTimingData">
            ChunkTimingData(int, int, int, int, Cell, int)
            </displayName>
            <syntax>
            public ChunkTimingData(int worldID, int zoneIndex, int worldGroupingIndex, int levelOfDetail, Cell cellOnStreamableGrid, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkTimingData.GetHashCode">
            <summary>
            Returns a hash code for this ChunkTimingData.
            </summary>
            <returns type="int">
            The hash code of the ChunkTimingData.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ConditionalMembers">
            <summary>
            A Scriptable Object class used to store members (methods, properties, etc.) that rely on Unity Conditional Compilation.
            <para>
            The actual implementation is stored outside this DLL in a scriptable assets stored in the Deep Space Labs/SAM/Resources folder, so that it can "see" the Unity Conditional Defines (#UNITY_EDITOR, DEVELOPMENT_BUILD, etc.), and is accessible at runtime. Members 
            inside of the SAM DLL can thus access conditionally compiled code in this way, and if for some reason the asset is deleted, a fall-back implementation is used.
            </para>
            </summary>
            <title>
            ConditionalMembers Class
            </title>
            <category>Scriptable Assets</category>
            <navigationName>ConditionalMembers</navigationName>
            <fileName>ConditionalMembers.html</fileName>
            <syntax>public abstract class ConditionalMembers : ScriptableObject</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnSAMInitializing">
            <summary>
            Called before SAM is initialized.
            </summary>
            <displayName id="OnSAMInitializing">
            OnSAMInitializing()
            </displayName>
            <syntax>
            public abstract void OnSAMInitializing()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnInitiatingAssetChunkLoad(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called right before an Asset Chunk's loading process is started.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case this method must be called 
            in the same frame that OnAssetChunkLoadInitiated is called.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnInitiatingAssetChunkLoad">
            OnInitiatingAssetChunkLoad(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnInitiatingAssetChunkLoad(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkLoadInitiated(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called right after the Streamer has initiated the loading of an asset chunk. Used to time how long 
            the call to start loading took.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, 
            in which case this method MUST be called in the same frame that OnInitiatingAssetChunkLoad is called.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnAssetChunkLoadInitiated">
            OnAssetChunkLoadInitiated(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkLoadInitiated(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnInitiatingAssetChunkIntegrate(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called right before the Streamer has initiated the integration of an asset chunk, which is typically the 
            final step of the loading process. Used to time how long the call to integrate took, although it should be noted that this is done 
            by combining this call with the call to OnAssetChunkLoaded, which itself may not be called immediately after the 
            integration completes.
            <para>
            This method is not called by all streamers, specifically the Addressable Prefab Chunk Streamer, as it's not possible 
            to control the integration step (it happens automatically during the load).
            </para>
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnInitiatingAssetChunkIntegrate">
            OnInitiatingAssetChunkIntegrate(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnInitiatingAssetChunkIntegrate(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkLoaded(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called after an Asset Chunk (or its source asset) has been loaded into main memory (i.e., after the itegration step completes). 
            This is called before the Asset Chunk has been configured, which if using prefabs, involves the instantiation of the asset chunk.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnAssetChunkLoaded">
            OnAssetChunkLoaded(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkLoaded(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnConfiguringAssetChunk(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called before an Asset Chunk is configured.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case you MUST call it in the same 
            frame as OnAssetChunkConfigured.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnConfiguringAssetChunk">
            OnConfiguringAssetChunk(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnConfiguringAssetChunk(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkConfigured(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called after an Asset Chunk is configured.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case you MUST call it in the same 
            frame as OnConfiguringAssetChunk.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnAssetChunkConfigured">
            OnAssetChunkConfigured(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkConfigured(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnInitiatingAssetChunkUnload(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called right before an Asset Chunk's unloading process is started. Only called by streamers that use an async operation to unload the asset chunks.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case it MUST be called 
            in the same frame as OnAssetChunkUnloadInitiated.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnInitiatingAssetChunkUnload">
            OnInitiatingAssetChunkUnload(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnInitiatingAssetChunkUnload(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkUnloadInitiated(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called right after the Streamer has initiated the unloading of an asset chunk. Used to time how long 
            the call to start unloading took. Only called by streamers that use an async operation to unload the asset chunks.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case it MUST be called 
            in the same frame as OnInitiatingAssetChunkUnload.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnAssetChunkUnloadInitiated">
            OnAssetChunkUnloadInitiated(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkUnloadInitiated(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnInitiatingAssetChunkDeintegrate(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called right before the Streamer has initiated the deintegration of an asset chunk, which is typically the 
            final step of the unloading process. Used to time how long the call to deintegrate took, although it should be noted that this is done 
            by combining this call with the call to OnAssetChunkUnloaded, which itself may not be called immediately after the 
            deintegration completes.
            <para>
            Only called by streamers that use an async operation to unload the asset chunks.
            </para>
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnInitiatingAssetChunkDeintegrate">
            OnInitiatingAssetChunkDeintegrate(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnInitiatingAssetChunkDeintegrate(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkUnloaded(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called after an Asset Chunk (or its source asset) has completely been unloaded from main memory (i.e., after the deitegration step completes). 
            Only called by streamers that use an async operation to unload the asset chunks.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnAssetChunkUnloaded">
            OnAssetChunkUnloaded(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkUnloaded(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnDestroyingAssetChunkOrChildren(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called before the destruction of an Asset Chunk or any of its children in a given frame. If using a ChunkDestroyer, this method 
            may be called multiple times for a single Asset Chunk, if the destruction of that asset chunk is carried out over multiple frames.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case it MUST be called in the same frame 
            as OnAssetChunkOrChildrenDestroyed.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnDestroyingAssetChunkOrChildren">
            OnDestroyingAssetChunkOrChildren(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnDestroyingAssetChunkOrChildren(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkOrChildrenDestroyed(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called after an Asset Chunk or any of its children are destroyed in a given frame. If using a ChunkDestroyer, this method 
            may be called multiple times for a single Asset Chunk, if the destruction of that asset chunk is carried out over multiple frames.
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case it MUST be called in the same frame 
            as OnDestroyingAssetChunkOrChildren.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnAssetChunkOrChildrenDestroyed">
            OnAssetChunkOrChildrenDestroyed(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkOrChildrenDestroyed(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnReleasingAssetChunkHandle(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called before an Asset Chunk Handle is released (currently only used with  
            Addressable Chunk Streamers).
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case it MUST be called in the same frame 
            as OnAssetChunkHandleReleased.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnReleasingAssetChunkHandle">
            OnReleasingAssetChunkHandle(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnReleasingAssetChunkHandle(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkHandleReleased(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Called after an Asset Chunk Handle is released (currently only used with  
            Addressable Chunk Streamers).
            <para>
            You should not call this method unless you are writing a custom Chunk Streamer, in which case it MUST be called in the same frame 
            as OnReleasingAssetChunkHandle.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="OnAssetChunkHandleReleased">
            OnAssetChunkHandleReleased(WorldCell, int)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkHandleReleased(WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnSettingAssetChunkActiveState(DeepSpaceLabs.SAM.WorldCell,System.Int32,System.Boolean)">
            <summary>
            Called before an Asset Chunk's active state is changed.
            <para>
            You should not call this method, unless you are writing a custom Chunk Manager that overrides the SetChunkActiveState method, 
            in which case it MUST be called in the same frame as OnAssetChunkActiveStateSet.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <param name="isActive">
            The state that the chunk will be set to.
            </param>
            <displayName id="OnSettingAssetChunkActiveState">
            OnSettingAssetChunkActiveState(WorldCell, int, bool)
            </displayName>
            <syntax>
            public abstract void OnSettingAssetChunkActiveState(WorldCell worldCellOfChunk, int chunkIndex, bool isActive)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.OnAssetChunkActiveStateSet(DeepSpaceLabs.SAM.WorldCell,System.Int32,System.Boolean)">
            <summary>
            Called after an Asset Chunk's active state is changed.
            <para>
            You should not call this method, unless you are writing a custom Chunk Manager that overrides the SetChunkActiveState method, 
            in which case it MUST be called in the same frame as OnSettingAssetChunkActiveState.
            </para>
            </summary>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <param name="isActive">
            The state that the chunk was just set to.
            </param>
            <displayName id="OnAssetChunkActiveStateSet">
            OnAssetChunkActiveStateSet(WorldCell, int, bool)
            </displayName>
            <syntax>
            public abstract void OnAssetChunkActiveStateSet(WorldCell worldCellOfChunk, int chunkIndex, bool isActive)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ConditionalMembers.GetConditionalMembers">
            <summary>
            Can be used to retrieve the Conditional Members asset. Using this method is preferred over 
            manually retrieving the asset from Resources because the instance will be cached for future calls.
            <para>
            This method will also create an instance of a default implementation if no Conditional Members asset was found in the 
            resources folder.
            </para>
            </summary>
            <returns type="ConditionalMembers">
            The Conditional Members asset, if found, or a default instance if one was not found in Resources.
            </returns>
            <displayName id="GetConditionalMembers">
            GetConditionalMembers()
            </displayName>
            <syntax>
            public static ConditionalMembers GetConditionalMembers()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.OriginCellChangeInfo">
            <summary>
            Holds information about a World Origin Cell Change operation.
            </summary>
            <title>OriginCellChangeInfo Class</title>
            <category>
            Secondary Non Components
            </category>
            <navigationName>OriginCellChangeInfo</navigationName>
            <fileName>OriginCellChangeInfo.html</fileName>
            <syntax>
            public class OriginCellChangeInfo
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.OriginCellChangeInfo.World">
            <summary>
            The World this info referes to.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.OriginCellChangeInfo.NewWorldOriginCell">
            <summary>
            The new Origin Cell of the World.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.OriginCellChangeInfo.ShiftAmount">
            <summary>
            The amount of shift added to the SAM Asset Chunks as a result of the Origin Cell change. If you have content outside the control of SAM 
            that needs to be shifted with the rest of the World, you should add this value to that contents' position.
            </summary>
             <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.OriginCellChangeInfo.TryGetNewOriginCellOfZoneGrouping(System.Int32,System.Int32,DeepSpaceLabs.SAM.Cell@)">
            <summary>
            Tries to get the new Origin Cell value (expressed as a Cell on the Zone Grouping's Endless Grid) for a particular Zone Grouping.
            </summary>
            <param name="zoneIndex" type="int" link="Name.html">
            The index of the Zone whose information you want to retrieve.
            </param>
             <param name="groupingIndex" type="int">
            The index of the World Grouping whose information you want to retrieve.
            </param>
             <param name="newOriginCell" type="out Cell" link="Cell.html">
            The new origin cell if the method returns true.
            </param>
            <displayName id="TryGetNewOriginCellOfZoneGrouping">
            TryGetNewOriginCellOfZoneGrouping(int, int, out Cell)
            </displayName>
            <syntax>
            public bool TryGetNewOriginCellOfZoneGrouping(int zoneIndex, int groupingIndex, out Cell newOriginCell)
            </syntax>
            <returns type="type">
            True if the origin cell could be retrieved, false otherwise.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ClampingOperationInfo">
            <summary>
            Holds information about a World Clamping Operation (executed using the 
            <see cref="M:DeepSpaceLabs.SAM.World.ClampOriginCells(System.Boolean,System.Boolean,System.Action{DeepSpaceLabs.SAM.World})" href="World.html#ClampOriginCells">ClampOriginCells</see> method.
            </summary>
            <title>ClampingOperationInfo Class</title>
            <category>
            Secondary Non Components
            </category>
            <navigationName>ClampingOperationInfo</navigationName>
            <fileName>ClampingOperationInfo.html</fileName>
            <syntax>
            public class ClampingOperationInfo
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ClampingOperationInfo.World">
            <summary>
            The World this info referes to.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ClampingOperationInfo.NewWorldOriginCell">
            <summary>
            The new Origin Cell of the World after the clamping operation.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ClampingOperationInfo.WorldClampingShift">
            <summary>
            The amount of shift added to the World's Origin Cell and other values that reference World Grid Cells as a result of the clamping operation.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ClampingOperationInfo.TryGetPostClampOriginCellAndClampingShiftOfZoneGrouping(System.Int32,System.Int32,DeepSpaceLabs.SAM.Cell@,DeepSpaceLabs.SAM.Cell@)">
            <summary>
            Tries to get the Origin Cell value (expressed as a Cell on the Zone Grouping's Endless Grid) for a particular Zone Grouping after 
            the clamping operation, as well as the amount of Cell Shift that was added to each Cell of this Zone Grouping as a result of the shift.
            <para>
            When clamping occurs all current Endless Grid Cell values of the World's World Cells and Origin Cells are offset by a certain number of 
            Cells on each axis, which is why the Origin Cell might change. However keep in mind that the position of the Origin Cell will not have changed, 
            and for most purposes, you can ignore the change in origin cell. However, if you are using the Origin Cell value for a Zone Grouping for 
            some purposes, and storing it locally, you will need to update that local copy with this new value.
            </para>
            </summary>
            <param name="zoneIndex" type="int" link="Name.html">
            The index of the Zone whose information you want to retrieve.
            </param>
             <param name="groupingIndex" type="int">
            The index of the World Grouping whose information you want to retrieve.
            </param>
             <param name="postClampOriginCell" type="out Cell" link="Cell.html">
            The origin cell (post clamp) if the method returns true.
            </param>
            <param name="clampingShift" type="out Cell" link="Cell.html">
            The amount of cell shift that was added to each Cell during the clamping operation.
            </param>
            <displayName id="TryGetPostClampOriginCellAndClampingShiftOfZoneGrouping">
            TryGetPostClampOriginCellAndClampingShiftOfZoneGrouping(int, int, out Cell, out Cell)
            </displayName>
            <syntax>
            public bool TryGetPostClampOriginCellAndClampingShiftOfZoneGrouping(int zoneIndex, int groupingIndex, out Cell postClampOriginCell, out Cell clampingShift)
            </syntax>
            <returns type="type">
            True if the origin cell and clamping shift could be retrieved, false otherwise.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ClampingOperationInfo.ClearMemory">
            <summary>
            Can be used to manually clear the memory taken up by the Origin Cell and Clamping Shift data. If you do not call this, 
            this data will remain loaded until the next Clamping Operation is executed.
            </summary>
            <displayName id="ClearMemory">
            ClearMemory()
            </displayName>
            <syntax>
            public void ClearMemory()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TimingDataTracker">
            <summary>
            Tracks Asset Chunk Timing Data for SAM.
            <para>
            Timing data can only be tracked in the editor or in Development Builds via the this component. To do so, simply add the component to the scene and 
            make sure it is activated, and SAM will take care of the rest. You can then print out timing data by hooking up the 
            <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithSamples(System.Int32)" href="#LogTimingDataWithSamples">LogTimingDataWithSamples</see> or 
            method <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithoutSamples(System.Int32)" href="#LogTimingDataWithoutSamples">LogTimingDataWithoutSamples</see> to a 
            button, or by manually calling it. You can also do a custom print that does not using UnityEngine.Debug.Log via the 
            <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.CustomPrintTimingData(System.Int32,System.Boolean,System.Action{System.String})" href="#CustomPrintTimingData">CustomPrintTimingData</see> method, or 
            retrieve the timing data directly for some other purpose (via the 
            <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.GetTimingData(System.Collections.Generic.List{DeepSpaceLabs.SAM.ChunkTimingData})" href="#GetTimingData">GetTimingData</see> method). Any other public method should not be called by you!
            </para>
            <para>
            All timing data is an average of 1 or more samples, unless timing data is not available because an operation was never carried out for the 
            asset chunk, in which case Samples will be 0.
            </para>
            <para>
            A lot of the data is for async operations only, and thus does not include loading during Two Frame Initialization. Also note that because most 
            Chunk Streamers do not make use of async unload operations to remove asset chunks, unloading related data is rare (it will be 0 if not available).
            </para>
            <para>
            In general, <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithSamples(System.Int32)" href="#LogTimingDataWithSamples">LogTimingDataWithSamples</see> and 
            <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithoutSamples(System.Int32)" href="#LogTimingDataWithoutSamples">LogTimingDataWithoutSamples</see> are the only 
            methods you should need to use, although the <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.GetTimingData(System.Collections.Generic.List{DeepSpaceLabs.SAM.ChunkTimingData})" href="#GetTimingData">GetTimingData</see> 
            can also be used if you wish. The other public methods should not be called, as they are used exclusively by SAM related members.
            </para>
            </summary>
            <title>TimingDataTracker Class</title>
            <category>Secondary Components</category>
            <navigationName>TimingDataTracker</navigationName>
            <fileName>TimingDataTracker.html</fileName>
            <syntax>
            public class TimingDataTracker : MonoBehaviour
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithSamples(System.Int32)">
            <summary>
            Logs the asset chunk timing data stored using UnityEngine.Debug.Log with sample counts. Data is logged in a tabbed format, 
            which you can easily copy/paste into a program like Excel for easier 
            viewing and data review. The following information is included for each Asset Chunk that has been loaded by SAM (items 6-16 include an 
            extra column to the right of each item that show the number of samples for that data point):
            <para>
            1) The ID of the World each Asset Chunk belongs to.
            </para>
            <para>
            2) The World Grouping Index each Asset Chunk belongs to.
            </para>
            <para>
            3) The LOD (LOD Group) each Asset Chunk belongs to.
            </para>
            <para>
            4) The Streamable Grid Cell each Asset Chunk belongs to.
            </para>
            <para>
            5) The Asset Chunk Index of each chunk (in relation to other asset chunks part of the same World Cell).
            </para>
            <para>
            6) Initializing Load - Time taken to fire the method used to start an async load operation.
            </para>
            <para>
            7) Integrating - Time taken to complete an async load operation's final integrate step.
            </para>
            <para>
            8) Loading - Total time to complete an async load operation, from the moment before initializing it to the moments after integration.
            </para>
            <para>
            9) Configuring - Time taken to confire the Asset Chunk (for Prefabs, includes instantiation of the asset chunk from its source).
            </para>
            <para>
            10) Activating - Time taken to activate the Asset Chunk.
            </para>
            <para>
            11) Deactivating - Time taken to deactivate the Asset Chunk
            </para>
            <para>
            12) Initializing Unload - Time taken to initialize an async unload operation (uncommon).
            </para>
            <para>
            13) Deintigrating - Time taken remove the Asset Chunk from main memory during an async unload operation (uncommon).
            </para>
            <para>
            14) Unloading - Total time to complete an async unload operation, from the memoment before initializng it to the moments after deintigration (uncommon)
            </para>
            <para>
            15) Destroying - Time per frame used destroying the Asset Chunk or its children. Note, this is not a measure of the time it took 
            each time to destroy the Asset Chunk. It is a measure of the amount of time used in any given frame on Destroy calls on either the asset 
            chunk directly, or its children (if using a Chunk Destroyer). When using a Chunk Destroyer, destruction can occur over multiple frames, so 
            multiple samples can be taken of the same game object asset chunk. In conclusion, this data point can give you a rough idea of the amount of 
            frame time being used on destruction ops, not the time it takes to completely destroy an asset chunk!
            </para>
            <para>
            16) Releasing - Time taken to release handles associated with the asset chunks (typically only used by the Addressables System).
            </para>
            </summary>
            <param name="maxLinesPerMessage" type="int">
            The maximum number of lines to include in each printed message. A value around 100 is recommended if using UnityEngine.Debug.Log, as 
            longer messages can get cutoff in the editor, however feel free to experiment to find the best value.
            </param>
            <displayName id="LogTimingDataWithSamples">
            LogTimingDataWithSamples(int)
            </displayName>
            <syntax>
            public void LogTimingDataWithSamples(int maxLinesPerMessage)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithoutSamples(System.Int32)">
            <summary>
            Logs the asset chunk timing data stored using UnityEngine.Debug.Log without sample counts. Data is logged in a tabbed format, 
            which you can easily copy/paste into a program like Excel for easier 
            viewing and data review. The following information is included for each Asset Chunk that has been loaded by SAM:
            <para>
            1) The ID of the World each Asset Chunk belongs to.
            </para>
            <para>
            2) The World Grouping Index each Asset Chunk belongs to.
            </para>
            <para>
            3) The LOD (LOD Group) each Asset Chunk belongs to.
            </para>
            <para>
            4) The Streamable Grid Cell each Asset Chunk belongs to.
            </para>
            <para>
            5) The Asset Chunk Index of each chunk (in relation to other asset chunks part of the same World Cell).
            </para>
            <para>
            6) Initializing Load - Time taken to fire the method used to start an async load operation.
            </para>
            <para>
            7) Integrating - Time taken to complete an async load operation's final integrate step.
            </para>
            <para>
            8) Loading - Total time to complete an async load operation, from the moment before initializing it to the moments after integration.
            </para>
            <para>
            9) Configuring - Time taken to confire the Asset Chunk (for Prefabs, includes instantiation of the asset chunk from its source).
            </para>
            <para>
            10) Activating - Time taken to activate the Asset Chunk.
            </para>
            <para>
            11) Deactivating - Time taken to deactivate the Asset Chunk
            </para>
            <para>
            12) Initializing Unload - Time taken to initialize an async unload operation (uncommon).
            </para>
            <para>
            13) Deintigrating - Time taken remove the Asset Chunk from main memory during an async unload operation (uncommon).
            </para>
            <para>
            14) Unloading - Total time to complete an async unload operation, from the memoment before initializng it to the moments after deintigration (uncommon)
            </para>
            <para>
            15) Destroying - Time per frame used destroying the Asset Chunk or its children. Note, this is not a measure of the time it took 
            each time to destroy the Asset Chunk. It is a measure of the amount of time used in any given frame on Destroy calls on either the asset 
            chunk directly, or its children (if using a Chunk Destroyer). When using a Chunk Destroyer, destruction can occur over multiple frames, so 
            multiple samples can be taken of the same game object asset chunk. In conclusion, this data point can give you a rough idea of the amount of 
            frame time being used on destruction ops, not the time it takes to completely destroy an asset chunk!
            </para>
            <para>
            16) Releasing - Time taken to release handles associated with the asset chunks (typically only used by the Addressables System).
            </para>
            </summary>
            <param name="maxLinesPerMessage" type="int">
            The maximum number of lines to include in each printed message. A value around 100 is recommended if using UnityEngine.Debug.Log, as 
            longer messages can get cutoff in the editor, however feel free to experiment to find the best value.
            </param>
            <displayName id="LogTimingDataWithoutSamples">
            LogTimingDataWithoutSamples(int)
            </displayName>
            <syntax>
            public void LogTimingDataWithoutSamples(int maxLinesPerMessage)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimingDataTracker.CustomPrintTimingData(System.Int32,System.Boolean,System.Action{System.String})">
            <summary>
            Logs the asset chunk timing data stored. Data is logged in a tabbed format, which you can easily copy/paste into a program like Excel for easier 
            viewing and data review. The following information is included for each Asset Chunk that has been loaded by SAM:
            <para>
            1) The ID of the World each Asset Chunk belongs to.
            </para>
            <para>
            2) The World Grouping Index each Asset Chunk belongs to.
            </para>
            <para>
            3) The LOD (LOD Group) each Asset Chunk belongs to.
            </para>
            <para>
            4) The Streamable Grid Cell each Asset Chunk belongs to.
            </para>
            <para>
            5) The Asset Chunk Index of each chunk (in relation to other asset chunks part of the same World Cell).
            </para>
            <para>
            6) Initializing Load - Time taken to fire the method used to start an async load operation.
            </para>
            <para>
            7) Integrating - Time taken to complete an async load operation's final integrate step.
            </para>
            <para>
            8) Loading - Total time to complete an async load operation, from the moment before initializing it to the moments after integration.
            </para>
            <para>
            9) Configuring - Time taken to confire the Asset Chunk (for Prefabs, includes instantiation of the asset chunk from its source).
            </para>
            <para>
            10) Activating - Time taken to activate the Asset Chunk.
            </para>
            <para>
            11) Deactivating - Time taken to deactivate the Asset Chunk
            </para>
            <para>
            12) Initializing Unload - Time taken to initialize an async unload operation (uncommon).
            </para>
            <para>
            13) Deintigrating - Time taken remove the Asset Chunk from main memory during an async unload operation (uncommon).
            </para>
            <para>
            14) Unloading - Total time to complete an async unload operation, from the memoment before initializng it to the moments after deintigration (uncommon)
            </para>
            <para>
            15) Destroying - Time per frame used destroying the Asset Chunk or its children. Note, this is not a measure of the time it took 
            each time to destroy the Asset Chunk. It is a measure of the amount of time used in any given frame on Destroy calls on either the asset 
            chunk directly, or its children (if using a Chunk Destroyer). When using a Chunk Destroyer, destruction can occur over multiple frames, so 
            multiple samples can be taken of the same game object asset chunk. In conclusion, this data point can give you a rough idea of the amount of 
            frame time being used on destruction ops, not the time it takes to completely destroy an asset chunk!
            </para>
            <para>
            16) Releasing - Time taken to release handles associated with the asset chunks (typically only used by the Addressables System).
            </para>
            </summary>
            <param name="maxLinesPerMessage" type="int">
            The maximum number of lines to include in each printed message. A value around 100 is recommended if using UnityEngine.Debug.Log, as 
            longer messages can get cutoff in the editor, however feel free to experiment to find the best value.
            </param>
            <param name="includeSampleCounts" type="bool">
            Whether to include the Sample Counts of the timing data. Sample Counts can give you an indicator of how reliable each piece of data is.
            </param>
            <param name="PrintAction" type="Action&lt;string&gt;">
            The action to use to print the timing data. If you just want UnityEngine.Debug.Log to be used, 
            use <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithSamples(System.Int32)" href="#LogTimingData">LogTimingData</see> instead.
            </param>
            <displayName id="CustomPrintTimingData">
            CustomPrintTimingData(int, bool, Action&lt;string&gt;)
            </displayName>
            <syntax>
            public void CustomPrintTimingData(int maxLinesPerMessage, bool includeSampleCounts, Action&lt;string&gt; PrintAction)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimingDataTracker.GetTimingData(System.Collections.Generic.List{DeepSpaceLabs.SAM.ChunkTimingData})">
            <summary>
            Gets all chunk timing data, sorted by World ID, then World Grouping Index, LOD, Streamable Grid Cell, and finally chunk index. Put another way, 
            all asset chunk data for one world will be grouped together, then within that group all asset chunks belonging to the same World Groupign are 
            grouped together, then within that group all asset chunks of the same LOD are grouped, and so on.
            <para>
            It is recommended to use the <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithSamples(System.Int32)" href="#LogTimingDataWithSamples">LogTimingDataWithSamples</see> 
            or <see cref="M:DeepSpaceLabs.SAM.TimingDataTracker.LogTimingDataWithoutSamples(System.Int32)" href="#LogTimingDataWithoutSamples">LogTimingDataWithoutSamples</see> method instead, 
            as this takes care of printing the timing data for you. However, if you want to 
            make use of the data for some other purpose, you can use this method.
            </para>
            </summary>
            <param name="chunkTimingData" type="List&lt;ChunkTimingData&gt;" link="ChunkTimingData.html">
            A list that will be filled with the timing data.
            </param>
            <displayName id="GetTimingData">
            GetTimingData(List&lt;ChunkTimingData&gt;)
            </displayName>
            <syntax>
            public void GetTimingData(List&lt;ChunkTimingData&gt; chunkTimingData)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AddressableErrorRepairerInfo">
            <summary>
            An optional class which can be overriden to provide custom repair logic for failed addressable download operations. Basically, when one or more 
            downloads fail, this classes AttemptRepair method will be called to try to fix the errors causing the failed downloads. If repairs were successfull, 
            the Addressable Streamer you are using will attempt to redownload the assets. Repair is only attempted once, after which the error handling 
            logic will be triggered.
            <para>
            The errors reported should be on of the following, however there is no gaurantee. You should check for one of these errors first and if not found, 
            move on to trying to identify the error a different way. We cannot offer any advice on how to resolve/fix any of these errors.
            </para>
            <para>
            "Request aborted" 
            "Unable to write data" 
            "Malformed URL" 
            "Out of memory" 
            "No Internet Connection" 
            "Encountered invalid redirect (missing Location header?)" 
            "Cannot modify request at this time" 
            "Unsupported Protocol" 
            "Destination host has an erroneous SSL certificate" 
            "Unable to load SSL Cipher for verification" 
            "SSL CA certificate error" 
            "Unrecognized content-encoding" 
            "Request already transmitted" 
            "Invalid HTTP Method" 
            "Header name contains invalid characters" 
            "Header value contains invalid characters" 
            "Cannot override system-specified headers" 
            "Backend Initialization Error" 
            "Cannot resolve proxy" 
            "Cannot resolve destination host" 
            "Cannot connect to destination host" 
            "Access denied" 
            "Generic/unknown HTTP error" 
            "Unable to read data" 
            "Request timeout" 
            "Error during HTTP POST transmission" 
            "Unable to complete SSL connection" 
            "Redirect limit exceeded" 
            "Received no data in response" 
            "Destination host does not support SSL" 
            "Failed to transmit data" 
            "Failed to receive data" 
            "Login failed" 
            "SSL shutdown failed" 
            "Redirect limit is invalid" 
            "Not implemented"
            "Data Processing Error, see Download Handler error" 
            "Unknown Error"
            </para>
            </summary>
            <title>
            AddressableErrorRepairer Class
            </title>
            <category>Secondary Components</category>
            <navigationName>
            AddressableErrorRepairer
            </navigationName>
            <fileName>AddressableErrorRepairer.html</fileName>
            <syntax>
            public abstract class AddressableErrorRepairer : MonoBehaviour
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableErrorRepairerInfo.AttemptRepair(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Boolean})">
            <summary>
            Method used to attempt a repair of any errors that caused the addressable asset downloads to fail. Since multiple downloads can fail, 
            the method takes in a list of AsyncOperationHandles, each representing a failed download. You can use the GetDownloadError method to retrieve 
            a useful error message that you may be able to use to figure out what is goign on. These error messages may be all the same, or 
            they may be different. You may just need to fix one issue, or fix multiple issues. When the method is invoked, errorsRepaired will be empty. 
            For each handle, you must add to the errorsRepaired list either true or false. True indicating that the error that caused the download to fail
            was successfully repaired, false indicating that it was not. The order of this list must match the order of the errorMessages list 1 to 1.
            <para>
            After the method finishes executing, the Addressable Streamer will attempt to redownload (one attempt only) assets for handles who's errors were repaired. 
            If an error was not repaired, the streamer will try to load the lowest quality LOD asset or a Place Holder asset for the associated cell chunk, 
            depending on the configuration of the Streamable Grid and Streamer's Fail-Safe. If fail-safe assets are not being used or cannot be downloaded, an exception 
            is thrown.
            </para>
            </summary>
            <param name="failedHandles">The list of handles that failed.</param>
            <param name="errorsRepaired">The list detailing whether each error that caused each download to fail was repaired.</param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="HandleException">
            HandleException(AsyncOperationHandle, Exception)
            </displayName>
            <syntax>
            public ReturnType HandleException(AsyncOperationHandle handle, Exception exception)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableErrorRepairerInfo.GetDownloadError(System.Int32)">
            <summary>
            Gets the Remote Provider Exception Web Result Error if available. If not available, returns the 
            outer exception as a string.
            </summary>
            <param name="fromHandle">
            The handle to retrieve the error message from.
            </param>
            <returns type="string">
            The error message
            </returns>
            <displayName id="GetDownloadError">
            GetDownloadError(AsyncOperationHandle)
            </displayName>
            <syntax>
            public static string GetDownloadError(AsyncOperationHandle fromHandle)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AddressableExceptionHandlerInfo">
            <summary>
            This class can be used to provide the Addressable Streamer you are using with a custom method for exception handling. If you do not provide this 
            class, and Log Runtime Exceptions is enabled in your Addressable Settings, the streamers will only log Invalid Key Exceptions. Usually you 
            will not need to provide a custom exception handler, however the option is there if you want it.
            <para>
            </para>
            </summary>
            <title>
            AddressableExceptionHandler Class
            </title>
            <category>Secondary Components</category>
            <navigationName>
            AddressableExceptionHandler
            </navigationName>
            <fileName>AddressableExceptionHandler.html</fileName>
            <syntax>
            public abstract class AddressableExceptionHandler : MonoBehaviour
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableExceptionHandlerInfo.HandleException(System.Int32,System.Exception)">
            <summary>
            Override to provide custom exception handling for failed async operations using one of the addressable chunk streamers
            </summary>
            <param name="handle" type="AsyncOperationHandle">
            The handle for the async operation that failed.
            </param>
            <param name="exception" type ="Exception">
            The exception that was thrown during the failed load op.
            </param>
            <displayName id="HandleException">
            HandleException(AsyncOperationHandle, Exception)
            </displayName>
            <syntax>
            public abstract void HandleException(AsyncOperationHandle handle, Exception exception)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo">
            <summary>
            Base class for addressable chunk streamer implementations. While it is not strictly necessary to use this with your custom addressable 
            chunk streamers, doing so will automate many necessary task related to loading addressable assets.
            <para>
            The only thing you need to provide implementations for is the FileExtension property, the DetatchAndUnloadChunksFromCells method, 
            and a custom AddressableStreamerBaseUser object, which should be returned in your implementation of the CreateAddressableLoaderUser method.
            </para>
            <para>
            Furthermore, your custom AddressableStreamerBaseUser must implement certain methods and properties, which your IDE should highlight when implementing the class. You 
            can also find information about those members, as well as other public/protected members of the AddressableStreamerBaseUser class on this page, listed among 
            the normal members of the class. You can identify these members easily, as they will have AddressableStreamerBaseUser. in front of their name.
            </para>
            <para>
            There are two additional nested classes which you may need to make use of in your AddressableStreamerBaseUser derived classes. These are the 
            LoadedAsyncOperationInfo and ReadyOp classes. Fields, methods, and properties of these classes are listed on this page as well and begin with 
            LoadedAsyncOperationInfo and ReadyOp respectively.
            </para>
            </summary>
            <title>
            AddressableBaseChunkStreamer Class
            </title>
            <category>Chunk Streamers</category>
            <navigationName>
            AddressableBaseChunkStreamer
            </navigationName>
            <fileName>AddressableBaseChunkStreamer.html</fileName>
            <syntax>
            public abstract class AddressableBaseChunkStreamer : <see cref="T:DeepSpaceLabs.SAM.ChunkStreamer" href="ChunkStreamer.html">ChunkStreamer</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ExtraDataToPrependKey">
            <summary>
            See <see cref="P:DeepSpaceLabs.SAM.ChunkStreamer.ExtraDataToPrependKey" href="ChunkStreamer.html#ExtraDataToPrependKey">ChunkStreamer.ExtraDataToPrependKey</see> 
            for more information on this property. This implemention simply returns the value 
            of 'Prepend Data Key' set in the inspector if 'Prepend Extra User Data' is true, or null if 'Prepend Extra User Data' is false.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ExtraDataToAppendKey">
            <summary>
            See <see cref="P:DeepSpaceLabs.SAM.ChunkStreamer.ExtraDataToAppendKey" href="ChunkStreamer.html#ExtraDataToAppendKey">ChunkStreamer.ExtraDataToAppendKey</see> 
            for more information on this property. This implemention simply returns the value 
            of 'Append Data Key' set in the inspector if 'Append Extra user Data' is true, or null if 'Prepend Extra User Data' is false.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ConstantDataToAppend">
            <summary>
            Returns the <see cref="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.FileExtension" href="AddressableBaseChunkStreamer.html#FileExtension">FileExtension</see> 
            if Append File Extension is enabled in the inspector, otherwise returns null.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.FileExtension">
            <summary>
            Override to return the file extension associated with the addressable assets being loaded. You can override this to try and load custom asset types, such as 
            scriptable objects, however there is no gaurantee that this will work. This is used when Append File Type is enabled in the inspector.
            <para>
            For Prefabs this is .prefab, for scenes it is .unity
            </para>
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AsyncLoadStrategy">
            <summary>
            Gets or sets the Async Load Strategy. 
            </summary>
            <type link="AsyncLoadStrategy.html">AsyncLoadStrategy</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.MaxLoadAttempts">
            <summary>
            Gets or sets the maximum number of attempts allowed for loading an asset.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.UseAltLODFailSafe">
            <summary>
            Gets whether the streamer has been configured to a use a lowest quality LOD fail-safe asset when the original asset  
            cannot be loaded for a cell chunk.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.UsePlaceholderFailSafe">
            <summary>
            Gets whether the streamer has been configured to a use a placeholder fail-safe asset when the original asset (or lowest quality LOD asset) 
            cannot be loaded for a cell chunk.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.PrintErrorToConsole">
            <summary>
            When FailureHandling is set to LoadPlaceholder, this controls whether the exception reported by Unity for the failed load operation is 
            printed as an error in the console. Get or Set
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ErrorRepairer">
            <summary>
            Gets the Addressable Error Repairer associated with the Addressable Loader.
            </summary>
            <type link="AddressableErrorRepairer.html">AddressableErrorRepairer</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AwakeExtended">
            <summary>
            Awake implementation. If you want to implement custom Awake logic, implement AwakeExtended2.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AwakeExtended2">
            <summary>
            Can be overriden to implement Awake related logic. Called at end of base classes AwakeExtended method.
            </summary>
            <displayName id="AwakeExtended2">
            AwakeExtended2()
            </displayName>
            <syntax>
            protected virtual void AwakeExtended2()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.Start">
            <summary>
            Start implementation. If you want to implement custom Start logic, implement StartExtended.
            </summary>
            <displayName id="Start">
            Start()
            </displayName>
            <syntax>
            protected void Start()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.StartExtended">
            <summary>
            Can be overriden to implement Start related logic. Called at end of base classes Start method.
            </summary>
            <displayName id="StartExtended">
            StartExtended()
            </displayName>
            <syntax>
            protected virtual void StartExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.OnDestroy">
            <summary>
            OnDestroy implementation. If you want to implement custom OnDestroy logic, implement OnDestroyExtended.
            </summary>
            <displayName id="OnDestroy">
            OnDestroy()
            </displayName>
            <syntax>
            protected void OnDestroy()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.OnDestroyExtended">
            <summary>
            Can be overriden to implement OnDestroy related logic. Called at end of base classes OnDestroy method.
            </summary>
            <displayName id="OnDestroyExtended">
            OnDestroyExtended()
            </displayName>
            <syntax>
            protected virtual void OnDestroyExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Creates a new ChunkStreamerUser by calling CreateAddressableLoaderUser. This method is overriden to force sub classes 
            to create a new ChunkStreamerUser that derives from AddressableLoaderBaseUser. This is necessary because 
            AddressableLoaderBaseUser is an abstract class and some of its methods/properties need to be implemented.
            </summary>
            <param name="LODGroup" type="ILodGroup" link="IZoneGrouping.html">
            The lod group being registered.
            </param>
            <returns type="ChunkStreamerUser">
            A new user object created using the LODGroup as input.
            </returns>
            <displayName id="CreateNewUser">
            CreateNewUser()
            </displayName>
            <syntax>
            protected sealed override ChunkStreamerUser CreateNewUser(IZoneGrouping LODGroup)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.CreateAddressableLoaderUser(DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Override to return a new user object that derives from AddressableStreamerBaseUser. The derived class must implement certain 
            abstract methods/properties from AddressableStreamerBaseUser.
            </summary>
            <param name="LODGroup" type="ILodGroup" link="IZoneGrouping.html">
            The lod group being registered.
            </param>
            <returns type="AddressableStreamerBaseUser">A user object deriving from AddressableStreamerBaseUser</returns>
            <displayName id="CreateAddressableLoaderUser">
            CreateAddressableLoaderUser()
            </displayName>
            <syntax>
            protected abstract AddressableStreamerBaseUser CreateAddressableLoaderUser(IZoneGrouping LODGroup)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.LoadAndAttachChunksToCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Loads and attaches the chunks associated with the input cells to the cells over a period of frames.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose objects need to be loaded and attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "LoadAndAttachChunksToCells">LoadAndAttachChunksToCells(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; LoadAndAttachChunksToCells(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.LoadAssetForCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.String@,DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.IResourceLocation@,System.String@)">
            <summary>
            Used to load lower quality assets when a streamer is unable to load a higher quality addressable asset. You shouldn't need to 
            call this yourself, unless you are creating a custom Addressable Chunk Streamer.
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The Streamable Grid Cell indexes associated with the asset we want to load.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk we want to load.
            </param>
            <param name="userID" type="int">
            The ID of the user whose info will be used to load the asset.
            </param>
            <param name="chunkName" type="string">
            The name of the chunk asset that this streamer is attempted to load, set once the method executes.
            </param>
            <param name="location" type="IResourceLocation">
            The IResourceLocation used to load the asset. May be null if the Key was used instead to load the asset.
            </param>
            <param name="key" type="string">
            The key used to load the asset. May be null if the IResourceLocation was used instead to load the asset.
            </param>
            <returns type="AsyncOperationHandle">
            An async op handle for the asset that is being loaded.
            </returns>
            <displayName id="LoadAssetForCell">
            LoadAssetForCell(Cell, int, int, out string, out IResourceLocation, out string)
            </displayName>
            <syntax>
            public AsyncOperationHandle LoadAssetForCell(Cell streamableGridCell, int chunkIndex, int userID, out string chunkName, out IResourceLocation location, out string key)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.RecalculateIResourceLocations">
            <summary>
            Recalculates the IResourceLocations for the addressable assets associated with all users of this streamer. This will do nothing if 
            Pre Calculate IResourceLocations is disabled. Only use this when you know the locations need to be recalculated.
            <para>
            If you only need one users data reculated, use <see cref="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.RecalculateIResourceLocations(System.Int32)" href="AddressableBaseChunkStreamer.html#RecalculateIResourceLocations2">RecalculateIResourceLocations</see> instead.
            </para>
            </summary>
            <displayName id="RecalculateIResourceLocations1">
            RecalculateIResourceLocations()
            </displayName>
            <syntax>
            public void RecalculateIResourceLocations()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.RecalculateIResourceLocations(System.Int32)">
            <summary>
            Recalculates the IResourceLocations for the addressable assets associated with the user ID. This will do nothing if 
            Pre Calculate IResourceLocations is disabled. Only use this when you know the locations need to be recalculated.
            <para>
            You can use the World's <see cref="M:DeepSpaceLabs.SAM.World.GetChunkStreamerAndID(System.Int32,System.Int32,System.Int32,DeepSpaceLabs.SAM.ChunkStreamer@,System.Int32@)" href="World.html#GetChunkStreamerAndID">GetChunkStreamerAndID</see> 
            method in order to find out the chunk streamer ID for a particular World Grouping and LOD.
            </para>
            </summary>
            <param name="userID" type="int">
            The ID of the user whose IResourceLocations you want to recalculate.
            </param>
            <displayName id="RecalculateIResourceLocations2">
            RecalculateIResourceLocations(int)
            </displayName>
            <syntax>
            public void RecalculateIResourceLocations(int userID)
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.CanReuseAddressables">
            <summary>
            An abstract property that must be overriden to return a value indicating whether the addressable assets (associated with the load operation) loaded by your streamer 
            implementation can be reused between World Cells with the same Streamable Grid Cell index.
            <para>
            For example, the 
            default Addressable Scene Streamer returns false for this, because scenes do not use an underlying 
            asset that can be reused. The Prefab Streamer, on the other hand, returns true, because there is an 
            underlying prefab asset that is loaded, which can be instantiated as many times as needed in order 
            to be shared among different World Cells with the same Streamable Grid Cell index.
            </para>
            <para>
            Reusing the underlying addressable asset is beneficial because it cuts down on the number of 
            Async load operations needed. When this returns true, the key used to store each LoadedAsyncOperationInfo object is a combination of the 
            Streamable Grid Cell index of the World Cell that triggered the load, and the chunk index of whatever chunk is needed by the cell. 
            When other World Cells using the same Streamable Grid Cell index 
            need to have chunks loaded for them, they are able to use the index (plus chunk number of the asset they need) 
            to identify an addressable asset that has already 
            been loaded, and use it to make a copy that can be used for that World Cell.
            </para>
            <para>
            When this returns false, each World Cell will trigger an Async Load Operation, even if a World Cell with the same 
            Streamable Grid Cell indexes has already been loaded. The key used to store the LoadedAsyncOperationInfo comes from the 
            AsyncOperationHandle itself, which is retrieved by calling the GetNonReusableAssetKey method (which you also need 
            to implement in your custom user class).
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.FileType">
            <summary>
            An abstract property that must be overriden to return a value indicating the file type of the addressable assets 
            (for example typeof(SceneInstance) or typeof(GameObject)).
            </summary>
            <type>Type</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.IsWaitingOnJob">
            <summary>
            Gets a value indicating whether the user is waiting on a multi threaded job to finish. This is very unlikely to ever be true, however it is still necessary 
            to check this in your custom streamer whenever one of its public methods is called (such as 
            LoadAndAttachChunksToCellsInSingleFrame or DetatchAndUnloadChunksFromCells). If the method is an enumerator, simply yield 
            until IsWaitingOnJob returns false. If there is no possibility to wait (i.e., the method returns something other than IEnumerator&lt;YieldInstruction&gt;) 
            you can call the method CompleteAllJobsImmediately to force the any running jobs to complete immediately.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.#ctor(System.Object,DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Creates a new instance of the AddressableStreamerBaseUser. You will never call this directly, instead you will create a class derived from 
            AddressableStreamerBaseUser that calls base(parent, LODGroup) after the constructor's declaration.
            </summary>
            <param name="parent" type="AddressableBaseChunkStreamer" link="AddressableBaseChunkStreamer.html">
            The parent streamer of this instance.
            </param>
            <param name="LODGroup" type="IZoneGrouping" link="IZoneGrouping.html">
            The LOD Group associated with the instance.
            </param>
            <displayName>
            AddressableStreamerBaseUser.AddressableStreamerBaseUser(AddressableBaseChunkStreamer, IZoneGrouping)
            </displayName>
            <syntax>
            public AddressableStreamerBaseUser(AddressableBaseChunkStreamer parent, IZoneGrouping LODGroup) : base(parent, LODGroup)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.IsLowestQualityLODStreamerCompatible(DeepSpaceLabs.SAM.ChunkStreamer)">
            <summary>
            Must be overriden to return a value that indicates whether the Chunk Streamer used by the lowest quality 
            LOD for the Streamable Grid associated with this user 
            is compatible with the type of Addressable Chunk Streamer in use. Typically it should be of the same type. This is only 
            called when UseAltLODFailSafe would otherwise be true. If you return false from this method, UseAltLODFailSafe will be made false as well. 
            <para>
            If the streamer is compatible, you can and should store it (casted to the derived type of streamer you 
            are using) along with the chunkStreamerUserID to avoid having to look up the streamer and ID each time they are needed.
            </para>
            </summary>
            <param name="streamerOfLowestQualityLODAssets" type="ChunkStreamer" link="ChunkStreamer.html">
            The Chunk Streamer used by the lowest quality LOD.
            </param>
            <returns type="bool">
            Should return true if the Chunk Streamer from the lowest quality LOD is compatible with this Chunk Streamer. False otherwise.
            </returns>
            <displayName id="AddressableStreamerBaseUser.IsLowestQualityLODStreamerCompatible">
            AddressableStreamerBaseUser.IsLowestQualityLODStreamerCompatible(ChunkStreamer)
            </displayName>
            <syntax>
            protected abstract bool IsLowestQualityLODStreamerCompatible(ChunkStreamer streamerOfLowestQualityLODAssets)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.CreateCellString(DeepSpaceLabs.SAM.IZoneLODGroup,System.String,System.String)">
            <summary>
            Creates a Cell String object, automatically taking into account whether Use Single Chunk Set For All Cells is enabled on the 
            LOD Group associated with the user.
            </summary>
            <param name="LODGroup" type="IZoneGrouping" link="IZoneGrouping.html">
            The LOD Group associated with this user.
            </param>
            <param name="extraDataToPrepend" type="string">
            Extra data to prepend to the strings generated with the Cell String. Pass this into your CellString object, and don't worry about 
            whether it is null or blank, as those cases are handled automatically by the CellString.
            </param>
            <param name="extraDataToAppend" type="string">
            Extra data to append to the strings generated with the Cell String. Pass this into your CellString object, and don't worry about 
            whether it is null or blank, as those cases are handled automatically by the CellString.
            </param>
            <returns type="CellString" link="CellString.html">
            The Cell String object created.
            </returns>
            <displayName id="AddressableStreamerBaseUser.CreateCellString">
            AddressableStreamerBaseUser.CreateCellString(IZoneGrouping, string, string)
            </displayName>
            <syntax>
            protected sealed override CellString CreateCellString(IZoneGrouping LODGroup, string extraDataToPrepend, string extraDataToAppend)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.TryGetReusableAssetLoadInfo(System.Object,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Use to try and retrieve LoadedAsyncOperationInfo for a reusable asset that has already 
            been loaded.  If your custom addressable chunk streamer has asset reuse disabled, 
            will always return false and you must ignore the out arguments.
            </summary>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            The World Cell whose chunks you are trying to load.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk you are trying to load.
            </param>
            <param name="streamableGridCellToLoad" type="Cell" link="Cell.html">
            The Streamable Grid Cell that will actually be loaded for this World Cell, as calculated 
            by the user based on whether the LODGroup is using a Single Object Cell Set
            </param>
            <param name="assetKey" type="string">
            The key produced by the user to try and retrieve the asset load info. Will be set 
            correctly so long as the custom addressable chunk streamer does not have asset reuse disabled.
            </param>
            <param name="info" type="LoadedAsyncOperationInfo">
            If the method returns true, this will contain the info about the async operation handle that 
            was used to load the asset to be reused (found in the handles .Result property). Note, if you 
            use the Result, you must call IncrementUserCount!
            </param>
            <returns type="bool">
            Returns true if there is an addressable asset that can be reused by the input World Cell, 
            and false if not.
            </returns>
            <displayName id="AddressableStreamerBaseUser.TryGetReusableAssetLoadInfo1">
            AddressableStreamerBaseUser.TryGetReusableAssetLoadInfo(WorldCell, int, out Cell, out int, out LoadedAsyncOperationInfo)
            </displayName>
            <syntax>
            public bool TryGetReusableAssetLoadInfo(WorldCell worldCell, int chunkIndex, out Cell streamableGridCellToLoad, out int assetKey, out LoadedAsyncOperationInfo info)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.TryGetReusableAssetLoadInfo2(System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Use to try and retrieve LoadedAsyncOperationInfo for a reusable asset that has already 
            been loaded. If your custom addressable chunk streamer has asset reuse disabled, 
            will always return false and you must ignore the out arguments.
            <para>
            This alternative method can be used if you have already determined the correct 
            Streamable Grid Cell to use to load the Assets for a particular World Cell.
            </para>
            </summary>
            <param name="streamableGridCellToLoad" type="Cell" link="Cell.html">
            The Streamable Grid Cell that is actually being used to load Assets for a given World Cell.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk you are trying to load.
            </param>
            <param name="assetKey" type="string">
            The key produced by the user to try and retrieve the asset load info. Will be set 
            correctly so long as the custom addressable chunk streamer does not have asset reuse disabled.
            </param>
            <param name="info" type="LoadedAsyncOperationInfo">
            If the method returns true, this will contain the info about the async operation handle that 
            was used to load the asset to be reused (found in the handles .Result property). Note, if you 
            use the Result, you must call IncrementUserCount!
            </param>
            <returns type="bool">
            Returns true if there is an addressable asset that can be reused by the input 
            World Cell, and false if not.
            </returns>
            <displayName id="AddressableStreamerBaseUser.TryGetReusableAssetLoadInfo2">
            AddressableStreamerBaseUser.TryGetReusableAssetLoadInfo(Cell, int, out int, out LoadedAsyncOperationInfo)
            </displayName>
            <syntax>
            public bool TryGetReusableAssetLoadInfo(Cell streamableGridCellToLoad, int chunkIndex, out int assetKey, out LoadedAsyncOperationInfo info)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.TryGetAssetLoadInfo(System.Int32,System.Int32)">
            <summary>
            Tries to get information associated with a completed load operation using a specific integer key. If the load operation is 
            reusable, you should use one of the 
            <see href="AddressableBaseChunkStreamer.html#AddressableStreamerBaseUser.TryGetReusableAssetLoadInfo1">TryGetReusableAssetLoadInfo</see> methods instead. 
            Otherwise, use this method with the same key 
            returned by your implementation of <see href="AddressableBaseChunkStreamer.html#AddressableStreamerBaseUser.GetNonReusableAssetKey">GetNonReusableAssetKey</see>.
            </summary>
            <param name="key" type="int">
            The key to use to get the information.
            </param>
            <param name="info" type="LoadedAsyncOperationInfo">
            If the method returns true, this will contain the information.
            </param>
            <returns type="bool">
            True if the information could be retrieved, false otherwise.
            </returns>
            <displayName id="AddressableStreamerBaseUser.TryGetAssetLoadInfo">
            AddressableStreamerBaseUser.TryGetAssetLoadInfo(int, out LoadedAsyncOperationInfo)
            </displayName>
            <syntax>
            public bool TryGetAssetLoadInfo(int key, out LoadedAsyncOperationInfo info)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.RemoveLoadedAsyncOpInfo(System.Int32,System.Int32)">
            <summary>
            Can be used to remove information for a completed load operation from the users internal collection of infos. This should be used in cases where your 
            streamer implementation is manually unloading the handle associated with the load operation. Typically this is only done if the underlying handle is 
            not being resused among multiple World Cells, as otherwise you are better off destroying the instance of the resource, then calling 
            RemoveUserOfReusableAsset and letting the base addressale chunk streamer unload the handle and remove this info.
            </summary>
            <param name="key" type="int">
            The key associated with the information, which should match the key returned by your implementation of the 
            <see href="AddressableBaseChunkStreamer.html#AddressableStreamerBaseUser.GetNonReusableAssetKey">GetNonReusableAssetKey</see> method. Note that since you are manually unloading 
            the handle, you should have access to it and be able to retrieve the same key.
            </param>
            <param name="info" type="LoadedAsyncOperationInfo">
            The info being removed. Passing this in allows the info object to be reset and returned to the pool without needing to 
            be retrieved from the internal collection, which saves a few CPU cycles.
            </param>
            <displayName id="AddressableStreamerBaseUser.RemoveLoadedAsyncOpInfo">
            AddressableStreamerBaseUser.RemoveLoadedAsyncOpInfo(int, LoadedAsyncOperationInfo)
            </displayName>
            <syntax>
            public void RemoveLoadedAsyncOpInfo(int key, LoadedAsyncOperationInfo info)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.CompleteAllJobsImmediately">
            <summary>
            Completes any jobs currently running immediately. Note, this may cause a hitch in the frame rate. Jobs are used by the base chunk streamer to 
            execute some CPU intensive code. Whenenever a publich method of your custom streamer is called, you need to check whether the user is 
            currently running a job by querying the IsWaitingOnJob property. If it is waiting, you need to yield until the job is complete 
            (IsWaitingOnJob returns false). If for any reason you are unable to yield, you can call this method to force the job to complete immediately.
            </summary>
            <displayName id="AddressableStreamerBaseUser.CompleteAllJobsImmediately">
            AddressableStreamerBaseUser.CompleteAllJobsImmediately()
            </displayName>
            <syntax>
            public void CompleteAllJobsImmediately()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.RemoveUserOfReusableAsset(DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Removes a single user for the reusable chunk asset associated with the input World Cell and chunk index. If the user count for the 
            asset falls to 0, the handle will be unloaded and LoadedAsyncOperationInfo removed.
            </summary>
            <param name="cell" type="WorldCell" link="WorldCell.html">
            The World Cell associated with the asset.
            </param>
            <param name="chunkIndex" type="int">
            The chunk index of the asset.
            </param>
            <displayName id="AddressableStreamerBaseUser.RemoveUserOfReusableAsset">
            AddressableStreamerBaseUser.RemoveUserOfReusableAsset(WorldCell, int)
            </displayName>
            <syntax>
            public void RemoveUserOfReusableAsset(WorldCell cell, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.CheckForLoadAndAttachChunksToCellsInSingleFrameExceptions">
            <summary>
            Some custom streamers cannot load addressable assets in one or two frames, which makes them incompatible with the Component Manager's 
            Initialize method or 'Initialize On Awake' property. This method should perform checks to see if that's the case and throw exceptions 
            if any issues exist. If you know there will never be any issues, you do not need to provide an override.
            </summary>
            <displayName id="AddressableStreamerBaseUser.CheckForLoadAndAttachChunksToCellsInSingleFrameExceptions">
            AddressableStreamerBaseUser.CheckForLoadAndAttachChunksToCellsInSingleFrameExceptions()
            </displayName>
            <syntax>
            public virtual void CheckForLoadAndAttachChunksToCellsInSingleFrameExceptions()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.GetNonReusableAssetKey(DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AsyncOperationHandle)">
            <summary>
            This is called when CanReuseAddressables is implemented to return false, and should return a unique key that 
            can be used to store the passed in handle plus some additional information about the load operation used to 
            load the addressable asset.
            <para>
            When chunks associated with a World Cell need to be unloaded, you must be able to produce or access the correct key for the 
            chunk stored on the World Cell. Note, however, that if your Chunk Manager uses pooling, or 
            has chunk reuse enabled, the chunk stored in the World Cell may have been originally loaded for a different World Cell. Therefore, 
            it is imperative to use a key that is associated with the chunks themselves rather than World Cell. If using a chunk that 
            derives from UnityEngine.Object, you can use the GetInstanceID to get a unique int that can be used as the key.
            </para>
            <para>
            If CanReuseAddressables returns true, you do not need to override this method.
            </para>
            </summary>
            <param name="handle" type="AsyncOperationHandle">The handle that the key needs to be generated for.</param>
            <returns type="int">A unique key associated with the handle or the chunk loaded by the handle.</returns>
            <displayName id="AddressableStreamerBaseUser.GetNonReusableAssetKey">
            AddressableStreamerBaseUser.GetNonReusableAssetKey(AsyncOperationHandle)
            </displayName>
            <syntax>
            public virtual int GetNonReusableAssetKey(AsyncOperationHandle handle)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.LoadNewAssetAsyncUsingLocation(DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.IResourceLocation)">
            <summary>
            Should be able to return an AsyncOperationHandle for loading an addressable asset by its IResourceLocation. If you have 
            setup your chunk streamer to NOT use IResourceLocations at all, then you can throw an exception in the method body if you want.
            </summary>
            <param name="location" type="IResourceLocation">The IResourceLocation of the asset.</param>
            <returns type="AsyncOperationHandle">An AsyncOperationHandle for the load.</returns>
            <displayName id="AddressableStreamerBaseUser.LoadNewAssetAsyncUsingLocation">
            AddressableStreamerBaseUser.LoadNewAssetAsyncUsingLocation(IResourceLocation)
            </displayName>
            <syntax>
            public abstract AsyncOperationHandle LoadNewAssetAsyncUsingLocation(IResourceLocation location)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.LoadNewAssetAsyncUsingKey(System.String)">
            <summary>
            Should be able to return an AsyncOperationHandle for loading an addressable asset by a key. If you have 
            setup your chunk streamer to NOT use keys at all, then you can throw an exception in the method body if you want.
            </summary>
            <param name="key" type="string">The key to use to load the asset.</param>
            <returns type="AsyncOperationHandle">An AsyncOperationHandle for the load.</returns>
            <displayName id="AddressableStreamerBaseUser.LoadNewAssetAsyncUsingKey">
            AddressableStreamerBaseUser.LoadNewAssetAsyncUsingKey(string)
            </displayName>
            <syntax>
            public abstract AsyncOperationHandle LoadNewAssetAsyncUsingKey(string key)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AddressableStreamerBaseUser.SetupChunkFromLoadHandle(DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ReadyOp,DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.AsyncOperationHandle,DeepSpaceLabs.SAM.ChunksPositioned)">
            <summary>
            Should get (from the AsyncOperationHandle) and setup the asset chunk that will be attached to the World Cell. Once the asset is returned it is simply 
            attached to the World Cell; no other processing is done with it, so you must ensure the asset is configured exactly 
            as you want. For instance, for Game Objects, you should set the name of the object to readyOp.LoadedAsyncOpInfo.ChunkName.
            </summary>
            <param name="readyOp" type="ReadOp">Contains some information about the chunk asset, such as its name.</param>
            <param name="handle" type="AsyncOperationHandle">The handle used to load the asset, which should contain a reference to the asset. 
            Note that typically, this asset is not suitable to be attached to the World Cell. You will likely need to cast the handle to 
            the correct type using handle.Convert, then retrieve or instantitate the actual object that will be attached to the 
            World Cell (for example, prefab streamers load a GameObject resource, but this resource doesn't actually exist in the scene, 
            so a different GameObject must be instantiated from the resource.
            </param>
            <param name="chunksPositioned" type="ChunksPositioned" link="ChunksPositioned.html">Set to whether you have positioned the chunks or not (if you are not sure, set to Maybe).</param>
            <returns type="object">The chunk object to attach to the World Cell</returns>
            <displayName id="AddressableStreamerBaseUser.SetupChunkFromLoadHandle">
            AddressableStreamerBaseUser.SetupChunkFromLoadHandle(ReadyOp, AsyncOperationHandle, out ChunksPositioned)
            </displayName>
            <syntax>
            public abstract object SetupChunkFromLoadHandle(ReadyOp readyOp, AsyncOperationHandle handle, out ChunksPositioned chunksPositioned)
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.LoadedAsyncOperationInfo.Handle">
            <summary>
            Gets the handle associated with the operation.
            </summary>
            <type>AsyncOperationHandle</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.LoadedAsyncOperationInfo.ChunkName">
            <summary>
            Gets the name of the Asset Chunk associated with this loaded async operation.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.LoadedAsyncOperationInfo.HasUsers">
            <summary>
            Gets a value indicating whether the loaded async operation has users.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ReadyOp.Cell">
            <summary>
            Gets the World Cell associated with the operation, which is the World Cell that requested the Addressable Asset in the first place.
            </summary>
            <type link="WorldCell.html">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ReadyOp.LoadedAsyncOpInfo">
            <summary>
            Gets the information about the load operation.
            </summary>
            <type>LoadedAsyncOperationInfo</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableBaseChunkStreamerInfo.ReadyOp.ChunkIndex">
            <summary>
            Gets the chunk index of the Asset Chunk that was loaded.
            </summary>
            <type>int</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo">
            <summary>
            An implementation of AddressableBaseChunkStreamer that is able to stream in Addressable Prefabs. You cannot override this class, however you can 
            consult this page as a reference if implementing your own custom addressable chunk streamer.
            </summary>
            <title>
            AddressablePrefabChunkStreamer Class
            </title>
            <category>Chunk Streamers</category>
            <navigationName>
            AddressablePrefabChunkStreamer
            </navigationName>
            <fileName>AddressablePrefabChunkStreamer.html</fileName>
            <syntax>
            public sealed class AddressablePrefabChunkStreamer : <see href="AddressableBaseChunkStreamer.html">AddressableBaseChunkStreamer</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.ChunkDestroyer">
            <summary>
            Gets the Chunk Destroyer associated with this component.
            <para>
            By default, when DetachAndUnloadChunksFromCells is called, the streamer calls GameObject.Destroy for each chunk/cell object that needs to be 
            removed from the scene, decrements the count of loaded instances for the addressable associated with the chunk/cell object, and then Releases 
            the addressable handle which should free memory.
            </para>
            <para>
            If your chunk/cell object has many children, you may wish to use a custom Chunk Destroyer in order to destroy the children across several 
            frames to avoid FPS spikes.
            </para>
            <para>
            Do keep in mind, unlike other Chunk Streamers that make use of the Chunk Destroyer class, this streamer will use the destroyers DestroyChunk method 
            rather than its DestroyChunksOnCells method. The reason for doing so is that after destroying each chunk/cell object, the count of loaded instances 
            for the addressable associated with the chunk/cell object needs to be decremented, so that its handle can be released when the count reaches 0.
            </para>
            </summary>
            <type link="ChunkDestroyer.html">ChunkDestroyer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.MemoryFreeingStrategy">
            <summary>
            The strategy for freeing memory. If you create a custom class deriving from Chunk Manager, 
            you can choose to ignore the strategy or enforce it. Memory freeing 
            is simply calling Resources.UnloadUnusedAssets (which can be used like any other coroutine!)
            </summary>
            <type link="MemoryFreeingStrategy.html">MemoryFreeingStrategy</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            Because Instantiated prefabs do not need a frame to "process", pre-loading is not required, and so this
            property is overridden to return false.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.FileExtension">
            <summary>
            File extension that is appended to addresses.
            </summary>
            <type>string</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.AwakeExtended2">
            <summary>
            Awake related logic is contained within this method.
            </summary>
            <displayName id="AwakeExtended2">
            AwakeExtended2()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended2()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.StartExtended">
            <summary>
            Start related logic is contained within this method.
            </summary>
            <displayName id="StartExtended">
            StartExtended()
            </displayName>
            <syntax>
            protected sealed override void StartExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.OnDestroyExtended">
            <summary>
            OnDestroy related logic is contained within this method.
            </summary>
            <displayName id="OnDestroyExtended">
            OnDestroyExtended()
            </displayName>
            <syntax>
            protected sealed override void OnDestroyExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.CreateAddressableLoaderUser(DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Creates a new AddressablePrefabLoaderUser object, which implements behaviour needed to load prefab addressable assets.
            </summary>
            <param name="LODGroup" type="IZoneGrouping" link="IZoneGrouping.html">
            The lod group being registered.
            </param>
            <returns type="AddressableStreamerBaseUser">A new AddressablePrefabLoaderUser user object created using the LODGroup as input.</returns>
            <displayName id="CreateAddressableLoaderUser">
            CreateAddressableLoaderUser(LODGroup)
            </displayName>
            <syntax>
            protected sealed override AddressableStreamerBaseUser CreateAddressableLoaderUser(IZoneGrouping LODGroup)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.LoadAndAttachChunksToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Instantiates and attaches all cell chunks to the input cells in a single frame. This is not very performant and so should only
            be used in Awake or Start, and generally only for testing purposes. Also note that since the AddressableErrorRepairer only works on a 
            multi frame basis, it will no the called, and the streamer will automatically try to load the backup assets if any assets fail to load.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose chunks need to be attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "LoadAndAttachChunksToCellsInSingleFrame">LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public sealed override void LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressablePrefabChunkStreamerInfo.DetachAndUnloadChunksFromCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Detaches and unloads the chunks associated with the input world cells over a period of frames using the associated 
            ChunkDestroyer, or GameObject.Destroy if no destroyer is present.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells whose objects need to be detached and unloaded.
            </param>
            <param name="userID" type = "int">
            The ID of the user requesting the unload and detachment.
            </param>
            <displayName id = "DetachAndUnloadChunksFromCells">
            DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo">
            <summary>
            An implementation of AddressableBaseChunkStreamer that is able to stream in Addressable Scenes. You cannot override this class, however you can 
            consult this page as a reference if implementing your own custom addressable chunk streamer.
            </summary>
            <title>
            AddressableSceneChunkStreamer Class
            </title>
            <category>Chunk Streamers</category>
            <navigationName>
            AddressableSceneChunkStreamer
            </navigationName>
            <fileName>AddressableSceneChunkStreamer.html</fileName>
            <syntax>
            public sealed class AddressableSceneChunkStreamer : <see href="AddressableBaseChunkStreamer.html">AddressableBaseChunkStreamer</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            This property, along with the LoadAndAttachChunksToCellsInSingleFrame method, 
            will throw an InvalidOperationException if queried, so don't! The Addressable System is unable to load scenes 
            in a synchronous manner, therefore use of 'Initialize on Awake' (via the Component Manager) is not allowed, as that will 
            query this Property as well as call the LoadAndAttachChunksToCellsInSingleFrame method. Instead, disable 'Initialize on Awake' and 
            call the InitializeGradually method of the Component Manager manually.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.FileExtension">
            <summary>
            Returns .unity which is the file extension for scenes.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.InvalidSceneFormatMessageLevel">
            <summary>
            Gets or sets the InvalidSceneFormatMessageLevel used by this Async Scene Loader.
            </summary>
            <type link="InvalidSceneFormatMessageLevel.html">InvalidSceneFormatMessageLevel</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.AwakeExtended2">
            <summary>
            Awake related logic.
            </summary>
            <displayName id="AwakeExtended2">
            AwakeExtended2()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended2()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.OnDestroyExtended">
            <summary>
            OnDestroy related logic.
            </summary>
            <displayName id="OnDestroyExtended">
            OnDestroyExtended()
            </displayName>
            <syntax>
            protected sealed override void OnDestroyExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.CreateAddressableLoaderUser(DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Creates a new AddressableSceneLoaderUser object, which implements behaviour needed to load scene addressable assets.
            </summary>
            <param name="LODGroup" type="IZoneGrouping" link="IZoneGrouping.html">
            The lod group being registered.
            </param>
            <returns type="AddressableStreamerBaseUser">
            A new AddressablePrefabLoaderUser user object created using the LODGroup as input.
            </returns>
            <displayName id="CreateAddressableLoaderUser">
            CreateAddressableLoaderUser(IZoneGrouping)
            </displayName>
            <syntax>
            protected sealed override AddressableStreamerBaseUser CreateAddressableLoaderUser(IZoneGrouping LODGroup)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.LoadAndAttachChunksToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            This method, along with the IsSingleFrameAttachmentPreloadRequired property, 
            will throw an InvalidOperationException if called, so don't! The Addressable System is unable to load scenes 
            in a synchronous manner, therefore use of 'Initialize on Awake' (via the Component Manager) is not allowed, as that will 
            call this method as well as query the IsSingleFrameAttachmentPreloadRequired property. Instead, disable 'Initialize on Awake' and 
            call the InitializeGradually method of the Component Manager manually.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells to load and attach</param>
            <param name="userID" type = "int">The ID assigned to the user of this chunk streamer at the time of registration.</param>
            <returns type="null">
            Nothing, as it will throw an exception.
            </returns>
            <displayName id="LoadAndAttachChunksToCellsInSingleFrame">
            LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public sealed override void LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AddressableSceneChunkStreamerInfo.DetachAndUnloadChunksFromCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Detaches and unloads the chunks associated with the input world cells over a period of frames using the associated 
            ChunkDestroyer, or GameObject.Destroy if no destroyer is present.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells whose objects need to be detached and unloaded.
            </param>
            <param name="userID" type = "int">
            The ID of the user requesting the unload and detachment.
            </param>
            <displayName id = "DetachAndUnloadCellChunksFromCells">
            DetachAndUnloadCellChunksFromCells(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndUnloadCellChunksFromCells(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AssetCreator">
            <summary>
            Base abstract class for Asset Creators. The main intention behind the Asset Creator is to allow you to add 
            new chunk/chunk assets to your project while using the World Designer tool. Whenever the tool needs a new chunk/chunk asset 
            for a cell, it request the Asset Creator assigned to the current World Grouping being edited to create the asset.
            <para>
            Note this is an abstract class and has no implementation. You must either use the Default Asset Creator or create 
            an asset creator yourself that implements some logic that creates the asset. Typically each Asset Creator is associated with a specific 
            folder where the assets are created, and you should create different Asset Creators assets in order to handle the creation of assets that need 
            to be stored in differentn folders. The caveat to that is if you are creating multiple assets per call of Create Asset.
            </para>
            <para>
            For instance, the Default Asset Creator is capable of creating a prefab asset and a scene asset for each call of Create Asset, and each 
            may be stored in separate folders using a single Asset Creator asset.
            </para>
            <para>
            The use of this class offers unlimited implemntation freedom. For instance, you could implement an Asset Creator that writes data about the 
            new asset to a file, rather than actually creating a new asset in the project.
            </para>
            <para>
            </para>
            </summary>
            <title>
            AssetCreator Class
            </title>
            <category>Scriptable Assets</category>
            <navigationName>
            AssetCreator
            </navigationName>
            <fileName>AssetCreator.html</fileName>
            <syntax>
            public abstract class AssetCreator : ScriptableObject
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AssetCreator.CanUseWithBatchAssetEditing(System.Int32)">
            <summary>
            Override to return a value indicating whether the Asset Creator can be used with batch asset editing for the given LOD. Batch asset editing utilizes 
            AssetDatabase.StartAssetEditing and AssetDatabase.StopAssetEditing before and after a batch of CreateAssetsForCellChunk calls for a given LOD. This speeds up 
            editor performance, however introduces some limitations, namely that assets created via the AssetCreator are not immediately available (they 
            only become available after the last CreateAssetsForCellChunk in the batch is called and StopAssetEditing is called).
            <para>
            The Default Asset Creator can always be used with batch editing.
            </para>
            <para>
            If batch editing can be used, it is always used, regardless of the number of asset chunks that need assets created.
            </para>
            </summary>
            <param name="LOD" type="int">
            The LOD that the next batch of CreateAssetsForCellChunk calls will be used for. Batches are always guarnateed to make use of the same LOD.
            </param>
            <returns type="bool">
            Return true in your override if the Asset Creator can be used with batch editing for the given LOD. If not, return false.
            </returns>
            <displayName id="CanUseWithBatchAssetEditing">
            CanUseWithBatchAssetEditing(int)
            </displayName>
            <syntax>
            public abstract bool CanUseWithBatchAssetEditing(int LOD)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AssetCreator.StartingBatchEditing">
            <summary>
            If you override CanUseWithBatchAssetEditing to return true for at least one LOD, this method will be called when creating asset chunks for that LOD.
            <para>
            Overriding it is optional, however typically there will be some setup required when performing batch editing.
            </para>
            <para>
            For example, the default asset creator (when not using a prefab template with a terrain) can be used with batch editing. 
            </para>
            <para>
            When batch editing is used, newly generated scenes are not added to the build settings immediately. 
            Instead, they are added to an internal list and once the batch editing is finished, 
            they are added to the Build Settings (when BatchEditingStopped is called).
            </para>
            <para>
            This method is used to store the current Editor Building Setting scenes (before the new ones are added).
            </para>
            </summary>
            <displayName id="StartingBatchEditing">
            StartingBatchEditing()
            </displayName>
            <syntax>
            public virtual void StartingBatchEditing()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AssetCreator.BatchEditingStopped">
            <summary>
            This method is called just after batch editing ends (<b>however, it is only called when CanUseWithBatchAssetEditing returns true for an LOD</b>).
            <para>
            You can override it to implement logic to perform cleanup and to execute pending actions for the batch Asset Creation calls.
            </para>
            <para>
            For example, 
            the default asset creator (when not using a prefab template with a terrain) can be used with batch editing. 
            When batch editing is used, newly generated scenes are not added to the build settings immediately. 
            Instead, they are added to an internal list and once the batch editing is finished and this method is called,
            they are added to the Build Settings.
            </para>
            </summary>
            <displayName id="BatchEditingStopped">
            BatchEditingStopped()
            </displayName>
            <syntax>
            public virtual void BatchEditingStopped()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AssetCreator.CreateAssetsForCellChunk(DeepSpaceLabs.SAM.ChunkInfo)">
            <summary>
            Abstract CreateAssetsForCellChunk Method. The expectation is that you will create at least one asset when this method is called, however 
            in reality you can choose to create multiple assets (of different types; for instance a prefab asset and a scene asset), or you can 
            just store information in a file rather than creating a new asset.
            </summary>
            <param name="chunkInfo" type="ChunkInfo" link="ChunkInfo.html">
            Info related to the chunk that the assets are needed for. 
            <para>
            Note that while the Asset Creator needs to create Assets that can be loaded via a specific Chunk Streamer (for instance, the Default 
            Asset Creator creates prefabs that should be loadable by a Prefab Chunk Streamer), no details from the Chunk Streamer are passed 
            to the Asset Creator.
            </para>
            <para>
            As such, you must explicitly design your Asset Creator such that instances of it can be created and configured to output Asset Chunks for 
            a specific LOD Group that can be loaded at runtime using the Chunk Streamer associated with that LOD Group.
            </para>
            <para>
            For example, when using a Prefab Chunk Streamer, the streamer reads the sub folder path where a LOD Group's Asset Chunks are stored (within 
            a folder called Resources), by accessing Extra Data for the LOD Group via the Streamable Grid. If the Assets are not in the folder, they cannot be loaded.
            </para>
            <para>
            The Asset Creator does not have access to this Extra Data from the Streamable Grid, however you can (and should) manually configure it (via a string field 
            and custom code) to output the Assets to the folder that the Prefab Chunk Streamer expects to find them in.
            </para>
            </param>
            <displayName>
            CreateAssetsForCellChunk(ChunkInfo)
            </displayName>
            <syntax>
            public abstract void CreateAssetsForCellChunk(ChunkInfo chunkInfo)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkInfo">
            <summary>
            A class for storing information about an Asset Chunk, which is passed to 
            <see cref="T:DeepSpaceLabs.SAM.AssetCreator" href="AssetCreator.html">Asset Creators</see> in order to create the Asset Chunks.
            <para>
            </para>
            </summary>
            <title>
            ChunkInfo Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>
            ChunkInfo
            </navigationName>
            <fileName>ChunkInfo.html</fileName>
            <syntax>
            public class ChunkInfo
            </syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkInfo.chunkName">
            <summary>
            The name of the asset chunk to create.
            </summary>
            <type>string</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkInfo.streamableGridCellOfChunk">
            <summary>
            he Streamable Grid Cell the chunk is a part of.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkInfo.chunkNumber">
            <summary>
            The index of the chunk in reference to the World Cell it belongs to. Will always be 1 if the World Cell is not using multi-chunking.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkInfo.LOD">
            <summary>
            The LOD of the Asset Chunk.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkInfo.chunkPosition">
            <summary>
            The position of the chunk at the time of creation.
            <para>
            You can decide whether to use this value or not. Generally speaking, it does not hurt to use the value. To convert the 
            value to a Vector3, do: Vector3 pos = (Vector3)chunkPosition;
            </para>
            <type link="Vector3Double.html">Vector3Double</type>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkInfo.isTestChunk">
            <summary>
            Whether the chunk is a test chunk. The World Designer Tool periodically creates test chunks to ensure the 
            Asset Creator has been configured correctly to work with whatever Chunk Streamer/Asset Manager is set to be used with the chunks.
            <para>
            If the chunk is a test chunk and you are creating multiple different kinds of assets for your chunk, it is generally 
            a good idea to only create assets for the test chunk that can be detected and used by the Asset Manager that will handle the 
            chunk. If you do not follow this rule, the Asset Manager will not be able to remove the secondary assets which will result in 
            assets being "left behind" in your project.
            </para>
            <para>
            For instance, when using the Default Asset Creator and creating both scenes and prefabs, you need to define which type of asset 
            is the primary asset. When creating a test asset chunk, the Creator will only create the primary asset.
            </para>
            <type>bool</type>
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkInfo.#ctor(System.String,DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,DeepSpaceLabs.SAM.Vector3Double,System.Boolean)">
            <summary>
            Creates a new instance of the ChunkInfo struct.
            </summary>
            <param name="chunkName" type="string">
            The name of the asset chunk to create.
            </param>
            <param name="streamableGridCellOfChunk" type="Cell" link="Cell.html">
            The Streamable Grid Cell the chunk is a part of.
            </param>
            <param name="chunkNumber" type="int">
            The name of the asset chunk to create.
            </param>
            <param name="LOD" type="int">
            The index of the chunk in reference to the World Cell it belongs to. Will always be 1 if the World Cell is not using multi-chunking.
            </param>
            <param name="chunkPosition" type="Vector3Double" link="Vector3Double.html">
            The position of the chunk at the time of creation.
            <para>
            You can decide whether to use this value or not. Generally speaking, it does not hurt to use the value. To convert the 
            value to a Vector3, do: Vector3 pos = (Vector3)chunkPosition;
            </para>
            </param>
            <param name="isTestChunk" type="bool">
            Whether the chunk is a test chunk. The World Designer Tool periodically creates test chunks to ensure the 
            Asset Creator has been configured correctly to work with whatever Chunk Streamer/Asset Manager is set to be used with the chunks.
            <para>
            If the chunk is a test chunk and you are creating multiple different kinds of assets for your chunk, it is generally 
            a good idea to only create assets for the test chunk that can be detected and used by the Asset Manager that will handle the 
            chunk. If you do not follow this rule, the Asset Manager will not be able to remove the secondary assets which will result in 
            assets being "left behind" in your project.
            </para>
            <para>
            For instance, when using the Default Asset Creator and creating both scenes and prefabs, you need to define which type of asset 
            is the primary asset. When creating a test asset chunk, the Creator will only create the primary asset.
            </para>
            </param>
            <displayName id="ChunkInfo">
            ChunkInfo(string, Cell, int, int, Vector3, [bool])
            </displayName>
            <syntax>
            public ChunkInfo(string chunkName, Cell streamableGridCellOfChunk, int chunkNumber, int LOD, Vector3Double chunkPosition, bool isTestChunk = false)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AssignmentSelector">
            <summary>
            A Scriptable Object class you can derive from to create custom logic for choosing 
            what objects are selected for assignment operations.
            <para>
            The selection process works like so:
            </para>
            <para>
            When an Assignment Parent is provided, the World Designer conducts a top down search of the hierarchy of each first level 
            child of the parent. For each child, the child's Transform component is passed to the IsMatch method. If 
            the method returns a value of true, the search stops for that specific child's hierarchy and the next sibling 
            is searched. If it returns false, the search continues drilling down into that child's hierarchy until a match 
            is found or no more children exist. After drilling all the way down or finding a match, the search moves 
            back up one level and searches all siblings of the last parent transform that was searched. This 
            strategy ensures that descendants of a selected object cannot also be selected, which would be problematic if allowed.
            </para>
            <para>
            When no Assignment Parent is provided, the top down search begins with all root level game objects 
            in all loaded scenes and searches each of their hierarchies. Since this could potentially be a TON 
            of objects, care should be taken when using this option. We recommend starting with an Assignment 
            Parent and proceeding with no Assignment Parent only if the operation with the Assignment Parent 
            did not encounter any problems.
            </para>
            </summary>
            <title>AssignmentSelector Class</title>
            <category>Scriptable Assets</category>
            <navigationName>AssignmentSelector</navigationName>
            <fileName>AssignmentSelector.html</fileName>
            <syntax>
            public abstract class AssignmentSelector : ScriptableObject
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AssignmentSelector.OnAssignmentStarting(DeepSpaceLabs.SAM.World,System.Int32,System.Int32)">
            <summary>
            Called before an Assignment Operation has begun. This can be overriden to perform setup/configuration, for instance 
            your IsMatch method should return true only if the input transform's game object has a specific tag, you can 
            use this to set the tag to use in the comparison, based on the World, groupingIndex, and/or LOD values.
            </summary>
            <param name="world" type="World" link="World.html">
            The World that the current Assignment Operation is assigning objects to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping that the current Assignment Operation is assigning objects to.
            </param>
            <param name="LOD" type="int">
            The index of the LOD Group that the current Assignment Operation is assigning objects to.
            </param>
            <displayName id="OnAssignmentStarting">
            OnAssignmentStarting(World, int, int)
            </displayName>
            <syntax>
            public virtual void OnAssignmentStarting(World world, int groupingIndex, int LOD)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.AssignmentSelector.IsMatch(UnityEngine.Transform)">
            <summary>
            Checks whether the game object associated with the input transform should be included in the current Assignment Operation.
            </summary>
            <param name="transform" type="Transform">
            The transform associated with the game object that you should check.
            </param>
            <returns type="type">
            Return true if the game object is a match (meaning it should be included in the selection of objects 
            which will be assigned), or false otherwise.
            </returns>
            <displayName id="IsMatch">
            IsMatch(Transform)
            </displayName>
            <syntax>
            public abstract bool IsMatch(Transform transform)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.FixedUpdatePlayerMover">
            <summary>
            A simple Player Mover that works by queing up any calls to MovePlayerByAmount or MovePlayerToPosition 
            and then executing the position changes on the next FixedUpdate call (unless the call is maded from FixedUpdate, in which 
            case the position change is performed immediately). Use this if your player absolutely has to be 
            moved in FixedUpdate!
            </summary>
            <title>
            FixedUpdatePlayerMover Class
            </title>
            <category>Player Movers</category>
            <navigationName>
            FixedUpdatePlayerMover
            </navigationName>
            <fileName>FixedUpdatePlayerMover.html</fileName>
            <syntax>
            public sealed class FixedUpdatePlayerMover : <see cref="T:DeepSpaceLabs.SAM.PlayerMover" href="PlayerMover.html">PlayerMover</see>
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.GlobalRuntimeSettings">
            <summary>
            A Scriptable Object class used to store runtime global settings that are used by various SAM components.
            <para>
            </para>
            </summary>
            <title>
            GlobalRuntimeSettings Class
            </title>
            <category>Scriptable Assets</category>
            <navigationName>GlobalRuntimeSettings</navigationName>
            <fileName>GlobalRuntimeSettings.html</fileName>
            <syntax>public class GlobalRuntimeSettings : ScriptableObject</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GlobalRuntimeSettings.LoadPriority">
            <summary>
            Returns a value indicating the value that Application.backgroundLoadingPriority should be set to 
            when SetLoadPriority returns true.
            </summary>
            <type>ThreadPriority</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GlobalRuntimeSettings.SetLoadPriority">
            <summary>
            Returns a value indicating whether the first Chunk Streamer that runs in the scene should set the 
            Application.backgroundLoadingPriority property (this controls how long it takes to load 
            data asynchronously vs performance impact on the game while loading in the background).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GlobalRuntimeSettings.SortingMethod">
            <summary>
            Returns a value indicating the Sorting Method that should be used to sort Build Setting 
            scenes (which is performed by Scene Chunk Streamers).
            </summary>
            <type link="SortingMethod.html">SortingMethod</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GlobalRuntimeSettings.SortScenesOnFirstLoad">
            <summary>
            Returns a value indicating whether Build Setting scenes should be sorted on first load (within the 
            Awake method of the first Scene Chunk Streamer that runs).
            <para>
            If false, the scenes will be sorted the first time an Asset Chunk needs to be loaded by any  
            Scene Chunk Streamer.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GlobalRuntimeSettings.TimeSortSpeed">
            <summary>
            Returns a value indicating whether the sorting of Build Setting scenes should be timed. This can be 
            useful for trying to determine which sorting method is fastest.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GlobalRuntimeSettings.GetGlobalRuntimeSettings">
            <summary>
            Can be used to retrieve the Global Runtime Settings asset. Using this method is preferred over 
            manually retrieving the asset from Resources because the instance will be cached for future calls.
            <para>
            This method will also create an instance of the settings if no Settings asset could be retrieved 
            from Resources.
            </para>
            </summary>
            <returns type="GlobalRuntimeSettings">
            The Global Runtime Settings asset, if found, or a default instance if one was not found in Resources.
            </returns>
            <displayName id="GetGlobalRuntimeSettings">
            GetGlobalRuntimeSettings()
            </displayName>
            <syntax>
            public static GlobalRuntimeSettings GetGlobalRuntimeSettings()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LightBakeData">
            <summary>
            When performing light baking using the Automated Unity Light Baker (via the World Designer Tool), this component is added to Asset Chunks that 
            use a Light Probe Group component. It stores data about where the Cell the Asset Chunks belong to was positioned at the time of the bake.
            <para>
            On Unity 2023.2 and greater, this data is used to calculate the offset of the Cells from their original baked position, which is then used to 
            correctly position those Cells' Light Probes.
            </para>
            <para>
            This component is added for all versions of Unity, even though the ability to position Light Probes at runtime is only available in Unity 2023.2 and 
            greater versions. This enables this functionality to work (without having to re-bake) on prior versions in the event that Unity backports the 
            runtime Light Probe additions, and it also allows you to upgrade your project to Unity 2023.2 or greater and have runtime light probe 
            changing "just work", without needing to re-bake your lighting.
            </para>
            </summary>
            <title>LightBakeData Class</title>
            <category>Secondary Components</category>
            <navigationName>LightBakeData</navigationName>
            <fileName>LightBakeData.html</fileName>
            <syntax>
            public class LightBakeData : MonoBehaviour
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LightBakeData.BakePosition">
            <summary>
            Gets the position of this Asset Chunk's Cell at the time it was baked.
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LightProbeManager">
            <summary>
            [BETA ONLY]A special World Grouping Listener that can be added to World Grouping's that use Light 
            Probes in order force Tetrahedralization of Light Probes whenever Cells are added or 
            removed from the Groupings.
            <para>
            In Unity 2023.2 and greater, this Manager also control the repositioning of Light Probes to enable Light Probe support on 
            Floating Origin based Worlds and/or Endless Worlds.
            </para>
            <para>
            Each World Grouping that contains Light Probes should use a seperate LightProbeManager, however note that in general, only a single 
            World Grouping should contain Light Probes. Using multiple Groupings with Light Probes will be less efficient, as tetrahedralization 
            cannot be timed as precicely and may be called more often then strictly needed.
            </para>
            </summary>
            <title>
            LightProbeManager Class
            </title>
            <category>World Grouping Listeners</category>
            <navigationName>
            LightProbeManager
            </navigationName>
            <fileName>LightProbeManager.html</fileName>
            <syntax>
            public sealed class LightProbeManager : <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LightProbeManager.IgnoreLODTransitions">
            <summary>
            Overriden to return false.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LightProbeManager.YieldBehaviorAfterMethodExecution">
            <summary>
            Overriden to return ListenerYieldBehavior.YieldOrContinue
            </summary>
            <type link="ListenerYieldBehavior.html">ListenerYieldBehavior</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LightProbeManager.OnBeforeCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is used to detect the addition of Asset Chunks that were baked with light probe data. We use 
            OnBeforeCellsInBatchActivated because this method is called before the Asset Chunks are added to 
            the Hierarchy Organizer, which means the Asset Chunks should still be associated with their original scene, assuming 
            Keep Scenes Intact has been configured correctly.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsActivated">
            OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public override IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LightProbeManager.OnAfterCellsInBatchDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is to detect the removal of Asset Chunks containing Light Probe Groups. When these Asset Chunks are being removed, information about 
            the chunk is tracked in order to match it to the appropriate scene when the scene is unloaded. This allows us to remove the 
            light probes object before the scene is completely unloaded, which solves a bug that is currently in Unity.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsDeactivated">
            OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public override IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LODCrossFadeTransitioner">
            <summary>
            A custom implementation of a 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            that is no longer used. The same functionality can be achieved by using a MatPropBlockTransitioner or PerMaterialTransitioner 
            with its 'Use Unity Crossfade' setting enabled.
            </summary>
            <title>LODCrossFadeTransitioner Class</title>
            <category>Deprecated Components</category>
            <navigationName>LODCrossFadeTransitioner</navigationName>
            <fileName>LODCrossFadeTransitioner.html</fileName>
            <syntax>public sealed class LODCrossFadeTransitioner : <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">CellVisualTransitionController</see></syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCrossFadeTransitioner.CanWorldCellsBeTransitioned(DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Returns false and prints an error to the console.
            </summary>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type you want to find out whether is able to be transitioned.
            </param>
            <returns type="bool">
            Always returns true if the Chunk Type is Non_Terrain_Game_Object. Also returns true if the Chunk Type is Unity_Terrain and 
            Allow Use With Terrain is enabled in the inspector. Otherwise returns false.
            </returns>
            <displayName id="CanWorldCellsBeTransitioned">
            CanWorldCellsBeTransitioned(ChunkType)
            </displayName>
            <syntax>
            public sealed override bool CanWorldCellsBeTransitioned(ChunkType ChunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCrossFadeTransitioner.ResetToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            No longer used.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            </param>
            <displayName id="ResetToVisibleState">
            ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCrossFadeTransitioner.ResetToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            No longer used.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the invisible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            </param>
            <displayName id="ResetToInvisibleState">
            ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells,  ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCrossFadeTransitioner.ImmediatelyTransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            No longer used.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="ImmediatelyTransitionToVisibleState">
            ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override void ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCrossFadeTransitioner.TransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            No longer used.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to an "activated" state. "Activated" in this sense just means the chunks should be made visible to the 
            player (assuming the cell is not being culled by your culling system [if present]). All cells are part of the same World Grouping and LOD.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToVisibleState">
            TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCrossFadeTransitioner.TransitionToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            No longer used.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to a "deactivated" state. "Deactivated" in this sense just means the chunks should be made invisible to the 
            player (assuming the cell is not being culled by your culling system [if present]). All cells are part of the same World Grouping and LOD.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToInvisibleState">
            TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCrossFadeTransitioner.TransitionBetweenLevelsOfDetail(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType,DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            No longer used.
            </summary>
            <param name="transitionFrom" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned from 
            (i.e., they are what is currently activated that we want to deactivate). 
            This list is read only and may contain cells from different LODs.
            </param>
            <param name="transitionFromCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionFrom World Cells.
            </param>
            <param name="transitionTo" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned to 
            (i.e., they are what is currently deactivated that we want to activate). 
            This list is read only and all cells are from the same World Grouping and LOD.
            </param>
            <param name="transitionToCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionTo World Cells.
            </param>
            <displayName id="TransitionBetweenLevelsOfDetail">
            TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt;, ChunkType, ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt; transitionFrom, ChunkType transitionFromCellsChunkType, ReadOnlyList&lt;WorldCell&gt; transitionTo, ChunkType transitionToCellsChunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PerMaterialTransitioner">
            <summary>
            A custom implementation of a 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see>. 
            Please take a look at that page before continuing, as it provides an overview of what this class is responsible for.
            <para>
            This particular transition controller requires either a shader compatible with Unity's built-in LODGroup component, or 
            a custom shader that makes use of a float. In either case, the shader should usually be compatible with the SRP batcher as well.
            </para>
            <para>
            It works by performing the transition over a fixed time period, 
            where the float in the shader (or built in lod crossfade vector value if using 'Use Unity Crossfade') 
            is set to a value between 0 (at start) and 1 (at end) for cells transitioning 
            to a "visible" state, and to a value between 1 (at start) and 0 (at end) 
            for cells transitioning to an "invisible" state. It is up to your shader to determine how this 
            float property is used, for instance by implementing true transparency or using alpha clipping (dithering).
            </para>
            <para>
            This transitioner will perform a separate transition for every child, grandchild, etc. of each root chunk, 
            so long as that child contains a Renderer component. It also transitions every Material on each Renderer, so if that is not 
            your desired behaviour, you will need to create a custom Transitioner.
            </para>
            <para>
            There is a special optimization that is performed when a renderer is not in view of the camera, whereby the renderer is immediately 
            set to its final state (either visible or invisible). This results in only renderers in view of the player being transitioned, which speeds up 
            the transition process, which in turn speeds up the dyanmic loading process. The Renderer.IsVisible property is used to determine if 
            a renderer is visible to any cameras. Within the editor, the Scene View camera counts as a camera in this capacity, so if a game object visible in 
            your scene view but not in the game view, you will still notice it being transitioned.
            </para>
            <para>
            The difference between this component and the MatPropBlockTransitioner is very subtle.
            </para>
            <para>
            This one should generally only be used with the Scriptable Render Pipeline, in situations where you are using the same shader with many different meshes and want to use the SRP Batcher.
            </para>
            <para>
            If not using the SRP or you are using many instances of 
            the same mesh and material, you will probably be better off using the MatPropBlockTransitioner. 
            You can easily test with each transitioner to see which one is more performant.
            </para>
            <para>
            Note that if 'Use Shared Material' is disabled, static runtime batching (using the 
            <see cref="T:DeepSpaceLabs.SAM.StaticBatcherListener" href="StaticBatcherListener.html">StaticBatcherListener</see> or some other method) 
            cannot be used on the same Renderers that will be transitioned using this controller.
            </para>
            </summary>
            <title>PerMaterialTransitioner Abstract Class</title>
            <category>Visual Transition Controllers</category>
            <navigationName>PerMaterialTransitioner</navigationName>
            <fileName>PerMaterialTransitioner.html</fileName>
            <syntax>public sealed class PerMaterialTransitioner : <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">CellVisualTransitionController</see></syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.AwakeExtended">
            <summary>
            Override of AwakeExtended
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.CanWorldCellsBeTransitioned(DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Queries the Transitioner to determine if World Cell's using the Chunk Type specified can be transitioned at the 
            present time.
            </summary>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type you want to find out whether is able to be transitioned.
            </param>
            <returns type="type">
            Always returns true if the Chunk Type is Non_Terrain_Game_Object. Also returns true if the Chunk Type is Unity_Terrain and 
            Allow Use With Terrain is enabled in the inspector. Otherwise returns false.
            </returns>
            <displayName id="CanWorldCellsBeTransitioned">
            CanWorldCellsBeTransitioned(ChunkType)
            </displayName>
            <syntax>
            public sealed override bool CanWorldCellsBeTransitioned(ChunkType ChunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.ResetToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the ResetToVisibleState method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#ResetToVisibleState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            </param>
            <displayName id="ResetToVisibleState">
            ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.ResetToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the ResetToInvisibleState method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#ResetToInvisibleState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the invisible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            </param>
            <displayName id="ResetToInvisibleState">
            ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells,  ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.ImmediatelyTransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the ImmediatelyTransitionToActivatedState method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#ImmediatelyTransitionToActivatedState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="ImmediatelyTransitionToVisibleState">
            ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override void ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.TransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the TransitionToActivatedState method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#TransitionToActivatedState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method. If you are trying to understand how the Mat Prop Block 
            Transitioner works, please take a look at the class summary.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            TThe list of cells whose chunks need to be reset to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToVisibleState">
            TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.TransitionToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the TransitionToDeactivatedState method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#TransitionToDeactivatedState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method. If you are trying to understand how the Mat Prop Block 
            Transitioner works, please take a look at the class summary.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the invisible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToInvisibleState">
            TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PerMaterialTransitioner.TransitionBetweenLevelsOfDetail(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType,DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the TransitionBetweenLevelsOfDetail method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#TransitionBetweenLevelsOfDetail">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method. If you are trying to understand how the Mat Prop Block 
            Transitioner works, please take a look at the class summary.
            </summary>
            <param name="transitionFrom" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned from 
            (i.e., they are what is currently activated that we want to deactivate). 
            This list is read only and may contain cells from different LODs.
            </param>
            <param name="transitionFromCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionFrom World Cells.
            </param>
            <param name="transitionTo" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned to 
            (i.e., they are what is currently deactivated that we want to activate). 
            This list is read only and all cells are from the same World Grouping and LOD.
            </param>
            <param name="transitionToCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionTo World Cells.
            </param>
            <displayName id="TransitionBetweenLevelsOfDetail">
            TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt;, ChunkType, ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt; transitionFrom, ChunkType transitionFromCellsChunkType, ReadOnlyList&lt;WorldCell&gt; transitionTo, ChunkType transitionToCellsChunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.MaterialDestroyer">
            <summary>
            A simple class that can be added to game objects being transitioned using the 
            <see cref="T:DeepSpaceLabs.SAM.PerMaterialTransitioner" href="PerMaterialTransitioner.html">Per Material Transitioner</see>, which 
            destroys created Material instances when the game object is destroyed. This is needed because the Per Material Transitioner   
            accesses the Renderer's materials using GetMaterials, which creates instances of new materials the first time it is called. These 
            materials are not tracked by Unity and must be destroyed manually when the game object is destroyed.
            <para>
            Note that you cannot add this component yourself. It will be added automatically whenever 'Use Shared Materials' is disabled 
            and 'Add Material Destroyer' is enabled on any Per Material Transitioner you are using.
            </para>
            <para>
            Also note that this is just one strategy for destroying the Material. You can also destroy the materials manually or call 
            Resources.UnloadUnusedAssets. The later can be done manually or via whatever Chunk Streamer you are using, by enabling 
            'Unload Unused Assets' or setting the 'Memory Freeing Strategy' to something other than 'Dont Free Memory'.
            </para>
            </summary>
            <title>
            MaterialDestroyer Class
            </title>
            <category>
            Secondary Components
            </category>
            <navigationName>
            MaterialDestroyer
            </navigationName>
            <fileName>MaterialDestroyer.html</fileName>
            <syntax>
            public class MaterialDestroyer : MonoBehaviour
            </syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.MaterialDestroyer.rendererWithMaterials">
            <summary>
            The renderer with the materials to destroy. If null, GetComponentInChildren will be used to try and retrieve it.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PositionTransitioner">
            <summary>
            A Cell Visual Transition Controller that manipulates the position of transforms to carry out transitions.
            </summary>
            <title>PositionTransitioner Class</title>
            <category>Visual Transition Controllers</category>
            <navigationName>PositionTransitioner</navigationName>
            <fileName>PositionTransitioner.html</fileName>
            <syntax>
            public sealed class PositionTransitioner : <see cref="T:DeepSpaceLabs.SAM.TransformTransitioner" href="TransformTransitioner.html">TransformTransitioner</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PositionTransitioner.TransitionToVisible">
            <summary>
            Returns an Action that performs a non LOD transition of a transform from invisible to visible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PositionTransitioner.LODTransitionToVisible">
            <summary>
            Returns an Action that performs an LOD transition of a transform from invisible to visible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PositionTransitioner.TransitionToInvisible">
            <summary>
            Returns an Action that performs a non LOD transition of a transform from visible to invisible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PositionTransitioner.LODTransitionToInvisible">
            <summary>
            Returns an Action that performs an LOD transition of a transform from visible to invisible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PositionTransitioner.AwakeExtended">
            <summary>
            Used to create the TransitionToVisible and TransitionToInvisible actions.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PositionTransitioner.GetVectorData(UnityEngine.Transform)">
            <summary>
            Returns the position of the Transform.
            </summary>
            <param name="transform" type="Transform">
            The Transform to get the data from.
            </param>
            <returns type="Vector3">
            The position data.
            </returns>
            <displayName id="GetVectorData">
            GetVectorData(Transform)
            </displayName>
            <syntax>
            protected sealed override Vector3 GetVectorData(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PositionTransitioner.MakeTransformVisibleImmediately(UnityEngine.Transform)">
            <summary>
            Immediately transitions the transform to the visible state.
            </summary>
            <param name="transform" type="Transform">
            The Transform to transition.
            </param>
            <displayName id="MakeTransformVisibleImmediately">
            MakeTransformVisibleImmediately(Transform)
            </displayName>
            <syntax>
            protected sealed override void MakeTransformVisibleImmediately(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PositionTransitioner.MakeTransformInvisibleImmediately(UnityEngine.Transform)">
            <summary>
            Immediately transitions the transform to the invisible state.
            </summary>
            <param name="transform" type="Transform">
            The Transform to transition.
            </param>
            <displayName id="MakeTransformInvisibleImmediately">
            MakeTransformInvisibleImmediately(Transform)
            </displayName>
            <syntax>
            protected sealed override void MakeTransformInvisibleImmediately(Transform transform)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SAMInitializer">
            <summary>
            This component can be added to the scene and used to Initialize SAM, either immediately (over two frames) 
            or gradually over multiple frames (note, the component is added automatically when using the Default SAM Setup command).
            <para>
            The class has be configured in a generic way to update a slider value and text if you wish. To use these features, 
            add one of the built in <see cref="T:DeepSpaceLabs.SAM.SAMText" href="SAMText.html">SAMText</see> and/or 
            <see cref="T:DeepSpaceLabs.SAM.SAMSlider" href="SAMSlider.html">SAMSlider</see> components to their corresponding UI component, or 
            create and add a custom SAMText and/or SAMSlider to the scene. Then assign those components to the 
            appropriate fields via the inspector.
            </para>
            <para>
            The Initializer is also capable of activating and/or deactivating objects before and/or after the 
            Initialization occurs. Just add the objects to the appropriate lists.
            </para>
            <para>
            Initialization can be triggered via another script, by hooking into a button's On Click event, or through 
            whatever other means you have available to you.
            </para>
            </summary>
            <title>SAMInitializer Class</title>
            <category>Primary Components</category>
            <navigationName>SAMInitializer</navigationName>
            <fileName>SAMInitializer.html</fileName>
            <syntax>public class SAMInitializer : MonoBehaviour</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SAMInitializer.IsInitialized">
            <summary>
            Gets a value indicating whether SAM has been initialized.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SAMInitializer.InitializeSAM_Immediate">
            <summary>
            Initializes SAM immediately. This will call ComponentManager.Initialize, which will execute 
            over this frame and the following frame to initialize everything regarding SAM.
            </summary>
            <displayName id="InitializeSAM_Immediate">
            InitializeSAM_Immediate()
            </displayName>
            <syntax>
            public void InitializeSAM_Immediate()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SAMInitializer.InitializeSAM_Gradual">
            <summary>
            Initializes SAM gradually. This will call ComponentManager.InitializeGradually, which will execute 
            over multiple frames.
            <para>
            If you need to track when the Initialization completes, you have three options:
            </para>
            <para>
            1) Check the IsInitialized property and wait for it to return true.
            </para>
            <para>
            2) Subscribe to the ComponentManagerInitialized event on the scene's Component Manager before calling this method.
            </para>
            <para>
            3) Use the 
            <see cref="M:DeepSpaceLabs.SAM.SAMInitializer.InitializeSAM_GradualCoroutine" href="#InitializeSAM_GradualCoroutine">InitializeSAM_GradualCoroutine</see> 
            method instead, calling it like a coroutine.
            </para>
            </summary>
            <displayName id="InitializeSAM_Gradual">
            InitializeSAM_Gradual()
            </displayName>
            <syntax>
            public void InitializeSAM_Gradual()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SAMInitializer.SetProgress(System.Single)">
            <summary>
            Sets the progress used by the Progress Slider and Text (if neither 
            are assigned, this will do nothing).
            <para>
            Normally you would not need to call this method, as the SAMInitializer 
            automatically does so while the Component Manager is being initialized 
            gradually.
            </para>
            <para>
            However, if you have additional operations being run before and/or after 
            the Component Manager is initialized, and these operations also take time, 
            you may wish for their progress to be tracked by the Progress Slider and 
            Text.
            </para>
            <para>
            In these instances, you can call this method in order to update the 
            Slider and Text. When doing so, you must decide how much progress to 
            allocate for each operations runtime, including the Component Manager's 
            Gradual Initialization. You can define this allocation using the 
            Progress Start and Progress End settings. As the Component Manager's 
            Initialization Progress runs from 0f to 1f, the SAM Initializer will 
            lerp between Progress Start and Progress End and set the Progress Slider 
            and Text to the lerped value.
            </para>
            <para>
            If the Component Manager's initialization takes up the bulk of the 
            loading screen time, you should not need to call this method manually, 
            however you should make sure to set Progress Start to 0 and Progress End to 1.
            </para>
            </summary>
            <param name="progress" type="float">
            The overall progress, as a value between 0 and 1f, that the 
            SAM Initializer's Progress Slider and/or Text are tracking.
            </param>
            <displayName id="SetProgress">
            SetProgress(float)
            </displayName>
            <syntax>
            public void SetProgress(float progress)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SAMInitializer.InitializeSAM_GradualCoroutine">
            <summary>
            Initializes SAM gradually. This will call ComponentManager.InitializeGradually, which will execute 
            over multiple frames.
            <para>
            This method is similar to 
            <see cref="M:DeepSpaceLabs.SAM.SAMInitializer.InitializeSAM_Gradual" href="#InitializeSAM_Gradual">InitializeSAM_Gradual</see>, except that this method can be 
            used as a coroutine or otherwise iterated
            </para>
            </summary>
            <displayName id="InitializeSAM_GradualCoroutine">
            InitializeSAM_GradualCoroutine()
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; InitializeSAM_GradualCoroutine()
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the <see href="YieldInstruction.html">YieldInstruction</see> page for more info.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SAMSlider">
            <summary>
            This is a very simple MonoBehaviour class you can derive from to interface with the SAMInitializer component.
            <para>
            Interfacing with the SAMInitializer allows you to receive Initialization Progress updates, 
            where the value corresponds to the position of the slider (from 0 to 1).
            </para>
            </summary>
            <title>SAMSlider Class</title>
            <category>Secondary Components</category>
            <navigationName>SAMSlider</navigationName>
            <fileName>SAMSlider.html</fileName>
            <syntax>
            public abstract class SAMSlider : MonoBehaviour
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SAMSlider.SetSliderValue(System.Single)">
            <summary>
            When overriden, should update the slider value to the input value.
            </summary>
            <param name="value" type="float">
            The value to set.
            </param>
            <displayName id="SetSliderValue">
            SetSliderValue(float)
            </displayName>
            <syntax>
            public abstract void SetSliderValue(float value)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SAMText">
            <summary>
            This is a very simple MonoBehaviour class you can derive from to interface with the SAMInitializer component.
            <para>
            Interfacing with the SAMInitializer allows you to receive Initialization Progress text updates, where the text is the 
            initialization progress (usually a float) expressed as a string.
            </para>
            <para>
            The exact format of the string is controlled by the SAMInitializer, but will usually be in a format like XX.X%.
            </para>
            </summary>
            <title> SAMText Class</title>
            <category>Secondary Components</category>
            <navigationName>SAMText</navigationName>
            <fileName>SAMText.html</fileName>
            <syntax>
            public abstract class SAMText : MonoBehaviour
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SAMText.SetText(System.String)">
            <summary>
            When overriden, should set the text value to the input text.
            </summary>
            <param name="text" type="string">
            The text to set.
            </param>
            <displayName id="SetText">
            SetText(string)
            </displayName>
            <syntax>
            public abstract void SetText(string text)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ScaleTransitioner">
            <summary>
            A Cell Visual Transition Controller that manipulates the scale of transforms to carry out transitions.
            </summary>
            <title>ScaleTransitioner Class</title>
            <category>Visual Transition Controllers</category>
            <navigationName>ScaleTransitioner</navigationName>
            <fileName>ScaleTransitioner.html</fileName>
            <syntax>
            public sealed class ScaleTransitioner : <see cref="T:DeepSpaceLabs.SAM.TransformTransitioner" href="TransformTransitioner.html">TransformTransitioner</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ScaleTransitioner.TransitionToVisible">
            <summary>
            Returns an Action that performs a non LOD transition of a transform from invisible to visible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ScaleTransitioner.LODTransitionToVisible">
            <summary>
            Returns an Action that performs an LOD transition of a transform from invisible to visible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ScaleTransitioner.TransitionToInvisible">
            <summary>
            Returns an Action that performs a non LOD transition of a transform from visible to invisible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ScaleTransitioner.LODTransitionToInvisible">
            <summary>
            Returns an Action that performs an LOD transition of a transform from visible to invisible.
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.AwakeExtended">
            <summary>
            Used to create the TransitionToVisible and TransitionToInvisible actions.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.PrepForAnyUse">
            <summary>
            Performs some checks and setup that is required at runtime and in the editor (when using 
            the World Designer Tool)
            </summary>
            <displayName id="PrepForAnyUse">
            PrepForAnyUse()
            </displayName>
            <syntax>
            protected sealed override void PrepForAnyUse()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.GetVectorData(UnityEngine.Transform)">
            <summary>
            Returns the scale of the Transform.
            </summary>
            <param name="transform" type="Transform">
            The Transform to get the data from.
            </param>
            <returns type="Vector3">
            The scale data.
            </returns>
            <displayName id="GetVectorData">
            GetVectorData(Transform)
            </displayName>
            <syntax>
            protected sealed override Vector3 GetVectorData(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.MakeTransformVisibleImmediately(UnityEngine.Transform)">
            <summary>
            Immediately transitions the transform to the visible state.
            </summary>
            <param name="transform" type="Transform">
            The Transform to transition.
            </param>
            <displayName id="MakeTransformVisibleImmediately">
            MakeTransformVisibleImmediately(Transform)
            </displayName>
            <syntax>
            protected sealed override void MakeTransformVisibleImmediately(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.StoreAdditionalData_InvisibleToVisible(UnityEngine.Transform)">
            <summary>
            Stores the difference between the transforms scale when visible and scale when invisble. This data is used 
            by the TransitionToVisible action.
            </summary>
            <param name="transform" type="Transform">
            The Transform whose data should be stored.
            </param>
            <displayName id="StoreAdditionalData_InvisibleToVisible">
            StoreAdditionalData_InvisibleToVisible(Transform)
            </displayName>
            <syntax>
            protected sealed override void StoreAdditionalData_InvisibleToVisible(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.MakeTransformInvisibleImmediately(UnityEngine.Transform)">
            <summary>
            Immediately transitions the transform to the invisible state.
            </summary>
            <param name="transform" type="Transform">
            The Transform to transition.
            </param>
            <displayName id="MakeTransformInvisibleImmediately">
            MakeTransformInvisibleImmediately(Transform)
            </displayName>
            <syntax>
            protected sealed override void MakeTransformInvisibleImmediately(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.StoreAdditionalData_VisibleToInvisible(UnityEngine.Transform)">
            <summary>
            Stores the difference between the transforms scale when visible and scale when invisble. This data is used 
            by the TransitionToInvisible action.
            </summary>
            <param name="transform" type="Transform">
            The Transform whose data should be stored.
            </param>
            <displayName id="StoreAdditionalData_VisibleToInvisible">
            StoreAdditionalData_VisibleToInvisible(Transform)
            </displayName>
            <syntax>
            protected sealed override void StoreAdditionalData_VisibleToInvisible(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ScaleTransitioner.ClearAdditionalData(System.Int32)">
            <summary>
            Clears data stored using the StoreAdditionalData methods.
            </summary>
            <param name="transformIndexToClear" type="int">
            The index of the transform whose data should be cleared.
            </param>
            <displayName id="ClearAdditionalData">
            ClearAdditionalData(int)
            </displayName>
            <syntax>
            protected sealed override void ClearAdditionalData(int transformIndexToClear)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SceneChunkStreamer">
            <summary>
            A Chunk Streamer component which loads chunks via scenes using the 
            <see href="https://docs.unity3d.com/ScriptReference/SceneManagement.SceneManager.LoadSceneAsync.html">SceneManager.LoadSceneAsync</see> method.
            <para>
            You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Streamable Assets Manager.
            </para>
            </summary>
            <title>SceneChunkStreamer Class</title>
            <category>Chunk Streamers</category>
            <navigationName>SceneChunkStreamer</navigationName>
            <fileName>SceneChunkStreamer.html</fileName>
            <syntax>
            public sealed class SceneChunkStreamer : <see cref = "T:DeepSpaceLabs.SAM.ChunkStreamer" href = "ChunkStreamer.html">ChunkStreamer</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SceneChunkStreamer.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            Scene objects cannot be fully loaded/initialized in a single frame; they need one frame before they actually "exist"
            in the scene they're loaded into. Because of this, pre loading is required, and so this property is overridden
            to always return true.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SceneChunkStreamer.AsyncLoadStrategy">
            <summary>
            Gets or sets the Async Load Strategy, which the strategy the Streamer will use to 
            load Asset Chunks.
            </summary>
            <type link="AsyncLoadStrategy.html">AsyncLoadStrategy</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SceneChunkStreamer.ChunkDestroyer">
            <summary>
            Gets the Chunk Destroyer associated with this component.
            </summary>
            <type link="ChunkDestroyer.html">ChunkDestroyer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SceneChunkStreamer.KeepScenesIntact">
            <summary>
            Gets the value of the Keep Scenes Intact option (set in the inspector).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SceneChunkStreamer.CompatibleWithHiearchyOrganizer">
            <summary>
            Returns true only if Keep Scenes Intact is false (disabled).
            <para>
            When Keep Scenes Intact is true (enabled), reparenting the Asset Chunks using a Hierarchy Organizer 
            would present huge problems, and thus it is not possible to use a Hiearchy Organizer in conjunction 
            with a Scene Chunk Streamer with this option enabled.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SceneChunkStreamer.MemoryFreeingStrategy">
            <summary>
            The strategy for freeing memory, which basically determines if/when Resources.UnloadUnusedAssets() is called.
            </summary>
            <type link="MemoryFreeingStrategy.html">MemoryFreeingStrategy</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SceneChunkStreamer.InvalidSceneFormatMessageLevel">
            <summary>
            Gets or sets the InvalidSceneFormatMessageLevel used by this Scene Chunk Streamer.
            </summary>
            <type link="InvalidSceneFormatMessageLevel.html">InvalidSceneFormatMessageLevel</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SceneChunkStreamer.AwakeExtended">
            <summary>
            Executes Awake related logic.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SceneChunkStreamer.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Creates a new SceneChunkStreamerUser, which is a custom type which derives from ChunkStreamerUser. This user object
            contains a <see cref="T:DeepSpaceLabs.SAM.CellString" href = "CellString.html">CellString</see> and some other data used specifically by this class.
            </summary>
            <param name="zoneGrouping" type="IZoneGrouping" link="IZoneGrouping.html">
            The Zone Grouping being registered.
            </param>
            <displayName id = "CreateNewUser">CreateNewUser(IZoneGrouping)</displayName>
            <syntax>protected override ChunkStreamerUser CreateNewUser(IZoneGrouping zoneGrouping)</syntax>
            <returns type = "ChunkStreamerUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SceneChunkStreamer.PerformSingleFrameAttachmentPreload(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Pre loads the chunks needed by the input cells for the user identified by loaderID. This ensures
            that when <see cref="M:DeepSpaceLabs.SAM.SceneChunkStreamer.LoadAndAttachChunksToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)" href = "#LoadAndAttachChunksToCellsInSingleFrame">LoadAndAttachChunksToCellsInSingleFrame</see> is
            called in a subsequent frame, it will work properly.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;">The cells whose chunks need to be pre loaded.</param>
            <param name="userID" type = "int">The ID of the user requesting the pre load.</param>
            <displayName id = "PerformSingleFrameAttachmentPreload">PerformSingleFrameAttachmentPreload(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public sealed override void PerformSingleFrameAttachmentPreload(List&lt;WorldCell&gt; cells, int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SceneChunkStreamer.LoadAndAttachChunksToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Attaches the chunks associated with the input cells to the cells in a single frame. Because 
            <see cref="P:DeepSpaceLabs.SAM.SceneChunkStreamer.IsSingleFrameAttachmentPreloadRequired" href = "#IsSingleFrameAttachmentPreloadRequired">IsSingleFrameAttachmentPreloadRequired</see> is
            set to return true, <see cref="M:DeepSpaceLabs.SAM.SceneChunkStreamer.PerformSingleFrameAttachmentPreload(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)" href = "#PerformSingleFrameAttachmentPreload">PerformSingleFrameAttachmentPreload</see> 
            must be called in an earlier frame prior to this method being called.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;">The cells whose objects need to be attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "LoadAndAttachChunksToCellsInSingleFrame">LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public sealed override void LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SceneChunkStreamer.LoadAndAttachChunksToCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Loads and attaches the objects associated with the input cells to the cells over a period of frames. using async scene loading.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose objects need to be loaded and attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "LoadAndAttachChunksToCellsInSingleFrame">LoadAndAttachChunksToCells(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public sealed override IEnumerator&lt;YieldInstruction&gt; LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SceneChunkStreamer.DetachAndUnloadChunksFromCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Unloads the cell chunks and their associated scene via SceneManager.UnloadSceneAsync.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells whose chunks need to be detached and unloaded.
            </param>
            <param name="userID" type = "int">
            The ID of the user requesting the unload and detachment.
            </param>
            <displayName id = "DetachAndUnloadChunksFromCells">
            DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager">
            <summary>
            An implementation of an 
            <see cref="T:DeepSpaceLabs.SAM.IPersistentStateManager" href="IPersistentStateManager.html">IPersistentStateManager</see> 
            that uses binary serialization to save/load persistent data related to the Streamable Assets Manager.
            </summary>
            <title>BinarySerializerPersistentStateManager Class</title>
            <category>Persistent State Managers</category>
            <navigationName>BinarySerializerPersistentStateManager</navigationName>
            <fileName>BinarySerializerPersistentStateManager.html</fileName>
            <syntax>public sealed class BinarySerializerPersistentStateManager : MonoBehaviour, <see href = "IPersistentStateManager.html">IPersistentStateManager</see></syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.FileName">
            <summary>
            Gets or sets the file name that the manager should use to save/load data. If you are implementing a save system that uses multiple save files, you 
            should set the FileName before beginning the Save and Load operations.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.FileExist">
            <summary>
            Gets a value indicating whether the save data file named FileName exists. This property will generate garbage as the full file path 
            of the file needs to be generated each time it is called. Therefore, you should not call it repeatedly.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.FilePath">
            <summary>
            Gets the full file path of the file. This will be equal to Application.persistentDataPath/FileName. The path needs to be generated each time 
            this property is called, therefore it will generate garbage. You should store the returned value rather than calling the property repeatedly.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.DisableAutoInvocationOfBeforeAndAfterSaveMethods">
            <summary>
            By default, when the Component Manager's Save method is called, it will automatically call 
            OnBeforeDataSaved before calling the Save... methods, and then it will automatically call OnAfterDataSaved 
            after all data has been saved. In some instances, this may be undesirable, for instance if you want to 
            save non Streamable Assets Manager data before or after the Component Manager's Save method is called. 
            <para>
            In these instances, you can disable the auto calling of those two methods (by the Component Manager) 
            by enabling the Disable Auto Invocation Of Before And After Save Methods option in the insepctor, which this property returns. Note, 
            however, that you will need to call the OnBeforeDataSaved and OnAfterDataSaved methods manually, before and after 
            beginning/completing the save operation.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.DisableAutoInvocationOfBeforeAndAfterLoadMethods">
            <summary>
            By default, when the Component Manager's Load method is called, it will automatically call 
            OnBeforeDataLoaded before calling the Load... methods, and then it will automatically call OnAfterDataLoaded 
            after all data has been loaded. In some instances, this may be undesirable, for instance if you want to 
            load non Streamable Assets Manager data before or after the Component Manager's Load method is called. 
            <para>
            In these instances, you can disable the auto calling of those two methods (by the Component Manager) 
            by enabling the Disable Auto Invocation Of Before And After Load Methods option in the insepctor, which this property returns. Note, 
            however, that you will need to call the OnBeforeDataLoaded and OnAfterDataLoaded methods manually, before and after 
            beginning/completing the load operation.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.OnBeforeDataSaved">
            <summary>
            Called before the Streamable Assets Manager saves data via the Component Manager (happens when Save or ConvertOldData is called). 
            This methods opens or creates a file named fileName at Application.persistentDataPath, a stream to that file, and a binary writer for writing to the stream.
            <para>
            If Disable Auto Invocation Of Before And After SaveMethods is disabled in the inspector, you will need to call this method manually before calling ComponentManager.Save 
            or ComponentManager.ConvertOldData.
            </para>
            </summary>
            <displayName id = "OnBeforeDataSaved">OnBeforeDataSaved()</displayName>
            <syntax>void OnBeforeDataSaved()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.SaveInt(System.Int32)">
            <summary>
            Saves an integer value to the FileStream via BinaryWriter.Write
            </summary>
            <param name="value" type="int">The integer to save.</param>
            <displayName id = "SaveInt">SaveInt(int)</displayName>
            <syntax>void SaveInt(int value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.SaveBool(System.Boolean)">
            <summary>
            Saves a boolean value to the FileStream via BinaryWriter.Write
            </summary>
            <param name="value" type="bool">The bool to save.</param>
            <displayName id = "SaveBool">SaveBool(bool)</displayName>
            <syntax>void SaveBool(bool value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.SaveFloat(System.Single)">
            <summary>
            Saves a float value to the FileStream via BinaryWriter.Write
            </summary>
            <param name="value" type="float">The float to save.</param>
            <displayName id = "SaveFloat">SaveFloat(float)</displayName>
            <syntax>void SaveFloat(float value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.SaveDouble(System.Double)">
            <summary>
            Saves a double value to the FileStream via BinaryWriter.Write
            </summary>
            <param name="value" type="double">The double to save.</param>
            <displayName id = "SaveDouble">SaveDouble(double)</displayName>
            <syntax>void SaveDouble(double value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.SaveString(System.String)">
            <summary>
            Saves a string value to the FileStream via BinaryWriter.Write
            </summary>
            <param name="value" type="string">The string to save.</param>
            <displayName id = "SaveString">SaveString(string)</displayName>
            <syntax>void SaveString(string value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.OnAfterDataSaved">
            <summary>
            Called after data is saved by the Streamable Assets Manager via the Component Manager (happens when Save or ConvertOldData is called). 
            This closes the binary writer and file stream.
            <para>
            If Disable Auto Invocation Of Before And After SaveMethods is disabled in the inspector, you will need to call this method manually after calling ComponentManager.Save 
            or ComponentManager.ConvertOldData.
            </para>
            </summary>
            <displayName id = "SaveString">SaveString(string)</displayName>
            <syntax>void SaveString(string value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.OnBeforeDataLoaded">
            <summary>
            Called before the Streamable Assets Manager begins the loading process. 
            This opens the file which holds the save data, a file stream to read from, and a binary reader to 
            read from the open stream.
            </summary>
            <displayName id = "OnBeforeDataLoaded">OnBeforeDataLoaded()</displayName>
            <syntax>void OnBeforeDataLoaded()</syntax>
            <exception cref="T:System.IO.FileNotFoundException">
            Thrown when the file specified does not exist in Application.persistentDataPath.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.LoadInt">
            <summary>
            Loads a integer value via BinaryReader.ReadInt32
            </summary>
            <displayName id = "LoadInt">LoadInt()</displayName>
            <syntax>int LoadInt()</syntax>
            <returns type = "int">The loaded integer.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.LoadBool">
            <summary>
            Loads a boolean value via BinaryReader.ReadBoolean
            </summary>
            <displayName id = "LoadBool">LoadBool()</displayName>
            <syntax>bool LoadBool()</syntax>
            <returns type = "bool">The loaded boolean.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.LoadFloat">
            <summary>
            Loads a float value via BinaryReader.ReadSingle
            </summary>
            <displayName id = "LoadFloat">LoadFloat()</displayName>
            <syntax>float LoadFloat()</syntax>
            <returns type = "float">The loaded float.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.LoadDouble">
            <summary>
            Loads a double value via BinaryReader.ReadDouble
            </summary>
            <displayName id = "LoadDouble">LoadDouble()</displayName>
            <syntax>double LoadDouble()</syntax>
            <returns type = "double">The loaded double.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.LoadString">
            <summary>
            Loads a string value via BinaryReader.ReadString
            </summary>
            <displayName id = "LoadString">LoadString()</displayName>
            <syntax>string LoadString()</syntax>
            <returns type = "string">The loaded string.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.OnAfterDataLoaded">
            <summary>
            Called after all data is loaded. The open BeinaryReader is closed along with the FileStream.
            </summary>
            <displayName id = "OnAfterDataLoaded">OnAfterDataLoaded()</displayName>
            <syntax>void OnAfterDataLoaded()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.SaveSAMData">
            <summary>
            A utility method that can be used to save SAM related data using this Manager. This method will identify the Component Manager in the scene (which there 
            should only be one of), and call it's Save method, passing in itself as the IPersistentStateManager. If a Component Manager does not exist 
            in the current scene, this method will exit silently.
            <para>
            You can also trigger this method via the context menu in the Unity Editor via the inspector.
            </para>
            </summary>
            <displayName id="SaveSAMData">
            SaveSAMData()
            </displayName>
            <syntax>
            public void SaveSAMData()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BinarySerializerPersistentStateManager.LoadSAMData">
            <summary>
            A utility method that can be used to load SAM related data (that was saved with this Manager) using this Manager. This method will identify the Component Manager in the scene (which there 
            should only be one of), and call it's Load method, passing in itself as the IPersistentStateManager. If a Component Manager does not exist 
            in the current scene, or if it has already been initialized, this method will exit silently.
            <para>
            You can also trigger this method via the context menu in the Unity Editor via the inspector.
            </para>
            <para>
            Remember that SAM persistent data must be loaded prior to SAM/the Component Manager being initialized! Also note that this method will pass in true for the 
            performComponentManagerIDCheck argument of the Component Manager's Load method. If this doesn't work for you, you cannot use this method!
            </para>
            </summary>
            <displayName id="LoadSAMData">
            LoadSAMData()
            </displayName>
            <syntax>
            public void LoadSAMData()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.CustomPlayer">
            <summary>
            This represents a custom player. Override this class to create a custom IPlayer implementation that can be assigned to an 
            ActiveGrid, either in the inspector or at runtime via the PreInitialize_SetPlayer method. Custom IPlayer implementations can be 
            used in situations where you player is not represented by a traditional Transform component. Take a look at 
            the <see cref="T:DeepSpaceLabs.SAM.IPlayer" href="IPlayer.html">IPlayer</see> interface for more information.
            <para>
            </para>
            </summary>
            <title>
            CustomPlayer Class
            </title>
            <category>Secondary Components</category>
            <navigationName>
            CustomPlayer
            </navigationName>
            <fileName>CustomPlayer.html</fileName>
            <syntax>
            public abstract class CustomPlayer : MonoBehaviour
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CustomPlayer.Position">
            <summary>
            When overriden, gets or sets the position of the player.
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SimpleChunkDestroyer">
            <summary>
            Provides a simple implementation for a 
            <see cref="T:DeepSpaceLabs.SAM.ChunkDestroyer" href="ChunkDestroyer.html">Chunk Destroyer</see>, 
            which destroys a specific number of game objects per frame. 
            The destroyer searches one level deep for child objects of each main chunk, and destroys those first 
            before destroying the root chunk.
            <para>
            As the name implies, this is a rather simple implementation, 
            and is not suitable for more complex child-parent hierarchies.
            In those cases, it is recommended to create a custom Chunk Destroyer.
            </para>
            <para>
            This destroyer does a check to make sure the chunks on each 
            <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> are present 
            before trying to destroy them, in situations where you manually destroy the chunks.
            </para>
            <para>
            The destroyer attempts to limit the amount of frame time consuned by the destruction of Asset Chunks via the Min Objects To Destroy In 
            A Single Frame value, since the destruction overhead is typically delayed until the end of the frame and thus cannot be tracked properly by 
            the Execution Controller. Each first level child of each chunk, plus the chunk itself, is counted towards this value. If 'Count 
            Grandchildren' is enabled, the grandchildren of each asset chunk are also counted. This count is carried over from one asset chunk to the 
            next, so long as the destruction operation of of the next asset chunk begins in the same frame that the last chunk's destruction ended.
            </para>
            </summary>
            <title>SimpleChunkDestroyer Class</title>
            <category>Chunk Destroyers</category>
            <navigationName>SimpleChunkDestroyer</navigationName>
            <fileName>SimpleChunkDestroyer.html</fileName>
            <syntax>public sealed class SimpleChunkDestroyer : <see cref="T:DeepSpaceLabs.SAM.ChunkDestroyer" href = "ChunkDestroyer.html">ChunkDestroyer</see></syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SimpleChunkDestroyer.DestroyChunksOnCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.MemoryFreeingStrategy,DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser,System.Boolean)">
            <summary>
            Destroys x children per frame, where x is whatever you set the "Max Objects To Destroy In A Single Frame" option in the insepctor to.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells with the chunks needing to be destroyed.
            </param>
            <param name="memoryFreeingStrategy" type = "MemoryFreeingStrategy" link="MemoryFreeingStrategy.html">
            The Memory Freeing Strategy set in the inspector of the calling Chunk Manager. 
            This method DOES make use of this value. If the value is set to 
            'Free After Each Chunk', when memory is freed after the root chunk object is destroyed, 
            the destroyed object counter is reset to 0.
            </param>
            <param name="ChunkStreamerUser" type = "ChunkStreamer.ChunkStreamerUser">
            The user which triggered the method call. This object is not used by this method.
            </param>
            <param name="waitOnFinalMemoryFreeing" type="bool">
            If memoryFreeingStrategy is not set to Dont Free Memory, this controls whether the destroyer will wait on the final memory freeing operation before 
            yielding control back to the calling Chunk Streamer. Setting this to false may speed up the World Update Speed, or it may not, since the memory 
            freeing strategy will block other Async operations from executing.
            </param>
            <displayName id="DestroyChunksOnCells">
            DestroyChunksOnCells(List&lt;WorldCell&gt;, MemoryFreeingStrategy, ChunkStreamer.ChunkStreamerUser, bool)
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; DestroyChunksOnCells(List&lt;WorldCell&gt; cells, MemoryFreeingStrategy memoryFreeingStrategy, ChunkStreamer.ChunkStreamerUser ChunkStreamerUser, bool waitOnFinalMemoryFreeing)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TransformPlayer">
            <summary>
            An IPlayer implementation for a transform based player. When you set Player Type to Transform Player on an Active Grid, internally an object 
            of this type is created. Normally you would not need to use this class yourself, however if you are presented with a method that takes 
            an IPlayer or IPlayer[], you can use this to be able to pass in a valid object to that method.
            <para>
            </para>
            </summary>
            <title>
            TransformPlayer Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>
            TransformPlayer
            </navigationName>
            <fileName>TransformPlayer.html</fileName>
            <syntax>
            public sealed class TransformPlayer : IPlayer
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformPlayer.#ctor(UnityEngine.Transform)">
            <summary>
            Constructs a new instance of the Transform Player using the playerTransform.
            </summary>
            <param name="playerTransform" type="Transform">
            The transform associated with the player.
            </param>
            <displayName id="TransformPlayer">
            TransformPlayer(Transform)
            </displayName>
            <syntax>
            public TransformPlayer(Transform playerTransform)
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformPlayer.Position">
            <summary>
            Gets and sets the position of the IPlayer. Uses Transform.position property
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformPlayer.PlayerTransform">
            <summary>
            The Transform of the Player assigned to this TransformPlayer. This property is intended solely so that you can verify that the correct Transform is being used by the Active Grid.
            </summary>
            <type>Transform</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TransformTransitioner">
            <summary>
            An abstract class designed around performing transform based World Cell Transitions. This class serves 
            as a base class that the 
            <see cref="T:DeepSpaceLabs.SAM.PositionTransitioner" href="PositionTransitioner.html">PositionTransitioner</see> 
            and <see cref="T:DeepSpaceLabs.SAM.ScaleTransitioner" href="ScaleTransitioner.html">ScaleTransitioner</see> derive from. While you can theoretically 
            derive from it yourslef to create a custom Transitioner, doing so does not make much sense as the 
            PositionTransitioner and ScaleTransitioner should be all you need if performing transform based transitions.
            <para>
            </para>
            </summary>
            <title>TransformTransitioner Class</title>
            <category>Visual Transition Controllers</category>
            <navigationName>TransformTransitioner</navigationName>
            <fileName>TransformTransitioner.html</fileName>
            <syntax>
            public abstract class TransformTransitioner : <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">CellVisualTransitionController</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformTransitioner.TransitionToVisible">
            <summary>
            Must be overriden to perform a gradual non LOD transition of the transform from invisible to visible.
            <para>
            1st Parameters (float) - Time as value between 0 (transition not started) and 1 (time elapsed = Transition Time), 
            which you will typically pass into the MakeVisibleCurve.Evaluate method.
            </para>
            <para>
            2nd Parameter (Transform) - The Transform to transition.
            </para>
            <para>
            3rd Parameter (Vector3) - The starting Vector3 data (that was returned by the GetVectorData method). 
            </para>
            <para>
            4th Paramter (int) - The index of the Transform in the list of Transforms currently being processed. This 
            can be used to retrieve any additional data that was stored for the Transform by 
            StoreAdditionalData_InvisibleToVisible.
            </para>
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformTransitioner.LODTransitionToVisible">
            <summary>
            Must be overriden to perform a gradual LOD transition of the transform from invisible to visible.
            <para>
            1st Parameters (float) - Time as value between 0 (transition not started) and 1 (time elapsed = LOD Transition Time), 
            which you will typically pass into the LODTransitionMakeVisibleCurve.Evaluate method.
            </para>
            <para>
            2nd Parameter (Transform) - The Transform to transition.
            </para>
            <para>
            3rd Parameter (Vector3) - The starting Vector3 data (that was returned by the GetVectorData method). 
            </para>
            <para>
            4th Paramter (int) - The index of the Transform in the list of Transforms currently being processed. This 
            can be used to retrieve any additional data that was stored for the Transform by 
            StoreAdditionalData_InvisibleToVisible.
            </para>
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformTransitioner.TransitionToInvisible">
            <summary>
            Must be overriden to perform a gradual non LOD transition of the transform from visible to invisible.
            <para>
            1st Parameters (float) - Time as value between 0 (transition not started) and 1 (time elapsed = Transition Time), 
            which you will typically pass into the MakeInvisibleCurve.Evaluate method.
            </para>
            <para>
            2nd Parameter (Transform) - The Transform to transition.
            </para>
            <para>
            3rd Parameter (Vector3) - The starting Vector3 data (that was returned by the GetVectorData method). 
            </para>
            <para>
            4th Paramter (int) - The index of the Transform in the list of Transforms currently being processed. This 
            can be used to retrieve any additional data that was stored for the Transform by 
            StoreAdditionalData_VisibleToInvisible.
            </para>
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformTransitioner.LODTransitionToInvisible">
            <summary>
            Must be overriden to perform a gradual LOD transition of the transform from visible to invisible.
            <para>
            1st Parameters (float) - Time as value between 0 (transition not started) and 1 (time elapsed = LOD Transition Time), 
            which you will typically pass into the LODTransitionMakeInvisibleCurve.Evaluate method.
            </para>
            <para>
            2nd Parameter (Transform) - The Transform to transition.
            </para>
            <para>
            3rd Parameter (Vector3) - The starting Vector3 data (that was returned by the GetVectorData method). 
            </para>
            <para>
            4th Paramter (int) - The index of the Transform in the list of Transforms currently being processed. This 
            can be used to retrieve any additional data that was stored for the Transform by 
            StoreAdditionalData_VisibleToInvisible.
            </para>
            </summary>
            <type>Action&lt;float, Transform, Vector3, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformTransitioner.TransitionTimeDeviation">
            <summary>
            Gets or Sets the Transition Time Deviation.
            <para>
            Can be used to add a small deviation to the transition times of each transform that is transitioned in a single batch.
            </para>
            <para>
            Basically, for each transform, a random transition time will be assigned between 
            [Transition Time - Transition Time Variation] and [Transition Time + Transition Time Variation]
            </para>
            <para>
            For example, if Transition Time is set to 2 seconds and this value is set to 1 second, transition times will fall 
            bewteen 1 and 3 seconds (min time is always capped at 0).
            </para>
            <para>
            Changing this value will have no effect on any transitions currently in progress.
            </para>
            </summary>
            <type>float</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.PrepForAnyUse">
            <summary>
            This is called anytime one of the TransformTransitioner's public methods is called, before the rest of the method runs. You can override it 
            to perform any setup/configuration/etc. that is required to properly run the methods.
            </summary>
            <displayName id="PrepForAnyUse">
            PrepForAnyUse()
            </displayName>
            <syntax>
            protected virtual void PrepForAnyUse()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.ImmediatelyTransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Immediately transitions the transforms of the World Cells to the visible state. You should never call this 
            method yourself.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells to transition.
            </param>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type of the Asset Chunks belonging to the World Cells.
            </param>
            <displayName id="ImmediatelyTransitionToVisibleState">
            ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override void ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.ResetToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Resets the transforms of the World Cells to the invisible state. You should never call this 
            method yourself.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells to reset.
            </param>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type of the Asset Chunks belonging to the World Cells.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the game is currently running. If false, it means the method was called in the editor.
            </param>
            <displayName id="ResetToInvisibleState">
            ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.ResetToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Resets the transforms of the World Cells to the visible state. You should never call this 
            method yourself.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells to reset.
            </param>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type of the Asset Chunks belonging to the World Cells.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the game is currently running. If false, it means the method was called in the editor.
            </param>
            <displayName id="ResetToVisibleState">
            ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.TransitionToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Transitions the transforms of the World Cells to the invisible state over multiple frames. You should never call this 
            method yourself.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells to transition.
            </param>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type of the Asset Chunks belonging to the World Cells.
            </param>
            <displayName id="TransitionToInvisibleState">
            TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.TransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Transitions the transforms of the World Cells to the visible state over multiple frames. You should never call this 
            method yourself.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells to transition.
            </param>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type of the Asset Chunks belonging to the World Cells.
            </param>
            <displayName id="TransitionToVisibleState">
            TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.TransitionBetweenLevelsOfDetail(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType,DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Transitions the transforms of the World Cells to the visible state over multiple frames. You should never call this 
            method yourself.
            </summary>
            <param name="transitionFromCells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned from 
            (i.e., they are what is currently visible that we want to make invisible). 
            This list is read only and may contain cells from different LODs.
            </param>
            <param name="transitionFromCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionFromCells.
            </param>
            <param name="transitionToCells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned to 
            (i.e., they are what is currently invisible that we want to make visible). 
            This list is read only and all cells are from the same World Grouping and LOD.
            </param>
            <param name="transitionToCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionToCells.
            </param>
            <displayName id="TransitionBetweenLevelsOfDetail">
            TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt;, ChunkType, ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt; transitionFrom, ChunkType transitionFromCellsChunkType, ReadOnlyList&lt;WorldCell&gt; transitionTo, ChunkType transitionToCellsChunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.GetVectorData(UnityEngine.Transform)">
            <summary>
            Override to return pertinent Vector3 data from the Transform. Return whatever your 
            Transitioner deals with (position, scale, etc.)
            </summary>
            <param name="transform" type="Transform">
            The Transform to get the data from.
            </param>
            <returns type="Vector3">
            The Vector data.
            </returns>
            <displayName id="GetVectorData">
            GetVectorData(Transform)
            </displayName>
            <syntax>
            protected abstract Vector3 GetVectorData(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.MakeTransformVisibleImmediately(UnityEngine.Transform)">
            <summary>
            Override to transition a transform immediately to the visible state.
            </summary>
            <param name="transform" type="Transform">
            The Transform to transition.
            </param>
            <displayName id="MakeTransformVisibleImmediately">
            MakeTransformVisibleImmediately(Transform)
            </displayName>
            <syntax>
            protected abstract void MakeTransformVisibleImmediately(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.MakeTransformInvisibleImmediately(UnityEngine.Transform)">
            <summary>
            Override to transition a transform immediately to the invisible state.
            </summary>
            <param name="transform" type="Transform">
            The Transform to transition.
            </param>
            <displayName id="MakeTransformInvisibleImmediately">
            MakeTransformInvisibleImmediately(Transform)
            </displayName>
            <syntax>
            protected abstract void MakeTransformInvisibleImmediately(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.CanWorldCellsBeTransitioned(DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Overriden to return true. You can override it to return a different value.
            </summary>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type.
            </param>
            <returns type="type">
            True, indicating all chunk types can be transitioned.
            </returns>
            <displayName id="CanWorldCellsBeTransitioned">
            CanWorldCellsBeTransitioned(ChunkType)
            </displayName>
            <syntax>
            public override bool CanWorldCellsBeTransitioned(ChunkType chunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.StoreAdditionalData_InvisibleToVisible(UnityEngine.Transform)">
            <summary>
            Optionally override to store additional data in your custom transitioner for a invisible to visible transition.
            </summary>
            <param name="transform" type="Transform">
            The Transform whose data should be stored.
            </param>
            <displayName id="StoreAdditionalData_InvisibleToVisible">
            StoreAdditionalData_InvisibleToVisible(Transform)
            </displayName>
            <syntax>
            protected virtual void StoreAdditionalData_InvisibleToVisible(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.StoreAdditionalData_VisibleToInvisible(UnityEngine.Transform)">
            <summary>
            Optionally override to store additional data in your custom transitioner for a visible to invisible transition.
            </summary>
            <param name="transform" type="Transform">
            The Transform whose data should be stored.
            </param>
            <displayName id="StoreAdditionalData_VisibleToInvisible">
            StoreAdditionalData_VisibleToInvisible(Transform)
            </displayName>
            <syntax>
            protected virtual void StoreAdditionalData_VisibleToInvisible(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformTransitioner.ClearAdditionalData(System.Int32)">
            <summary>
            Optionally override to remove any data stored using the StoreAdditionalData methods. This 
            is called once the transition for a transform has been completed.
            </summary>
            <param name="transformIndexToClear" type="int">
            The index of the transform. Tyically, you will have the data stored in a list and 
            remove it using list.RemoveAt(transformIndex).
            </param>
            <displayName id="ClearAdditionalData">
            ClearAdditionalData(int)
            </displayName>
            <syntax>
            protected virtual void ClearAdditionalData(int transformIndexToClear)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldDesignerGroupingListener">
            <summary>
            A Scriptable Object class you can derive from and hook up to the World Designer tool to receive notifications 
            when Asset Chunks are added and removed from the scene using the Tool.
            <para>
            This is useful if you need to perform some secondary operations on the assets, perhaps involving third party tools.
            </para>
            <para>
            Do note that this feature has some limitations, including:
            </para>
            <br></br>
            <para indented="true">
            1) References to the assets may become nulled out under different situations, such as unloading the scene the assets 
            are in or performing an assembly reload (but not always in this case). This, in combination with item 2 below, may cause issues.
            </para>
            <br></br>
            <para indented="true">
            2) Only newly loaded assets are passed to the OnAfterAssetChunksAdded method. You will need to account for this and 
            in some cases (when references become "lost"), you may need to manually unload and re-load the Asset Chunks for the 
            Grouping in order for the asset chunks to be detected as "new" and for them to trigger the OnAfterAssetChunksAdded method.
            </para>
            <br></br>
            <para indented="true">
            If storing the assets in a list, you may also need to check before using the assets to make sure they are not null (if they 
            are null, they should be pruned from the list).
            </para>
            <br></br>
            <para indented="true">
            3) The World Cells passed into the OnAfterAssetChunksAdded method are fully configured and settings can be relied upon to be accurate, 
            including the neighbors; however, 
            there is no guarantee that the World Cells will remain valid after you return execution to calling code (for instance, they 
            will be destroyed if you change which World Grouping is being edited by the World Designer Tool). As such, you should only 
            use the World Cells in your method bodies and should not store references to them to be used later.
            </para>
            <br></br>
            <para indented="true">
            In addition to this, neighbors will not be set on World Cells when they are passed to the OnBeforeAssetChunksRemoved method, 
            due to the nature of how the World Designer works. All values will be null!
            </para>
            <br></br>
            <para indented = "true">
            4) It does not make much sense to make edits to the assets using this class, as the edits will be performed every time 
            the asset is loaded and/or unloaded. Instead, this class is primarily intended to allow you to interface with other 
            scripts that may need to know when an asset is loaded and unloaded, or to perform secondary logic.
            </para>
            <para>
            If more than one listener is assigned to a Grouping, each listener is called in the order they appear in the World Designer Tool.
            </para>
            <para>
            If you only care about specific LODs, use the LevelOfDetail property of the WorldCell to ignore Asset Chunks that don't belong to the 
            LODs you care about!
            </para>
            </summary>
            <title>WorldDesignerGroupingListener Class</title>
            <category>Scriptable Assets</category>
            <navigationName>WorldDesignerGroupingListener</navigationName>
            <fileName>WorldDesignerGroupingListener.html</fileName>
            <syntax>
            public abstract class WorldDesignerGroupingListener : ScriptableObject
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldDesignerGroupingListener.OnAfterAssetChunksAdded(DeepSpaceLabs.Core.ReadOnlyList{System.Object},DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            This is called by the World Designer tool just after an Asset Chunks from a particular World 
            Grouping and LOD have been added to the scene.
            </summary>
            <param name="assetChunks" type="ReadOnlyList&lt;object&gt;">
            The asset chunk objects that were just added.
            </param>
            <param name="cellsChunksBelongsTo" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells that the asset chunks belongs to. All data will be configured correctly, including the 
            neighbors of each cell. Each index in this list corresponds to the same indexed item in the assetChunks lists, so you 
            should use a for statement rather than a foreach to iterate through the asset chunks and world cells.
            <para>
            Because all assets in the assetChunks list are guaranteed to come from the same World Grouping and LOD, you can check the 
            data of the first World Cell only to determine if your logic should run (perhaps you only want it to run for LOD 2, for example), 
            or to perform custom logic for each LOD or World Grouping.
            </para>
            </param>
            <displayName id="OnAfterAssetChunksAdded">
            OnAfterAssetChunksAdded(ReadOnlyList&lt;object&gt;, ReadOnlyList&lt;WorldCell&gt;)
            </displayName>
            <syntax>
            public abstract void OnAfterAssetChunksAdded(ReadOnlyList&lt;object&gt; assetChunks, ReadOnlyList&lt;WorldCell&gt; cellsChunksBelongsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldDesignerGroupingListener.OnBeforeAssetChunksRemoved(DeepSpaceLabs.Core.ReadOnlyList{System.Object},DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            This is called by the World Designer tool just prior to a group of Asset Chunks from a particular World 
            Grouping and LOD being removed from the scene.
            </summary>
            <param name="assetChunks" type="ReadOnlyList&lt;object&gt;">
            The asset chunk objects that are about to be removed.
            </param>
            <param name="cellsChunksBelongsTo" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells that the asset chunks belongs to. All data will be configured correctly, excepting the 
            neighbors of each cell. Each index in this list corresponds to the same indexed item in the assetChunks lists, so you 
            should use a for statement rather than a foreach to iterate through the asset chunks and world cells.
            <para>
            Because all assets in the assetChunks list are guaranteed to come from the same World Grouping and LOD, you can check the 
            data of the first World Cell only to determine if your logic should run (perhaps you only want it to run for LOD 2, for example), 
            or to perform custom logic for each LOD or World Grouping.
            </para>
            </param>
            <displayName id="OnBeforeAssetChunksRemoved">
            OnBeforeAssetChunksRemoved(ReadOnlyList&lt;object&gt;, ReadOnlyList&lt;WorldCell&gt;)
            </displayName>
            <syntax>
            public abstract void OnBeforeAssetChunksRemoved(ReadOnlyList&lt;object&gt; assetChunks, ReadOnlyList&lt;WorldCell&gt; cellsChunksBelongsTo)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldGroupingListener">
            <summary>
            Provides a base implementation for components that wish to implement the 
            <see cref="T:DeepSpaceLabs.SAM.IWorldGroupingListener" href="IWorldGroupingListener.html">IWorldGroupingListener</see> interface.
            <para>
            World Grouping Listeners can be assigned to a World Grouping in order to receive notification before or after the 
            World Grouping is updated, and also before/after World Cells on the World Grouping are 
            activated and/or deactivated. Previously, this behaviour 
            was achieved via Cell Actions attached to the individual Asset Chunks of a cell, however this system was cumbersome as 
            it required you to attach a component to each 
            chunk game object.
            </para>
            <para>
            The new system utilizes one or more components at the World Grouping level to perform actions on a 
            collection of cells at a time. You can also utilize this system to keep 
            track of what cells are currently active, by adding the cells from one of the 'Activated' methods and removing them 
            from one of the 'Deactivated' methods.
            </para>
            <para>
            The most useful situation I can think of for doing this when trying to add integration for 3rd party assets.
            </para>
            <para>
            If a method you want to use does not need to utilize multiple frames, override the method and place the 
            code you want executed as normal, then return 
            SimpleYieldBreakEquivalentEnumerator.Instance. This will ensure no garbage is generated when the method is called.
            </para>
            </summary>
            <title>WorldGroupingListener Abstract Class</title>
            <category>World Grouping Listeners</category>
            <navigationName>WorldGroupingListener</navigationName>
            <fileName>WorldGroupingListener.html</fileName>
            <syntax>public abstract class WorldGroupingListener : MonoBehaviour, <see cref="T:DeepSpaceLabs.SAM.IWorldGroupingListener" href="IWorldGroupingListener.html">IWorldGroupingListener</see></syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.IsEnabled">
            <summary>
            Whether the listener is currently enabled. Its methods will only be called if it is enabled.
            <para>
            The default behaviour is to return false if the game object the listener is attached to's activeInHierarchy value is false or 
            the scripts enabled property is false. Otherwise it returns true. You can override this behaviour if you'd like, though this 
            default behaviour makes it possible to disable the listener in the inspector without having to modify the list of 
            World Grouping listeners on the World Grouping.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions">
            <summary>
            Gets a value indicating whether the listener's methods will be called during LOD transitions. When an LOD transition occurs, technically a World Cell is 
            deactivated (the old LOD) and a World Cell is activated (the new LOD), however generally it is better to think of these two World Cells as the same Cell 
            that is just changing its Asset Chunks out. With that said, a lot of logic may be directed at the World Cell's Asset Chunks, and if that is the case with 
            your WorldGroupingListener, you should set this property to return false, because the Asset Chunks will change during an LOD transition. The actuall WorldCell 
            object instance will also change, so if you're storing these WorldCell objects in some way, you will also need to set this to false so that you can remove 
            the old World Cells and add the new ones.\n\nIf, on the other hand, your WorldGroupingListeners only utilize data related to the World Cell's 
            (such as position, Streamable Grid Indexes, etc.), this data will not change during an LOD Transition, so you can ignore them.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.YieldBehaviorAfterMethodExecution">
            <summary>
            Gets a value that tells the World the Listener is being used with whether it should 
            yield control (to the Unity Engine and other components your game might have), after fully executing one of its methods. 
            <para>
            The options in the ListenerYieldBehaviour enumerator give you a great 
            deal of control.
            </para>
            <para>
            NeverYield can be chosen if you need to ensure that the next Listener to run runs immediately after this one finishes.
            </para>
            <para>
            AlwaysYield, on the other hand, can be used to force the World to yield for at least a frame, which might be necessary to 
            allow whatever code you've just run to "ferment".
            </para>
            <para>
            Finally, YieldOrContinue can be used if you don't really care one way or the other 
            whether the World yields control, as it will let the Execution Controller used by the World decide.
            </para>
            </summary>
            <type link="ListenerYieldBehaviour.html">ListenerYieldBehaviour</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnBeforeAnyCellsDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeAnyCellsDeactivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnBeforeCellsInBatchDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeCellsInBatchDeactivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnAfterCellsInBatchDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterCellsInBatchDeactivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnAfterAllCellsDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterAllCellsDeactivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnBeforeAnyCellsActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeAnyCellsActivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnBeforeCellsInBatchActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeCellsInBatchActivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnAfterCellsInBatchActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterCellsInBatchActivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnAfterAllCellsActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterAllCellsActivated method. Please note, when deriving from WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnBeforeGroupingUpdated">
            <summary>
            Returns a value indicating whether the World Grouping this WorldGroupingListener is linked to should call the 
            OnBeforeGroupingUpdated method. Please note, it is not necessary to 
            worry about this property. All you need to do is override the OnBeforeGroupingUpdated method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            OnBeforeGroupingUpdated is useful because it is called regardless of whether any cells will be activated or deactivated for the 
            given World Grouping. Therefore, you can use it to perform logic that is not dependent on cells being specifically activated or deactivated. 
            If your logic is dependent on activated or deactivated cells being present, use the OnBeforeAnyCellsActivated or 
            OnBeforeAnyCellsDeactivated methods instead, utilizing the batchNumber and totalBatchesToExpect to find the last call to the method 
            and performing the logic their, so it is only performed once.
            </para>
            <para>
            Note the method is called regardless of the IgnoreLODTransitions properties value, so long as it is overriden.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListener.CallOnAfterGroupingUpdated">
            <summary>
            Returns a value indicating whether the World Grouping this WorldGroupingListener is linked to should call the 
            OnAfterGroupingUpdated method. Please note, it is not necessary to 
            worry about this property. All you need to do is override the OnAfterGroupingUpdated method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            OnAfterGroupingUpdated is useful because it is called regardless of whether any cells have been activated or deactivated for the 
            given World Grouping. Therefore, you can use it to perform logic that is not dependent on cells being specifically activated or deactivated. 
            If your logic is dependent on activated or deactivated cells being present, use the OnAfterAllCellsActivated or 
            OnAfterAllCellsDeactivated methods instead, utilizing the batchNumber and totalBatchesToExpect to find the last call to the method 
            and performing the logic their, so it is only performed once.
            </para>
            <para>
            Note the method is called regardless of the IgnoreLODTransitions properties value, so long as it is overriden.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.Start">
            <summary>
            This is implemented solely so that the Listener will have the enabled toggle exposed in the inspector.
            <para>
            You can override this method if you need to run code in Start.
            </para>
            </summary>
            <displayName id="Start">
            Start()
            </displayName>
            <syntax>
            protected virtual void Start()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.DetermineMethodCalls">
            <summary>
            Computes the values of the the Call... properties 
            (CallOnBeforeGroupingUpdated, CallOnBeforeAnyCellsDeactivated, etc.) based on whether 
            each method corresponding to each property has been overriden in your derived class.
            </summary>
            <displayName id="DetermineMethodCalls">
            DetermineMethodCalls()
            </displayName>
            <syntax>
            public void DetermineMethodCalls()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.PrecomputeUseWithLODValues">
            <summary>
            Precomputes data used by the 
            <see cref="M:DeepSpaceLabs.SAM.WorldGroupingListener.UseWithLOD(System.Int32)" href="#UseWithLOD">UseWithLOD</see> method, based on the LOD Filter.
            <para>
            You cannot override this method, as the WorldGroupingListener requires that the LOD Filter based criteria be setup.
            </para>
            <para>
            However, if you have overriden the UseWithLOD method and need to precompute other data unrelated to the LOD Filter, you can 
            override the 
            <see cref="M:DeepSpaceLabs.SAM.WorldGroupingListener.PrecomputeUseWithLODValues_Extended" href="#PrecomputeUseWithLODValues_Extended">PrecomputeUseWithLODValues_Extended</see> 
            method instead, which is called automatically by this method.
            </para>
            </summary>
            <displayName id="PrecomputeUseWithLODValues">
            PrecomputeUseWithLODValues()
            </displayName>
            <syntax>
            public void PrecomputeUseWithLODValues()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.PrecomputeUseWithLODValues_Extended">
            <summary>
            Can be overriden to precompute additional data for use with a custom implementation of the  
            <see cref="M:DeepSpaceLabs.SAM.WorldGroupingListener.UseWithLOD(System.Int32)" href="#UseWithLOD">UseWithLOD</see> method.
            <para>
            Remeber that the LOD Filter based criteria is always configured and can be queried using 
            base.UseWithLOD, even if you override the UseWithLOD method. This allows you to add additional criteria 
            on top of the existing LOD Filter based criteria.
            </para>
            <para>
            This method is gauranteed to only be called once, so you do not need to provide safeguards to ensure your 
            logic only runs once.
            </para>
            </summary>
            <displayName id="PrecomputeUseWithLODValues_Extended">
            PrecomputeUseWithLODValues_Extended()
            </displayName>
            <syntax>
            protected virtual void PrecomputeUseWithLODValues_Extended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.UseWithLOD(System.Int32)">
            <summary>
            This method is queried before any of the methods that use cells are called, to determine if that method should be 
            invoked for the current group of cells, given the active LOD of those cells (remember, all cells in a batch 
            are always gauranteed to have the same active LOD).
            <para>
            It is virtually implemented to return a value based on the LOD Filter configured in the Listener's 
            inspector. You can override it to ignore the LOD Filter in favor of a custom system for determining per LOD use, or 
            to add additional criteria on top of the LOD Filter (in which case, you can use base.UseWithLOD 
            to get the default value the method would have returned if only using the LOD Filter).
            </para>
            <para>
            The value returned by this method is not cached. Each time one of the methods would be called, the method is called.
            </para>
            <para>
            This gives you a great deal of freedom, as you can adjust which LODs the Listener is being used with on the fly at runtime.
            </para>
            <para>
            However, if you know that the LODs that the Listener is being used will not change at runtime, and the computation 
            used to determine if an LOD should be used by the Listener is expensive, you should cache the computed value for each 
            LOD and use that when the method is called. Typically, should do this in AwakeExtended, so that the cached values can be used 
            as early as Start.
            </para>
            <para>
            The value is applied universally across all method calls that use cells (OnBeforeAnyCellsDeactivated, OnBeforeCellsInBatchDeactivated, 
            etc.). If you use more than 1 of these methods and need to use different criteria for determining LOD use for each one, 
            you should return true when UseWithLOD is called and instead filter each LOD within the actual methods that process the cells.
            </para>
            </summary>
            <param name="LOD" type="int">
            The active LOD of the World Cells that one of the methods (OnBeforeAnyCellsDeactivated, 
            OnBeforeCellsInBatchDeactivated, etc.) is about to be invoked for.
            <para>
            This value is 1 based, such that the first (highest quality) LOD is 1.
            </para>
            </param>
            <returns type="type">
            Return true if you want the method (OnBeforeAnyCellsDeactivated, OnBeforeCellsInBatchDeactivated, 
            etc.) to be called for the World Cells of the LOD, or false otherwise.
            </returns>
            <displayName id="UseWithLOD">
            UseWithLOD(int)
            </displayName>
            <syntax>
            bool UseWithLOD(int LOD)
            </syntax>
            <exception name="ExceptionName">
            Description
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnGroupingLinkEstablished(DeepSpaceLabs.SAM.World,System.Int32,System.Int32)">
            <summary>
            Called by the World when a Zone Grouping is linked to a World Grouping Listener.
            <para>
            This can be used to verify configuration settings or perform one time setup for the World and 
            grouping, rather than placing this setup code in the other On... methods which is less efficient.
            </para>
            <para>
            By default the method does nothing; override to implement logic that only needs to run once for the Grouping.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The World the Grouping belongs to.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the Zone Groupings whose link was established.
            </param>
             <param name="groupingIndex" type="int">
            The index of the grouping associated with the Zone Grouping whose link was established.
            </param>
            <displayName id="OnGroupingLinkEstablished">
            OnGroupingLinkEstablished(World, int, int)
            </displayName>
            <syntax>
            public virtual void OnGroupingLinkEstablished(World world, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnGroupingLinkRemoved(DeepSpaceLabs.SAM.World,System.Int32,System.Int32)">
            <summary>
            Called by the World when a Zone Grouping link to a World Grouping Listener is removed. This occurs when the World Grouping Listener 
            is removed using the World's RemoveWorldGroupingListener method or if the World is destroyed.
            <para>
            This can be used to cleanup data that was created in the OnGroupingLinkEstablished method.
            </para>
            <para>
            By default the method does nothing; override to implement logic that only needs to run once for the Grouping.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The World the Grouping belongs to.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the Zone Groupings whose link was removed.
            </param>
            <param name="groupingIndex" type="int">
            The index of the grouping associated with the Zone Grouping whose link was removed.
            </param>
            <displayName id="OnGroupingLinkRemoved">
            OnGroupingLinkRemoved(World, int, int)
            </displayName>
            <syntax>
            public virtual void OnGroupingLinkRemoved(World world, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnBeforeAnyCellsDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called before any cells have been deactivated during the current World Grouping Update, 
            for all cells that the World determines need to be removed/deactivated completely, and also for cells which are being 
            removed/deactivated as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that. This method is also called before duplicating a world, before the duplication process begins, with the 
            input cells being the old cells which are about to be duplicated.
            <para>
            Each of the OnCells...Deactivated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors assigned, and the neighbors Asset Chunks will be in an ACTIVATED state.
            </para>
            <para>
            This method is ideal for situations where you need to perform neigbor related cell specific actions that are not time sensitive, since the 
            actual deactivation of the cells will take place some frames after this method is called.
            </para>
            <para>
            In addition, you SHOULD USE this method for removing World Cells or World Cell related data from an internal collection 
            such as a Dictionary.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which will be deactivated in a short amount of time.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeAnyCellsDeactivated">
            OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnBeforeCellsInBatchDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called right before a batch of cells is set to be deactivated during the current World Update (deactivation 
            involves transitioning the cells to a non visible state, removing them from any HierarchyOrganizers, and removing them 
            from the internal collection of World Cells so that they are no longer "part" of the Streamable World Grouping they were a part of), 
            for all cells that the World determines need to be deactivated completely, and also for cells which are being 
            deactivated as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Removed methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors assigned, however the state of the neighbors cannot be predicted, since this 
            method may be called before or after other cells that are to be removed have been deactivated. For example, one of its neighbors 
            may be a cell that will be LOD transitioned, so while currently its neighbor is a cell with LOD 1, once all LOD transitions are 
            processed, its new neighbor might be the same cell but of LOD 2. Or in another example, a neighbor may be not present currently, 
            but after adding new cells, may become present. As such, it is not recommended to carry out any neighbor based logic here. Use the 
            OnBeforeAnyCellsDeactivated method instead!
            </para>
            <para>
            Situations where you need to perform non neighbor related cell specific actions right before a Cell is deactivated. However, do note that there 
            will likely be a small delay between this method being called and the actual deactivation of the batch of Cell's Asset Chunks. If you need very 
            precise timing, you should disable Auto Deactivate Chunks When Removing Cells and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> where you 
            perform the necessary logic just before you make the Cell's Asset Chunks Invisible.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which are just about to be deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeCellsInBatchDeactivated">
            OnBeforeCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnAfterCellsInBatchDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called right after a batch of cells has been deactivated during the current World Update (deactivation 
            involves transitioning the cells to a non visible state, removing them from any HierarchyOrganizers, and removing them 
            from the internal collection of World Cells so that they are no longer "part" of the Streamable World Grouping they were a part of), 
            for all cells that the World determined need to be deactivated completely, and also for cells which are being 
            deactivated as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Removed methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an DEACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors assigned, however the state of the neighbors cannot be predicted, since this 
            method may be called before or after other cells that are to be removed have been deactivated. For example, one of its neighbors 
            may be a cell that will be LOD transitioned, so while currently its neighbor is a cell with LOD 1, once all LOD transitions are 
            processed, its new neighbor might be the same cell but of LOD 2. Or in another example, a neighbor may be not present currently, 
            but after adding new cells, may become present. As such, it is not recommended to carry out any neighbor based logic here. Use the 
            OnBeforeAnyCellsDeactivated method instead!
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right before a Cell is deactivated. 
            However, do note that there will likely be a small delay between this method being called and the actual deactivation of the batch of Cell's Asset Chunks. 
            If you need very precise timing, you should disable <b>Auto Deactivate Chunks When Removing Cells</b> and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            where you perform the necessary logic just before you make the Cell's Asset Chunks Invisible and deactivate them.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have just been deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterCellsInBatchDeactivated">
            OnAfterCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnAfterAllCellsDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called after every cell on a World Grouping that the World has determined needs to be deactivated, has been deactivated for 
            a given World Update (deactivation involves transitioning the cells to a non visible state, removing them from any 
            HierarchyOrganizers, and removing them from the internal collection of World Cells so that they are no longer "part" of 
            the Streamable World Grouping they were a part of), for all cells that the World determined needed to be deactivated completely, 
            and also for cells which were deactivated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Deactivated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL NOT have its own Asset Chunks present.
            3) Each World Cell in the batch WILL NOT have cell neighbors assigned.
            </para>
            <para>
            Based on the gaurantees listed, hopefully you can see that this method is the most limited of the OnCells...Deactivated methods. No 
            Asset Chunks or neighbors are present, so this method is only suitable if you need to perform non chunk related operations after all 
            cells that are going to be deactivated have been deactivated in the current World Update.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsDeactivated">
            OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnBeforeAnyCellsActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called before any cells have been activated during the current World Grouping Update, 
            for all cells that the World determines need to be newly activated, and also for cells which are being 
            activated as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL NOT have its own Asset Chunks present.
            3) Each World Cell in the batch WILL NOT have cell neighbors assigned.
            </para>
            <para>
            This method is ideal for situations where you need to perform non chunk, neigbor related, cell specific 
            actions that are not time sensitive, since the 
            actual activation of the cells will take place some frames after this method is called.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which will be activated in a short time.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeAnyCellsActivated">
            OnBeforeAnyCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeAnyCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnBeforeCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called just before a batch of cells will be activated (activation involves transitioning 
            the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determines need to be newly activated, 
            and also for cells which are activated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in a DEACTIVATED state.
            3) Each World Cell in the batch WILL NOT have cell neighbors assigned.
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right before a Cell is activated. Do note, 
            however, that there will likely be a delay between this method being called and the actual activation of the batch of Cell's Asset Chunks. If you need very 
            precise timing, you should disable <b>Auto Activate Chunks When Adding Cells</b> and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            where you perform the necessary logic just before you activate and make the Cell's Asset Chunks Visible.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which are just about to be activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeCellsInBatchActivated">
            OnBeforeCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnAfterCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called just after a batch of cells have been activated (activation involves transitioning 
            the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determined needed to be newly activated, 
            and also for cells which were activated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors assigned, and any non LOD related data of the neighbors can be considered 
            accurate. However the state of the neighbor Asset Chunks is not predictable, and the neighbor may be replaced by different cells if 
            the neighbor is undergoing an LOD transition (though do note, the neighbor is gauranteed to not be null in the future of the current 
            World Update, since the deactivation of cells which need to be completely removed is performed prior to this method being called 
            for the first time.
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right after a Cell is activated. 
            Do note, however, that there will likely be a delay between the actual activation of the batch of Cell's Asset Chunks and this method being called. I
            f you need very precise timing, you should disable <b>Auto Activate Chunks When Adding Cells</b> and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            where you perform the necessary logic just after you activate and make the Cell's Asset Chunks Visible.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have just been activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterCellsInBatchActivated">
            OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnAfterAllCellsActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called after every cell on a World Grouping that the World has determined needs to be activated, have been activated for 
            a given World Update (activation involves transitioning the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determined needed to be newly activated, 
            and also for cells which were activated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors set, and the Asset Chunks of the cell neighbors will be in an ACTIVATED state. Please 
            note, there is no gaurantee that a cell will have a neighbor, as if its on the edge of the world or next to an empty Streamable Grid Cell, 
            there may be no World Cell to serve as its neighbor.
            </para>
            <para>
            This method is well suited for neighbor related logic where you want a gaurantee that the cell neighbors will be present (if they exist) 
            and accurate (all neighbors will be true neighbors, and not possibly LOD cells that are in the process of transitioning, or cells which 
            will be deactivated; i.e., neighbors which will be nulled out or replaced in the future of this World Grouping Update).
            </para>
            <para>
            In addition, you SHOULD USE this method for adding World Cells or World Cell related data to an internal collection 
            such as a Dictionary.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsActivated">
            OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnBeforeGroupingUpdated(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called before a Zone Grouping is updated, regardless of whether cells will actually 
            be changed on the Grouping (because remember, all Groupings are updated during a Word update, regardless of 
            whether there are changes on that grouping!).
            <para>
            Because this method is not dependent on activated or deactivated cells 
            being present, it does not have any input WorldCell's, unlike 
            the other methods. This also means that the method is only called once per World Grouping Listener per World Grouping update.
            </para>
            <para>
            The method is also called when the Component Manager is initialized with two frame 
            initialization (for example, if it's Initialize On Awake option is enabled) 
            before the initial starting cell users are added/activated on a World Grouping. Again, this occurs regardless 
            of whether that World Grouping actually has starting cells. In these instances, immediate mode will be true.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world whose World Grouping is about to be updated.
            </param>
             <param name="zoneIndex" type="int">
            The index of the Zone associated with the cells which have been update. This is useful if using multiple Zones.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping associated with the cells which have been updated. This is useful if using the listener with 
            multiple World Groupings.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeGroupingUpdated">
            OnBeforeGroupingUpdated(World, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnBeforeGroupingUpdated(World world, int zoneIndex, int groupingIndex, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListener.OnAfterGroupingUpdated(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called after a Zone Grouping has been updated, regardless of whether cells have actually 
            been changed on the Grouping (because remember, all Groupings are updated during a Word update, regardless of 
            whether there are changes on that grouping!).
            <para>
            Because this method is not dependent on activated or deactivated cells 
            being present, it does not have any input WorldCell's, unlike 
            the other methods. This also means that the method is only called once per World Grouping Listener per World Grouping update.
            </para>
            <para>
            The method is also called when the Component Manager is initialized with two frame 
            initialization (for example, if it's Initialize On Awake option is enabled) 
            after the initial starting cell users are added/activated on a World Grouping. Again, this occurs regardless 
            of whether that World Grouping actually has starting cells. In these instances, immediate mode will be true.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world whose World Grouping has just been updated.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the cells which have been update. This is useful if using multiple Zones.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping associated with the cells which have been updated. This is useful if using the listener with 
            multiple World Groupings.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterGroupingUpdated">
            OnAfterGroupingUpdated(World, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterGroupingUpdated(World world, int zoneIndex, int groupingIndex, bool immediateMode)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkReuseJudge">
            <summary>
            A MonoBehaviour you can derive from to implement custom logic for determing whether chunks associated with a 
            particular Streamable Grid Cell can be reused by a 
            <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> using a second Streamable Grid Cell (which might be the same or different 
            than the first Streamable Grid Cell).
            <para>
            <em>By default</em>, the Streamable Assets Manager only reuses objects from one World Cell on another World Cell when the two World Cell's have matching 
            Streamable Grid Cell indexes. In some cases however, such as when using the same game object for every Streamable Grid Cell on the 
            <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see>, 
            you may want to utilize alternative logic (for instance in that example case, since all Streamable Grid Cells use the same objects, 
            you could return true for every Compare test).
            </para>
            <para>
            The instance of your ChunkReuseJudge in the scene must be linked to a <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">Chunk Manager</see> in order to 
            be used. If no ChunkReuseJudge is provided, the default logic as described above will be used.
            </para>
            <para>
            Please note that the judgement logic is only run for World Cells on the same World Grouping and LOD. World Cells 
            on different LOD's or World Groupings will never reuse game objects between each other. In addition, the default 
            <see cref="T:DeepSpaceLabs.SAM.PoolingChunkManager" href="PoolingChunkManager.html">Pooling Chunk Manager</see> and any other classes derived from it do not utilize the Cell 
            Object Reuse Judge in their pooling logic. You will need to create a Chunk Manager 
            that does not derive from the Pooling class in order to make use of the reuse judge.
            </para>
            </summary>
            <title>
            ChunkReuseJudge Class
            </title>
            <category>Chunk Reuse Judges</category>
            <navigationName>
            ChunkReuseJudge
            </navigationName>
            <fileName>ChunkReuseJudge.html</fileName>
            <syntax>
            public class ChunkReuseJudge : MonoBehaviour
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkReuseJudge.JudgementDelegate">
            <summary>
            A delegate which you need to use to implement the logic. The delegate construct is used in order to allow the 
            logic to be used in a Job, which provides speedier performance. This is also why the arguments are the Streamable Grid 
            <see cref="T:DeepSpaceLabs.SAM.Cell" href="Cell.html">Cell's</see> associated with each World Cell, and not the World Cell's themselves.
            <para>
            The logic is queried internally by each World Grouping when it is transitioning or activating new cells. The objects from 
            World Cells that have already been deactivated will provide the cellThatHasChunks input, and the World Cells to be 
            activated will provide the cellThatNeedsChunks input.
            </para>
            <para>
            Do note that only World Cells on the same World Grouping and LOD are queried. World Cells on different World Groupings or LOD's never 
            reuse game objects between them.
            </para>
            </summary>
            <param name="cellThatHasChunks" type="Cell" link="Cell.html">The Streamable Grid Cell index associated chunks that may be reusable.</param>
            <param name="cellThatNeedsChunks" type="Cell" link="Cell.html">The Streamable Grid Cell index associated with the World Cell that needs chunks.</param>
            <returns type="bool">
            Must return true if the objects associated with cellThatHasChunks should be reused by the World Cell associated with 
            cellThatNeedsChunks. False otherwise.
            </returns>
            <displayName id="JudgementDelegate">JudgementDelegate(Cell, Cell)</displayName>
            <syntax>public delegate bool JudgementDelegate(Cell cellThatHasChunks, Cell cellThatNeedsChunks)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkReuseJudge.GetJudgementLogic">
            <summary>
            Gets the custom logic for performing judgements between two Streamable Grid Cell's in order to determine reuse eligibility.
            </summary>
            <returns type="JudgementDelegate" link="#JudgementDelegate">
            The logic of the judge. This must be in the form of JudgementDelegate.
            </returns>
            <displayName id="GetJudgementLogic">
            GetJudgementLogic()
            </displayName>
            <syntax>
            public abstract <see href="#JudgementDelegate">JudgementDelegate</see> GetJudgementLogic()
            </syntax>
            
        </member>
        <member name="T:DeepSpaceLabs.SAM.ReuseAllChunksReuseJudge">
            <summary>
            An implementation of a ChunkReuseJudge that returns a 
            <see cref="T:DeepSpaceLabs.SAM.ChunkReuseJudge.JudgementDelegate" href="ChunkReuseJudge.html#JudgementDelegate">JudgementDelegate</see> 
            object which returns true for all inputs. 
            You can add this component to your scene, then assign it to the appropriate field on a 
            <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">Chunk Manager</see>, 
            in order to force a <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see> to reuse game objects between all 
            <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cells</see> on a given World Grouping and LOD.
            <para>
            The result will be that all World Cell's reuse game objects with other World Cell's on a World Grouping and LOD. 
            Note that chunks are never reused between World Cell's on different World Grouping's or LODs.
            </para>
            </summary>
            <title>
            ReuseAllChunkReuseJudge Class
            </title>
            <category>Chunk Reuse Judges</category>
            <navigationName>
            ReuseAllChunkReuseJudge
            </navigationName>
            <fileName>ReuseAllChunkReuseJudge.html</fileName>
            <syntax>
            public class ReuseAllChunkReuseJudge : <see cref="T:DeepSpaceLabs.SAM.ChunkReuseJudge" href="ChunkReuseJudge.html">ChunkReuseJudge</see>
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ReuseAllChunksReuseJudge.GetJudgementLogic">
            <summary>
            Gets judgement logic that just returns true for any inputs. This results in all World Cells reusing the chunks 
            of any other World Cell on the World Grouping and LOD. Therefore, this 
            <see cref="T:DeepSpaceLabs.SAM.ChunkReuseJudge" href="ChunkReuseJudge.html">ChunkReuseJudge</see> should only 
            be used when using the same game object for every Streamable Grid Cell on a given World Grouping and LOD.
            </summary>
            <returns type="JudgementDelegate" link="ChunkReuseJudge.html#JudgementDelegate">
            The judgement delegate logic.
            </returns>
            <displayName id="GetJudgementLogic" link="ChunkReuseJudge.html#JudgementDelegate">
            GetJudgementLogic()
            </displayName>
            <syntax>
            public sealed override <see href="ChunkReuseJudge.html#JudgementDelegate">JudgementDelegate</see> GetJudgementLogic()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.DistancePoolingChunkManager">
            <summary>
            Provides an implementation for a 
            <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">Chunk Manager</see> that deactivates chunks when they are not in 
            use until the cells those objects belong to are a specified distance from the active cell the player is in (at which time 
            they are destroyed).
            <para>
            Note, the operation that checks for obsolete objects is run on a coroutine separate from the 
            <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see>, therefore it will not respect the World's 
            <see cref="T:DeepSpaceLabs.SAM.ExecutionController" href="ExecutionController.html">Execution Controller</see>.
            </para>
            <para>
            This component is usable with  
            both Game Objects and non Game Object Chunks, however there are certain methods of the Chunk Manager class 
            that are by default configured to work with Game Objects. Those methods include:
            </para>
            <para>
            GetChunkPosition - For retrieving the Vector3Double position of a chunk. Only called if the LOD using this manager has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkPosition - For setting the chunk position to a Vector3Double value. Only called if the LOD using this manager has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkActiveState - For setting the state of the chunk to active or deactive. This method is called only if Auto Activate/Deactivate 
            Cell Chunks is enabled in your World inspector, for any LODs that use this manager.
            </para>
            <para>
            If you anticipate any of these methods being called, you will need to create a custom class deriving from this one, and in that class override 
            the methods that will be called, so that they function correctly with your custom chunks.
            </para>
            </summary>
            <title>DistancePoolingChunkManager Class</title>
            <category>Chunk Managers</category>
            <navigationName>DistancePoolingChunkManager</navigationName>
            <fileName>DistancePoolingChunkManager.html</fileName>
            <syntax>
            public sealed class DistancePoolingChunkManager : 
            <see cref="T:DeepSpaceLabs.SAM.PoolingChunkManager" href="PoolingChunkManager.html">PoolingChunkManager</see>
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DistancePoolingChunkManager.AwakeExtended">
            <summary>
            Used to perform some initialization.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DistancePoolingChunkManager.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32)">
            <summary>
            Creates a new DistanceBasedPoolingChunkManagerUser, which is a custom type which derives 
            from ChunkManagerUser. This user object contains an object pool 
            used specifically by this class.
            </summary>
            <param name="zoneGrouping" type="IZoneGrouping" link="IZoneGrouping.html">
            The Zone Grouping being registered.
            </param>
            <param name="chunkStreamerUserID" type="int">When the zoneGrouping registered with the manager, the manager automatically registered the 
            zoneGrouping with the Chunk Streamer associated with it. This is the user ID assigned to the zoneGrouping by that Chunk Streamer.
            </param>
            <displayName id = "CreateNewUser">CreateNewUser(IZoneGrouping, int)</displayName>
            <syntax>protected sealed override ChunkManagerUser CreateNewUser(IZoneGrouping zoneGrouping, int chunkStreamerUserID)</syntax>
            <returns type = "ChunkManagerUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DistancePoolingChunkManager.OnUserDeRegistered(DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Unsubscribes the user from On Cell Player Is In Changed events.
            </summary>
            <param name="user" type="ChunkManagerUser">
            The user that was just de-registered
            </param>
            <displayName id="OnUserDeRegistered">
            OnUserDeRegistered(ChunkManagerUser)
            </displayName>
            <syntax>
            protected sealed override void OnUserDeRegistered(ChunkManagerUser user)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DistancePoolingChunkManager.ShouldAddChunkSetToPool(DeepSpaceLabs.SAM.WorldCell,DeepSpaceLabs.SAM.PoolingChunkManager.PoolingChunkManagerUser)">
            <summary>
            Checks the distance of the cell from the cell the player is in. If the distance is greater than that defined in the 
            inspector, the cells chunks will not be added to the pool. If it is within distance, they will be added if there 
            is room in the pool. The cell will also be added to a list of cells which are distance checked whenever the cell 
            the player is in changes. If the cell ever becomes too far from the cell the player is in, it will be removed from this 
            list and the pool that stores chunks associated with that cell will be emptied if needed. Note that multiple endless 
            grid cells can make use of the same chunks if they use the same Streamable Grid Cell. In these cases, a pool may not be 
            emptied, as there may be other cells still within distance that might need them in the future.
            </summary>
            <param name="cell" type = "WorldCell" link="WorldCell.html">
            The cell which needs to be processed.
            </param>
            <param name="userCellBelongsTo" type = "PoolingChunkManagerUser">
            The user this cell belongs to.
            </param>
            <displayName id = "ProcessDeactivatedCell">
            ProcessDeactivatedCell(WorldCell, PoolingChunkManagerUser)
            </displayName>
            <syntax>
            public sealed override void ProcessDeactivatedCell(WorldCell cell, PoolingChunkManagerUser userCellBelongsTo)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.FrameRateDependentExecutionController">
            <summary>
            An Exeuction Controller which uses the time the Current frame has run for to determine whether 
            execution should start or continue.
            <para>
            Note that once execution starts, it's possible the component using the Execution Controller will execute for longer 
            than strictly allowed. This is because some operations may have fixed time costs, and the execution controller 
            is only queried between operations. Usually the amount of time it goes over will be small.
            </para>
            <para>
            If using multiple Worlds at the same time, each World must use a different instance of the Execution Controller!
            </para>
            </summary>
            <title>
            FrameRateDependentExecutionController Class
            </title>
            <category>Execution Controllers</category>
            <navigationName>
            FrameRateDependentExecutionController
            </navigationName>
            <fileName>FrameRateDependentExecutionController.html</fileName>
            <syntax>
            public sealed class FrameRateDependentExecutionController : <see cref="T:DeepSpaceLabs.SAM.ExecutionController" href="ExecutionController.html">ExecutionController</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.FrameRateDependentExecutionController.FrameTimeLimit">
            <summary>
            Gets or sets the frame time limit. The component that uses this execution controller will not be 
            allowed to execute if the amount of time the Current frame has taken is greater than this value. If 
            the component is already executing, then it will not be allowed to continue executing when a method queries 
            whether it should yield for a frame or continue, if the amount of time the Current frame has taken is 
            greater than this value.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.FrameRateDependentExecutionController.SuspensionFrameLimit">
            <summary>
            Gets or sets the suspension frame limit. This is used to avoid situations where the component that uses 
            the execution controller would never start executing because the frame time is always greater than the 
            Frame Time Limit. Once the component has been suspended for this number of frames, the next execution is 
            started no matter the frame time.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.FrameRateDependentExecutionController.ShouldStartExecuting">
            <summary>
            For every frame that the component which uses this execution controller is set to execute, this method will 
            be queried to determine whether the component should execute.
            </summary>
            <displayName id="ShouldStartExecuting">
            ShouldStartExecuting()
            </displayName>
            <syntax>
            public override bool ShouldStartExecuting()
            </syntax>
            <returns type="bool">
            Returns true if the components exuction has been restricted from starting for a number of frames 
            equal to <see cref="P:DeepSpaceLabs.SAM.FrameRateDependentExecutionController.SuspensionFrameLimit">SuspensionFrameLimit</see> 
            or if the Current frame has been running for less than 
            <see cref="P:DeepSpaceLabs.SAM.FrameRateDependentExecutionController.FrameTimeLimit">FrameTimeLimit</see>. Returns false otherwise.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.FrameRateDependentExecutionController.ShouldContinueExecuting">
            <summary>
            When the component which uses the execution controller wants to know whether it should yield for a frame or 
            continue executing, this method is queried.
            <para>
            Note there are a lot of methods that don't use this strategy, but instead need to always yield for a frame 
            or on some other property (WaitForSeconds for example).
            </para>
            </summary>
            <displayName id="ShouldContinueExecuting">
            ShouldContinueExecuting()
            </displayName>
            <syntax>
            public override bool ShouldContinueExecuting()
            </syntax>
            <returns type="bool">
            Returns true when the total time the Current frame has executed for is less than 
            <see cref="P:DeepSpaceLabs.SAM.FrameRateDependentExecutionController.FrameTimeLimit">FrameTimeLimit</see>.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController">
            <summary>
            An Exeuction Controller which uses the time the Current frame has run for to determine whether 
            execution should start. Once started, execution will continue for a pre-set time, set via the Time Slice setting.
            <para>
            This time slice is approximate. In some instances the component using the Execution Controller may need to yield 
            early or may exceed the time slice by a small amount.
            </para>
            <para>
            If using multiple Worlds at the same time, each World must use a different instance of the Execution Controller!
            </para>
            </summary>
            <title>
            FrameRateDependentTimeSlicedExecutionController Class
            </title>
            <category>Execution Controllers</category>
            <navigationName>
            FrameRateDependentTimeSlicedExecutionController
            </navigationName>
            <fileName>FrameRateDependentTimeSlicedExecutionController.html</fileName>
            <syntax>
            public sealed class FrameRateDependentTimeSlicedExecutionController : <see cref="T:DeepSpaceLabs.SAM.ExecutionController" href="ExecutionController.html">ExecutionController</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.ExecutionStartFrameTimeLimit">
            <summary>
            Gets or sets the execution start frame time limit. The component that uses this execution controller will not be 
            allowed to execute if the amount of time the Current frame has taken is greater than this value.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.SuspensionFrameLimit">
            <summary>
            Gets or sets the suspension frame limit. This is used to avoid situations where the component that uses 
            the execution controller would never start executing because the frame time is always greater than the 
            Frame Time Limit. Once the component has been suspended for this number of frames, the next execution is 
            started no matter the frame time.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.TimeSlice">
            <summary>
            The amount of time (in seconds) that the component that uses this execution controller can execute for (not guaranteed).
            </summary>
            <type>double</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.ShouldStartExecuting">
            <summary>
            For every frame that the component which uses this execution controller is set to execute, this method will 
            be queried to determine whether the component should execute.
            </summary>
            <returns type="bool">
            Returns true if the components exuction has been restricted from starting for a number of frames 
            equal to <see cref="P:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.SuspensionFrameLimit">SuspensionFrameLimit</see> 
            or if the Current frame has been running for less than 
            <see cref="P:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.ExecutionStartFrameTimeLimit">ExecutionStartFrameTimeLimit</see>. Returns false otherwise.
            </returns>
            <displayName id="ShouldStartExecuting">
            ShouldStartExecuting()
            </displayName>
            <syntax>
            public override bool ShouldStartExecuting()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.ShouldContinueExecuting">
            <summary>
            When the component which uses the execution controller wants to know whether it should yield for a frame or 
            continue executing, this method is queried.
            <para>
            Note there are a lot of methods that don't use this strategy, but instead need to always yield for a frame 
            or on some other property (WaitForSeconds for example).
            </para>
            </summary>
            <returns type="bool">
            Returns true when the component using this execution controller has run for less time than 
            <see cref="P:DeepSpaceLabs.SAM.FrameRateDependentTimeSlicedExecutionController.TimeSlice">TimeSlice</see>.
            </returns>
            <displayName id="ShouldContinueExecuting">
            ShouldContinueExecuting()
            </displayName>
            <syntax>
            public override bool ShouldContinueExecuting()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.FrameTimer">
            <summary>
            A script which monitors the current frame time. You can query this classes 
            FrameTimeInMilliseconds property to get a value which indicates how much time has 
            elapsed in the Current frame. This can be useful for running 
            heavy operations only when the frame time is under a certain threshold.
            </summary>
            <title>FrameTimer Class</title>
            <category>Secondary Components</category>
            <navigationName>FrameTimer</navigationName>
            <fileName>FrameTimer.html</fileName>
            <syntax>public class FrameTimer : MonoBehaviour</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.FrameTimer.FrameTimeInMilliseconds">
            <summary>
            The amount of time, in milliseconds, that the current frame has taken. Since this is a long, it's not accurate as using 
            CalculateExactFrameTimeInMilliseconds, but it is more performant.
            </summary>
            <type>long</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.FrameTimer.CalculateExactFrameTimeInMilliseconds">
            <summary>
            Calculates an exact frame time in milliseconds. Uses a double for more accurate reporting.
            </summary>
            <displayName id="CalculateExactFrameTimeInMilliseconds">
            CalculateExactFrameTimeInMilliseconds()
            </displayName>
            <syntax>
            public double CalculateExactFrameTimeInMilliseconds()
            </syntax>
            <returns type="double">
            The frame time in milliseconds.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SimpleYieldBreakEquivalentEnumerator">
            <summary>
            This is an implementation of an IEnumerator equivalent to a method that returns IEnumerator&lt;YieldInstruction&gt; with a single 
            yield break statement in the method body. Rather than using that construct, you can initilize an instance of this class once and then 
            simply return it in the method body, rather than using yield break (which will create a compiler generated class behind the scene, which 
            will be instantiated each time the method is called, generating garbage). Alternatively, because the class has no state and the MoveNext 
            simply returns false, I have provided a static 
            <see cref="P:DeepSpaceLabs.SAM.SimpleYieldBreakEquivalentEnumerator.Instance" href="SimpleYieldBreakEquivalentEnumerator.html#Instance">Instance</see> property which can be used to ensure only one instance of this class is 
            ever created.
            </summary>
            <title>
            SimpleYieldBreakEquivalentEnumerator Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>
            SimpleYieldBreakEquivalentEnumerator
            </navigationName>
            <fileName>SimpleYieldBreakEquivalentEnumerator.html</fileName>
            <syntax>
            public class SimpleYieldBreakEquivalentEnumerator : IEnumerator&lt;YieldInstruction&gt;
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SimpleYieldBreakEquivalentEnumerator.Instance">
            <summary>
            Gets an instance which of the SimpleYieldBreakEquivalentEnumerator which you can use freely across threads, scenes, whatever, at the same time as 
            any other caller using it.
            </summary>
            <type>SimpleYieldBreakEquivalentEnumerator</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SimpleYieldBreakEquivalentEnumerator.Current">
            <summary>
            Not implemented, as MoveNext will always return false and thus it should not be called.
            </summary>
            <type link="YieldInstruction.html">YieldInstruction</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SimpleYieldBreakEquivalentEnumerator.Dispose">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SimpleYieldBreakEquivalentEnumerator.MoveNext">
            <summary>
            Simply returns false every time it is called.
            </summary>
            <returns type="type">
            false alaways
            </returns>
            <displayName id="MoveNext">
            MoveNext()
            </displayName>
            <syntax>
            public bool MoveNext()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SimpleYieldBreakEquivalentEnumerator.Reset">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumerator">
            <summary>
            A custom implementation of IEnumerator&lt;YieldInstruction&gt; which you can derive from in order to implement 
            reusable enumerators. By default, when you have a method that returns IEnumerator (or IEnumerator&lt;YieldInstruction&gt; in our 
            case), with yield statements in the method body, the .Net compiler will auto generate a class behind the scenes that serves as a 
            state machine. When your method is called, this class is created anew, generating garbage.
            <para>
            As an alternative, you can create your own implementation of IEnumerator that can be reused, however the drawback is that you need 
            to implement all of the state machine logic yourself, as well as create the fields to store any arguments that are passed into the 
            original method. I cannot help with the former issue, however the YieldEnumerator and other generic alternatives of it provide 
            a means of taking care of some common coding necessities, such as the fields for storing the arguments and nulling out these fields 
            after the enumerator is finished.
            </para>
            <para>
            Note that you also need to ensure that the enumerator is only in use by one caller at a time. You can use the InUse property for this, as 
            it will be set to true when PrepareForIteration is called, and set to false once MoveNextImplementation returns false. Typically you 
            will run into this issue if using multiple Worlds, however you should take the issue into account and create a new enumerator if 
            your current enumerator is in use. The ClearFields and ResetImplementation methods are called automatically within the MoveNext 
            method once MoveNextImplementation returns false. The Reset method is not implemented.
            </para>
            <para>
            Every time the enumerator is called for, PrepareForIteration should be called to ensure correct functioning, whether the enumerator 
            is a reused object or a new object.
            </para>
            <para>
            Only a single YieldEnumerator class is shown here, however the DeepSpaceLabs.SAM namespace contains multiple generic YieldEnumerators. 
            The generic parameters should match the input parameters of your method that returns IEnumerator&lt;YieldInstruction&gt;. If you cannot find 
            a class that contains the generic parameters you need, you can create your own class that derives from YieldEnumerator. This class should
            have fields matching the method parameters your method takes as arguments, which you will need to set. You should also null out any 
            reference fields by implementing the NullRefFields method, which is called after once the MoveNextImplementation returns false.
            </para>
            <para>
            You will not be able to access the parent instance fields or methods from within MoveNextImplementation 
            using this as a base for your custom enumerator. If you need this 
            ability, please derive from the YieldEnumeratorWithParent (or one of its child generic classes) instead. When doing this, make sure 
            to assign the Parent property. If you are reusing the same enumerator with multiple parent different instances, you can assign the Parent 
            before the enumerator is used, and null it out in your NullRefFields method.
            </para>
            </summary>
            <title>
            YieldEnumerator Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>
            YieldEnumerator
            </navigationName>
            <fileName>YieldEnumerator.html</fileName>
            <syntax>
            public abstract class YieldEnumerator : IEnumerator&lt;YieldInstruction&gt;
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.YieldEnumerator.MoveNextCalls">
            <summary>
            How many times MoveNext has been called by whatever is using this enumerator, before the current MoveNext. 
            Will be 0 the first time MoveNext (and thus MoveNextImplementation) is called, then 1, then 2, and so on. The value is 
            also reset to 0 in the Reset method which will be called after SAM is finished using the enumerator, so that the next time it is 
            used, it will be 0 for the first call.
            <para>
            If your enumerator needs to simply iterate over a list or array, you can use this for the index, assuming you want to start processing 
            the list or array upon the first call to MoveNextImplementation.
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.YieldEnumerator.Phase">
            <summary>
            In general, enumerators make use of state machine logic, which operates in phases (Phase 1, do this, phase 2, do that, etc.). 
            This is a convenience property since most enumerators will use a phase, so this avoids you needing to type out a phase variable. 
            You do not need to use it. The Phase is reset to DefaultInitialPhase when PrepareForIteration is called, which is 1 unless 
            overriden. After that, you should set the phase yourself 
            in your MoveNextImplementation. By default the Phase will always start at 1, however you can override this behavour by 
            setting it to a different value in your PerformAdditionalIterationPreparation method.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.YieldEnumerator.InUse">
            <summary>
            Tells you whether this enumerator is in use by some caller.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.YieldEnumerator.Current">
            <summary>
            The current YieldInstruction. By default it is null, which wil yield for a single frame. If that suits your code, you don't need 
            to set it to anything else, however if you want to yield on a different time frame, set this value before returning true from your 
            MoveNextInternal method.
            </summary>
            <type link="YieldInstruction.html">YieldInstruction</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.Dispose">
            <summary>
            Not implemented
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.MoveNext">
            <summary>
            Iterates the enumerator, which first calls MoveNextImplementation, then increments MoveNextCalls, and finally calls 
            Resets the enumerator if MoveNextImplementation returned false (this sets InUse to false, MoveNextCalls to 0, and then 
            calls the ClearFields and ResetImplementation methods).
            </summary>
            <returns type="bool">
            True if the enumerator was advanced to the next Yield Statement (and thus there is more code to exeucte), 
            false if not. Current should only be called when this returns true. Once MoveNext returns false, as the caller you should not 
            use it again. Also note, Current will automatically be set to null once it returns false, so you don't have to. 
            </returns>
            <displayName id="MoveNext">
            MoveNext()
            </displayName>
            <syntax>
            public bool MoveNext()
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method has been called before PrepareForIteration is called.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.Reset">
            <summary>
            Can be used to reset the implementation in the case that it has not actually been used in the normal fashion (using MoveNext)
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.ResetImplementation">
            <summary>
            Called automatically by the base YieldEnumerator once MoveNextImplementation returns false. You don't have to to implement this; only 
            do so if you have some cleanup that needs to be performed outside of nulling reference fields. Note that nulling reference fields, 
            including the Parent if deriving from YieldEnumeratorWithParent, is done after this method is called, so you can still access 
            those fields to perform the reset if needed.
            </summary>
            <displayName id="ResetImplementation">
            ResetImplementation()
            </displayName>
            <syntax>
            public virtual void ResetImplementation(
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.NullRefFields">
            <summary>
            Called automatically once MoveNextImplementation returns false, you need only worry about implementing this method if 
            not deriving from one of the Generic implementations of YieldEnumerator and only when you have reference fields that should be 
            nulled out after the enumerator has finished iterating. Note, the method is implemented by the generic types, which is why you 
            don't need to worry about it if deriving from one of them. The generic types that have a Parent will also null out the parent, 
            which is why the PrepareForIteration method needs to pass in the Parent instance each call.
            <para>
            If you are deriving from one of the generics, any reference fields indicated by the type parameters will be nulled out 
            automatically (and also the Parent). Any addditional fields you want to null out should be nulled out in your ResetImplementation method.
            </para>
            <para>
            Also note that this method is called after ResetImplementation, so you can still access the references if needed in order to 
            perform the reset (although note this is unlikely).
            </para>
            </summary>
            <displayName id="NullRefFields">
            NullRefFields()
            </displayName>
            <syntax>
            public virtual void NullRefFields()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.MoveNextImplementation">
            <summary>
            Override to provide an actual implemntation of the MoveNext method, which advances the enumeration. 
            Under normal circumstances, you would put in here 
            whatever you would have put in the MoveNext method, however the MoveNext method is reserved to perform some additional actions.
            </summary>
            <returns type="bool">
            True if the enumerator was advanced to the next Yield Statement (and thus there is more code to exeucte), 
            false if not. Current should only be called when this returns true. Once MoveNext returns false, the caller you should not 
            use it again until calling the method that returned the enumerator again.
            </returns>
            <displayName id="MoveNextImplementation">
            MoveNextImplementation()
            </displayName>
            <syntax>
            public abstract bool MoveNextImplementation()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.PrepareForIteration">
            <summary>
            Prepares the enumerator for iteration. Should be called before returning the enumerator to whatever caller is going to 
            iterate over it. If you are deriving from YieldEnumerator or YieldEnumeratorWithParent directly, you should call this method 
            manually before returning the enumerator to the caller. This method will call PerformAdditionalIterationPreparation, so if you are 
            deriving from one of the generic YieldEnumerators, which calls PrepareForIteration automatically, and you need to 
            perform some sort of setup or initialization each time the enumerator is about to be used, override 
            PerformAdditionalIterationPreparation.
            <para>
            If you are deriving from one of the generic implementations of YieldEnumerator, do not call this method yourself, instead call 
            the PrepareForIteration method that uitilizes the generic types you are making use of as parameters.
            </para>
            <para>
            Also note that PerformAdditionalIterationPreparation is called before the DefaultInitialPhase is queried, so you can setup data that 
            manipulates the value of DefaultInitialPhase if you so choose.
            </para>
            </summary>
            <displayName id="PrepareForIteration">
            PrepareForIteration()
            </displayName>
            <syntax>
            public YieldEnumerator PrepareForIteration()
            </syntax>
            <returns>
            Returns itself, which is just intendend to make one line initialization and returns possible
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator.PerformAdditionalIterationPreparation">
            <summary>
            You can override this to perform additional initialization each time the enumerator will be used. When PrepareForIteration is called 
            (automatically when you are deriving from one of the generic YieldEnumerators and you call the PrepareForIteration method with 
            the arguments for your fields, or manually if not deriving from one of those but instead from YieldEnumerator or YieldEnumeratorWithParent 
            directly), this is called by it.
            </summary>
            <displayName id="PerformAdditionalIterationPreparation">
            PerformAdditionalIterationPreparation()
            </displayName>
            <syntax>
            public virtual void PerformAdditionalIterationPreparation()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct1`2">
            <summary>
            An implementation of YieldEnumerator that uses one reference type field and one value type field. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="R1">The type of the reference type</typeparam>
            <typeparam name="S1">The type of the value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct1`2.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct1`2.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct1`2.PrepareForIteration(`0,`1)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="r1">The first reference type type parameter</param>
            <param name="s1">The value type parameter</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct1`2.NullRefFields">
            <summary>
            nulls the reference type argumnets
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct2`3">
            <summary>
            An implementation of YieldEnumerator that uses one reference type field and two value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="R1">The type of the reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct2`3.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct2`3.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct2`3.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct2`3.PrepareForIteration(`0,`1,`2)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="r1">The first reference type type parameter</param>
            <param name="s1">The first value type parameter</param>
            <param name="s2">The second value type parameter</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumerator_Ref1_Struct2`3.NullRefFields">
            <summary>
            nulls the reference type argumnets
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent`1">
            <summary>
            This class is effectively the same as <see cref="T:DeepSpaceLabs.SAM.YieldEnumerator" href="YieldEnumerator.html">YieldEnumerator</see>, 
            except it includes a field to store the Parent of your custom enumerator. This 
            allows you to access the parent instance and any fields/methods it has from within the MoveNextImplementation method.
            <para>
            The type parameter P is the type of the parent which your custom class is created in. If you want to actually make use of this 
            parent (for accessing instance fields or methods within the MoveNextImplementation), 
            pass it into the PrepareForIteration method.
            </para>
            </summary>
            <title>
            YieldEnumeratorWithParent Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>
            YieldEnumeratorWithParent
            </navigationName>
            <fileName>YieldEnumeratorWithParent.html</fileName>
            <syntax>
            public abstract class YieldEnumeratorWithParent&lt;P&gt; : IEnumerator&lt;YieldInstruction&gt;
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.YieldEnumeratorWithParent`1.Parent">
            <summary>
            Gets the parent of your custom YieldEnumeratorWithParent class. Classes deriving from this one can and should null the 
            Parent in their NulRefFields method. There is no need to set the Parent, simply call PrepareForIteration that uses 
            a single P type parameter.
            </summary>
            <type>P</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent`1.PrepareForIteration(`0)">
            <summary>
            Prepares the enumerator for iteration by passing in the parent reference of the enumerator, so that it can be used 
            by the enumerator within it's PrepareForIteration or MoveNextImplementation methods.
            </summary>
            <param name="parent">The parent reference.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent`1.NullRefFields">
            <summary>
            Nulls the Parent reference and calls NullRefFieldsAdditional so that additional references can be 
            nulled in sub classes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent`1.NullAdditionalRefFields">
            <summary>
            Can be overriden in sub classes to null additional reference fields. If using one of the generic sub classes, 
            you don't need to implement this, as it is implemented already to null out the fields indicated by the generic 
            reference types.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators`1">
            <summary>
            A Yield Enumerator With Parent that makes iterating external enumerators easier.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`2">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the reference type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`2.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`2.PrepareForIteration(`0,`1)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type type to store</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`2.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`3">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses two reference type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`3.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`3.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`3.PrepareForIteration(`0,`1,`2)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`3.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`4">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses three reference type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="R3">The type of the third reference type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`4.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`4.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`4.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`4.PrepareForIteration(`0,`1,`2,`3)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`4.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`5">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses four reference type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="R3">The type of the third reference type</typeparam>
            <typeparam name="R4">The type of the fourth reference type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`5.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`5.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`5.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`5.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`5.PrepareForIteration(`0,`1,`2,`3,`4)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`5.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses five reference type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="R3">The type of the third reference type</typeparam>
            <typeparam name="R4">The type of the fourth reference type</typeparam>
            <typeparam name="R5">The type of the fifth reference type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6.r5">
            <summary>
            The fifth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator.
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <param name="r5">The fifth reference type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`6.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses six reference type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="R3">The type of the third reference type</typeparam>
            <typeparam name="R4">The type of the fourth reference type</typeparam>
            <typeparam name="R5">The type of the fifth reference type</typeparam>
            <typeparam name="R6">The type of the sixth reference type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.r5">
            <summary>
            The fifth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.r6">
            <summary>
            The sixth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator.
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <param name="r5">The fifth reference type arg</param>
            <param name="r6">The sixth reference type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_RefOnly`7.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct1`3">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field and one value type field. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the reference type</typeparam>
            <typeparam name="S1">The type of the value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct1`3.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct1`3.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct1`3.PrepareForIteration(`0,`1,`2)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct1`3.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct2`4">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field and two value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct2`4.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct2`4.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct2`4.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct2`4.PrepareForIteration(`0,`1,`2,`3)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct2`4.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct3`5">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field and three value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct3`5.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct3`5.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct3`5.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct3`5.s3">
            <summary>
            The third value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct3`5.PrepareForIteration(`0,`1,`2,`3,`4)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct3`5.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field and four value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
            <typeparam name="S4">The type of the fourth value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6.s3">
            <summary>
            The third value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6.s4">
            <summary>
            The fourth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <param name="s4">The fourth value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct4`6.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field and five value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
            <typeparam name="S4">The type of the fourth value type</typeparam>
            <typeparam name="S5">The type of the fifth value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.s3">
            <summary>
            The third value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.s4">
            <summary>
            The fourth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.s5">
            <summary>
            The fifth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <param name="s4">The fourth value type argument which will be stored</param>
            <param name="s5">The fifth value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct5`7.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field and six value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
            <typeparam name="S4">The type of the fourth value type</typeparam>
            <typeparam name="S5">The type of the fifth value type</typeparam>
            <typeparam name="S6">The type of the sixth value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.s3">
            <summary>
            The third value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.s4">
            <summary>
            The fourth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.s5">
            <summary>
            The fifth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.s6">
            <summary>
            The sixth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <param name="s4">The fourth value type argument which will be stored</param>
            <param name="s5">The fifth value type argument which will be stored</param>
            <param name="s6">The sixth value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct6`8.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one reference type field and seven value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
            <typeparam name="S4">The type of the fourth value type</typeparam>
            <typeparam name="S5">The type of the fifth value type</typeparam>
            <typeparam name="S6">The type of the sixth value type</typeparam>
            <typeparam name="S7">The type of the seventh value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.s3">
            <summary>
            The third value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.s4">
            <summary>
            The fourth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.s5">
            <summary>
            The fifth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.s6">
            <summary>
            The sixth value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.s7">
            <summary>
            The seventh value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6,`7,`8)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <param name="s4">The fourth value type argument which will be stored</param>
            <param name="s5">The fifth value type argument which will be stored</param>
            <param name="s6">The sixth value type argument which will be stored</param>
            <param name="s7">The seventh value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref1_Struct7`9.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct1`4">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses two reference type fields and one value type field. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="S1">The type of the value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct1`4.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct1`4.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct1`4.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct1`4.PrepareForIteration(`0,`1,`2,`3)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct1`4.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct2`5">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses two reference type fields and two value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct2`5.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct2`5.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct2`5.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct2`5.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct2`5.PrepareForIteration(`0,`1,`2,`3,`4)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct2`5.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses two reference type fields and three value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6.s3">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref2_Struct3`6.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct1`5">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses three reference type fields and one value type field. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="R3">The type of the third reference type</typeparam>
            <typeparam name="S1">The type of the value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct1`5.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct1`5.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct1`5.r3">
            <summary>
            The third reference type arguments used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct1`5.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct1`5.PrepareForIteration(`0,`1,`2,`3,`4)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct1`5.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses three reference type fields and one value type field. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="R3">The type of the third reference type</typeparam>
            <typeparam name="S1">The type of the value type</typeparam>
            <typeparam name="S2">The type of the value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6.r3">
            <summary>
            The third reference type arguments used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6.s2">
            <summary>
            The second value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type argument</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref3_Struct2`6.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses four reference type fields and 1 value type field. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="R1">The type of the first reference type</typeparam>
            <typeparam name="R2">The type of the second reference type</typeparam>
            <typeparam name="R3">The type of the third reference type</typeparam>
            <typeparam name="R4">The type of the fourth reference type</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <param name="s1">The first value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_Ref4_Struct1`6.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`2">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses one value type field. Pass this argument type into 
            the PrepareForIteration method to have them stored for the current iteration. You can find this value in the s1 field.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`2.s1">
            <summary>
            The first value type argument which will be stored used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`2.PrepareForIteration(`0,`1)">
            <summary>
            Prepares the enumerator for iteration, and also sets the first value type argument which will be stored used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="s1">The first value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`3">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses two value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`3.s1">
            <summary>
            The first value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`3.s2">
            <summary>
            The second value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`3.PrepareForIteration(`0,`1,`2)">
            <summary>
            Prepares the enumerator for iteration, and also sets the value type arguments
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`4">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses three value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`4.s1">
            <summary>
            The first value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`4.s2">
            <summary>
            The second value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`4.s3">
            <summary>
            The third value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`4.PrepareForIteration(`0,`1,`2,`3)">
            <summary>
            Prepares the enumerator for iteration, and also sets the value type arguments
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`5">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses four value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
            <typeparam name="S4">The type of the fourth value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`5.s1">
            <summary>
            The first value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`5.s2">
            <summary>
            The second value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`5.s3">
            <summary>
            The third value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`5.s4">
            <summary>
            The fourth value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`5.PrepareForIteration(`0,`1,`2,`3,`4)">
            <summary>
            Prepares the enumerator for iteration, and also sets the value type arguments
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <param name="s4">The fourth value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`6">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses five value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
            <typeparam name="S4">The type of the fourth value type</typeparam>
            <typeparam name="S5">The type of the fifth value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`6.s1">
            <summary>
            The first value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`6.s2">
            <summary>
            The second value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`6.s3">
            <summary>
            The third value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`6.s4">
            <summary>
            The fourth value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`6.s5">
            <summary>
            The fifth value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets the value type arguments
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <param name="s4">The fourth value type argument which will be stored</param>
            <param name="s5">The fifth value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7">
            <summary>
            An implementation of YieldEnumeratorWithParent that uses six value type fields. Pass these argument types into 
            the PrepareForIteration method to have them stored for the current iteration.
            </summary>
            <typeparam name="P">The type of the parent of your custom Yield Enumerator</typeparam>
            <typeparam name="S1">The type of the first value type</typeparam>
            <typeparam name="S2">The type of the second value type</typeparam>
            <typeparam name="S3">The type of the third value type</typeparam>
            <typeparam name="S4">The type of the fourth value type</typeparam>
            <typeparam name="S5">The type of the fifth value type</typeparam>
            <typeparam name="S6">The type of the sixth value type</typeparam>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7.s1">
            <summary>
            The first value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7.s2">
            <summary>
            The second value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7.s3">
            <summary>
            The third value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7.s4">
            <summary>
            The fourth value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7.s5">
            <summary>
            The fifth value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7.s6">
            <summary>
            The sixth value type argument which will be stored and used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParent_StructOnly`7.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Prepares the enumerator for iteration, and also sets the value type arguments
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="s1">The first value type argument which will be stored</param>
            <param name="s2">The second value type argument which will be stored</param>
            <param name="s3">The third value type argument which will be stored</param>
            <param name="s4">The fourth value type argument which will be stored</param>
            <param name="s5">The fifth value type argument which will be stored</param>
            <param name="s6">The sixth value type argument which will be stored</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_StructOnly`2.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_StructOnly`2.PrepareForIteration(`0,`1)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="s1">The first value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_RefOnly`2.r1">
            <summary>
            The first ref type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_RefOnly`2.PrepareForIteration(`0,`1)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first ref type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_RefOnly`2.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_RefOnly`3.r1">
            <summary>
            The first ref type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_RefOnly`3.r2">
            <summary>
            The second ref type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_RefOnly`3.PrepareForIteration(`0,`1,`2)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first ref type arg</param>
            <param name="r2">The second ref type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_RefOnly`3.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct1`3.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct1`3.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct1`3.PrepareForIteration(`0,`1,`2)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct1`3.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct2`4.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct2`4.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct2`4.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct2`4.PrepareForIteration(`0,`1,`2,`3)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct2`4.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.s3">
            <summary>
            The third value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.s4">
            <summary>
            The fourth value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.s5">
            <summary>
            The fifth value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Prepares the enumerator for iteration, and also sets the first reference type argument and 5 value type arguments 
            to be used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <param name="s3">The third value type arg</param>
            <param name="s4">The fourth value type arg</param>
            <param name="s5">The fifth value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct5`7.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.s3">
            <summary>
            The third value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.s4">
            <summary>
            The fourth value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.s5">
            <summary>
            The fifth value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.s6">
            <summary>
            The sixth value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Prepares the enumerator for iteration, and also sets the first reference type argument and 5 value type arguments 
            to be used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <param name="s3">The third value type arg</param>
            <param name="s4">The fourth value type arg</param>
            <param name="s5">The fifth value type arg</param>
            <param name="s6">The sixth value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref1_Struct6`8.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct1`4.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct1`4.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct1`4.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct1`4.PrepareForIteration(`0,`1,`2,`3)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="s1">The first value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct1`4.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct2`5.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct2`5.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct2`5.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct2`5.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct2`5.PrepareForIteration(`0,`1,`2,`3,`4)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct2`5.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.s3">
            <summary>
            The third value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.s4">
            <summary>
            The fourth value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <param name="s3">The third value type arg</param>
            <param name="s4">The fourth value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref2_Struct4`7.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct1`5.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct1`5.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct1`5.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct1`5.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct1`5.PrepareForIteration(`0,`1,`2,`3,`4)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="s1">The first value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct1`5.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct2`6.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct2`6.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct2`6.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct2`6.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct2`6.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct2`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref3_Struct2`6.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct1`6.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct1`6.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct1`6.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct1`6.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct1`6.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct1`6.PrepareForIteration(`0,`1,`2,`3,`4,`5)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <param name="s1">The first value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct1`6.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct2`7.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.s3">
            <summary>
            The third value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <param name="s3">The third value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct3`8.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.r1">
            <summary>
            The first reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.r2">
            <summary>
            The second reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.r3">
            <summary>
            The third reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.r4">
            <summary>
            The fourth reference type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.s1">
            <summary>
            The first value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.s2">
            <summary>
            The second value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.s3">
            <summary>
            The third value type argument used by this enumerator
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.s4">
            <summary>
            The fourth value type argument used by this enumerator
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.PrepareForIteration(`0,`1,`2,`3,`4,`5,`6,`7,`8)">
            <summary>
            Prepares the enumerator for iteration, and also sets the parent and reference type arguments used by the enumerator
            </summary>
            <param name="parent">The parent instance of the enumerator for the current iteration</param>
            <param name="r1">The first reference type argument</param>
            <param name="r2">The second reference type argument</param>
            <param name="r3">The third reference type arg</param>
            <param name="r4">The fourth reference type arg</param>
            <param name="s1">The first value type arg</param>
            <param name="s2">The second value type arg</param>
            <param name="s3">The third value type arg</param>
            <param name="s4">The fourth value type arg</param>
            <returns>The enumerator itself, so you can use one line initialization and returns.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.YieldEnumeratorWithParentAndExternalEnumerators_Ref4_Struct4`9.NullAdditionalRefFields">
            <summary>
            Nulls the reference type arguments.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LODOverride.ChunkManager">
            <summary>
            Gets the chunk manager assigned to this LOD Override (if any)
            </summary>
            <type link="ChunkManager.html">ChunkManager</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LODOverride.ChunkStreamer">
            <summary>
            Gets the chunk streamer assigned to this LOD override (if any)
            </summary>
            <type link="ChunkStreamer.html">ChunkStreamer</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape">
            <summary>
            A blend shape.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape.ShapeName">
            <summary>
            The name of the blend shape.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape.Frames">
            <summary>
            The blend shape frames.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape.#ctor(System.String,DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShapeFrame[])">
            <summary>
            Creates a new blend shape.
            </summary>
            <param name="shapeName">The name of the blend shape.</param>
            <param name="frames">The blend shape frames.</param>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShapeFrame">
            <summary>
            A blend shape frame.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShapeFrame.FrameWeight">
            <summary>
            The weight of the blend shape frame.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShapeFrame.DeltaVertices">
            <summary>
            The delta vertices of the blend shape frame.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShapeFrame.DeltaNormals">
            <summary>
            The delta normals of the blend shape frame.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShapeFrame.DeltaTangents">
            <summary>
            The delta tangents of the blend shape frame.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShapeFrame.#ctor(System.Single,UnityEngine.Vector3[],UnityEngine.Vector3[],UnityEngine.Vector3[])">
            <summary>
            Creates a new blend shape frame.
            </summary>
            <param name="frameWeight">The weight of the blend shape frame.</param>
            <param name="deltaVertices">The delta vertices of the blend shape frame.</param>
            <param name="deltaNormals">The delta normals of the blend shape frame.</param>
            <param name="deltaTangents">The delta tangents of the blend shape frame.</param>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator">
            <summary>
            Contains methods for generating LODs (level of details) for game objects.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.LODParentGameObjectName">
            <summary>
            The name of the game object where generated LODs are parented under.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.LODAssetDefaultParentPath">
            <summary>
            The default parent path for generated LOD assets.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.AssetsRootPath">
            <summary>
            The root assets path.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.LODAssetUserData">
            <summary>
            The user data applied to created LOD assets.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.GenerateLODs(DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper)">
            <summary>
            Generates the LODs and sets up a LOD Group for the LOD generator helper component.
            </summary>
            <param name="generatorHelper">The LOD generator helper.</param>
            <returns>The generated LOD Group.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.GenerateLODs(UnityEngine.GameObject,DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel[],System.Boolean,DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions)">
            <summary>
            Generates the LODs and sets up a LOD Group for the specified game object.
            </summary>
            <param name="gameObject">The game object to set up.</param>
            <param name="levels">The LOD levels to set up.</param>
            <param name="autoCollectRenderers">If the renderers under the game object and any children should be automatically collected.
            Enabling this will ignore any renderers defined under each LOD level.</param>
            <param name="simplificationOptions">The mesh simplification options.</param>
            <returns>The generated LOD Group.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.GenerateLODs(UnityEngine.GameObject,DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel[],System.Boolean,DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions,System.String)">
            <summary>
            Generates the LODs and sets up a LOD Group for the specified game object.
            </summary>
            <param name="gameObject">The game object to set up.</param>
            <param name="levels">The LOD levels to set up.</param>
            <param name="autoCollectRenderers">If the renderers under the game object and any children should be automatically collected.
            Enabling this will ignore any renderers defined under each LOD level.</param>
            <param name="simplificationOptions">The mesh simplification options.</param>
            <param name="saveAssetsPath">The path to where the generated assets should be saved. Can be null or empty to use the default path.</param>
            <returns>The generated LOD Group.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.DestroyLODs(DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper)">
            <summary>
            Destroys the generated LODs and LOD Group for the specified game object.
            </summary>
            <param name="generatorHelper">The LOD generator helper.</param>
            <returns>If the LODs were successfully destroyed.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGenerator.DestroyLODs(UnityEngine.GameObject)">
            <summary>
            Destroys the generated LODs and LOD Group for the specified game object.
            </summary>
            <param name="gameObject">The game object to destroy LODs for.</param>
            <returns>If the LODs were successfully destroyed.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel">
            <summary>
            A LOD (level of detail) level.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.ScreenRelativeTransitionHeight">
            <summary>
            Gets or sets the screen relative height to use for the transition [0-1].
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.FadeTransitionWidth">
            <summary>
            Gets or sets the width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.Quality">
            <summary>
            Gets or sets the quality of this level [0-1].
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.CombineMeshes">
            <summary>
            Gets or sets if all renderers and meshes under this level should be combined into one, where possible.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.CombineSubMeshes">
            <summary>
            Gets or sets if all sub-meshes should be combined into one, where possible.
            NOTE: This is only used if <see cref="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.CombineMeshes"/> is true.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.Renderers">
            <summary>
            Gets or sets the renderers used in this level.
            These will have no purpose if automatic collection is used for the LOD generator.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.SkinQuality">
            <summary>
            Gets or sets the skin quality to use for renderers on this level.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.ShadowCastingMode">
            <summary>
            Gets or sets the shadow casting mode for renderers on this level.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.ReceiveShadows">
            <summary>
            Gets or sets if renderers on this level should receive shadows.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.MotionVectorGenerationMode">
            <summary>
            Gets or sets the motion vector generation mode for renderers on this level.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.SkinnedMotionVectors">
            <summary>
            Gets or sets if renderers on this level should use skinned motion vectors.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.LightProbeUsage">
            <summary>
            Gets or sets the light probe usage for renderers on this level.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.ReflectionProbeUsage">
            <summary>
            Gets or sets the reflection probe usage for renderers on this level.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.#ctor(System.Single,System.Single)">
            <summary>
            Creates a new LOD level.
            </summary>
            <param name="screenRelativeTransitionHeight">The screen relative height to use for the transition [0-1].</param>
            <param name="quality">The quality of this level [0-1].</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.#ctor(System.Single,System.Single,System.Single,System.Boolean,System.Boolean)">
            <summary>
            Creates a new LOD level.
            </summary>
            <param name="screenRelativeTransitionHeight">The screen relative height to use for the transition [0-1].</param>
            <param name="fadeTransitionWidth">The width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.</param>
            <param name="quality">The quality of this level [0-1].</param>
            <param name="combineMeshes">If all renderers and meshes under this level should be combined into one, where possible.</param>
            <param name="combineSubMeshes">If all sub-meshes should be combined into one, where possible.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODLevel.#ctor(System.Single,System.Single,System.Single,System.Boolean,System.Boolean,UnityEngine.Renderer[])">
            <summary>
            Creates a new LOD level.
            </summary>
            <param name="screenRelativeTransitionHeight">The screen relative height to use for the transition [0-1].</param>
            <param name="fadeTransitionWidth">The width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated.</param>
            <param name="quality">The quality of this level [0-1].</param>
            <param name="combineMeshes">If all renderers and meshes under this level should be combined into one, where possible.</param>
            <param name="combineSubMeshes">If all sub-meshes should be combined into one, where possible.</param>
            <param name="renderers">The renderers used in this level.</param>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshCombiner">
            <summary>
            Contains methods for combining meshes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshCombiner.CombineMeshes(UnityEngine.Transform,UnityEngine.MeshRenderer[],UnityEngine.Material[]@)">
            <summary>
            Combines an array of mesh renderers into one single mesh.
            </summary>
            <param name="rootTransform">The root transform to create the combine mesh based from, essentially the origin of the new mesh.</param>
            <param name="renderers">The array of mesh renderers to combine.</param>
            <param name="resultMaterials">The resulting materials for the combined mesh.</param>
            <returns>The combined mesh.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshCombiner.CombineMeshes(UnityEngine.Transform,UnityEngine.SkinnedMeshRenderer[],UnityEngine.Material[]@,UnityEngine.Transform[]@)">
            <summary>
            Combines an array of skinned mesh renderers into one single skinned mesh.
            </summary>
            <param name="rootTransform">The root transform to create the combine mesh based from, essentially the origin of the new mesh.</param>
            <param name="renderers">The array of skinned mesh renderers to combine.</param>
            <param name="resultMaterials">The resulting materials for the combined mesh.</param>
            <param name="resultBones">The resulting bones for the combined mesh.</param>
            <returns>The combined mesh.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshCombiner.CombineMeshes(UnityEngine.Mesh[],UnityEngine.Matrix4x4[],UnityEngine.Material[][],UnityEngine.Material[]@)">
            <summary>
            Combines an array of meshes into a single mesh.
            </summary>
            <param name="meshes">The array of meshes to combine.</param>
            <param name="transforms">The array of transforms for the meshes.</param>
            <param name="materials">The array of materials for each mesh to combine.</param>
            <param name="resultMaterials">The resulting materials for the combined mesh.</param>
            <returns>The combined mesh.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshCombiner.CombineMeshes(UnityEngine.Mesh[],UnityEngine.Matrix4x4[],UnityEngine.Material[][],UnityEngine.Transform[][],UnityEngine.Material[]@,UnityEngine.Transform[]@)">
            <summary>
            Combines an array of meshes into a single mesh.
            </summary>
            <param name="meshes">The array of meshes to combine.</param>
            <param name="transforms">The array of transforms for the meshes.</param>
            <param name="materials">The array of materials for each mesh to combine.</param>
            <param name="bones">The array of bones for each mesh to combine.</param>
            <param name="resultMaterials">The resulting materials for the combined mesh.</param>
            <param name="resultBones">The resulting bones for the combined mesh.</param>
            <returns>The combined mesh.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier">
            <summary>
            The mesh simplifier.
            Deeply based on https://github.com/sp4cerat/Fast-Quadric-Mesh-Simplification but rewritten completely in C#.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SimplificationOptions">
            <summary>
            Gets or sets all of the simplification options as a single block.
            Default value: SimplificationOptions.Default
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.PreserveBorderEdges">
            <summary>
            Gets or sets if the border edges should be preserved.
            Default value: false
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.PreserveUVSeamEdges">
            <summary>
            Gets or sets if the UV seam edges should be preserved.
            Default value: false
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.PreserveUVFoldoverEdges">
            <summary>
            Gets or sets if the UV foldover edges should be preserved.
            Default value: false
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.PreserveSurfaceCurvature">
            <summary>
            Gets or sets if the discrete curvature of the mesh surface be taken into account during simplification.
            Default value: false
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.EnableSmartLink">
            <summary>
            Gets or sets if a feature for smarter vertex linking should be enabled, reducing artifacts in the
            decimated result at the cost of a slightly more expensive initialization by treating vertices at
            the same position as the same vertex while separating the attributes.
            Default value: true
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.MaxIterationCount">
            <summary>
            Gets or sets the maximum iteration count. Higher number is more expensive but can bring you closer to your target quality.
            Sometimes a lower maximum count might be desired in order to lower the performance cost.
            Default value: 100
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Agressiveness">
            <summary>
            Gets or sets the agressiveness of the mesh simplification. Higher number equals higher quality, but more expensive to run.
            Default value: 7.0
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Verbose">
            <summary>
            Gets or sets if verbose information should be printed to the console.
            Default value: false
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.VertexLinkDistance">
            <summary>
            Gets or sets the maximum distance between two vertices in order to link them.
            Note that this value is only used if EnableSmartLink is true.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.VertexLinkDistanceSqr">
            <summary>
            Gets or sets the maximum squared distance between two vertices in order to link them.
            Note that this value is only used if EnableSmartLink is true.
            Default value: double.Epsilon
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Vertices">
            <summary>
            Gets or sets the vertex positions.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SubMeshCount">
            <summary>
            Gets the count of sub-meshes.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.BlendShapeCount">
            <summary>
            Gets the count of blend shapes.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Normals">
            <summary>
            Gets or sets the vertex normals.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Tangents">
            <summary>
            Gets or sets the vertex tangents.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV1">
            <summary>
            Gets or sets the vertex 2D UV set 1.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV2">
            <summary>
            Gets or sets the vertex 2D UV set 2.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV3">
            <summary>
            Gets or sets the vertex 2D UV set 3.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV4">
            <summary>
            Gets or sets the vertex 2D UV set 4.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV5">
            <summary>
            Gets or sets the vertex 2D UV set 5.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV6">
            <summary>
            Gets or sets the vertex 2D UV set 6.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV7">
            <summary>
            Gets or sets the vertex 2D UV set 7.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UV8">
            <summary>
            Gets or sets the vertex 2D UV set 8.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Colors">
            <summary>
            Gets or sets the vertex colors.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.BoneWeights">
            <summary>
            Gets or sets the vertex bone weights.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.#ctor">
            <summary>
            Creates a new mesh simplifier.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.#ctor(UnityEngine.Mesh)">
            <summary>
            Creates a new mesh simplifier.
            </summary>
            <param name="mesh">The original mesh to simplify.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Flipped(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,System.Int32,System.Int32,DeepSpaceLabs.SAM.UnityMeshSimplifier.Internal.Vertex@,System.Boolean[])">
            <summary>
            Check if a triangle flips when this edge is removed
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UpdateTriangles(System.Int32,System.Int32,DeepSpaceLabs.SAM.UnityMeshSimplifier.Internal.Vertex@,DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray{System.Boolean},System.Int32@)">
            <summary>
            Update triangle connections and edge error after a edge is collapsed.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.RemoveVertexPass(System.Int32,System.Int32,System.Double,DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray{System.Boolean},DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray{System.Boolean},System.Int32@)">
            <summary>
            Remove vertices and mark deleted triangles
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.UpdateMesh(System.Int32)">
            <summary>
            Compact triangles, compute edge error and build reference list.
            </summary>
            <param name="iteration">The iteration index.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.CompactMesh">
            <summary>
            Finally compact mesh before exiting.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetAllSubMeshTriangles">
            <summary>
            Returns the triangle indices for all sub-meshes.
            </summary>
            <returns>The triangle indices for all sub-meshes.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetSubMeshTriangles(System.Int32)">
            <summary>
            Returns the triangle indices for a specific sub-mesh.
            </summary>
            <param name="subMeshIndex">The sub-mesh index.</param>
            <returns>The triangle indices.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.ClearSubMeshes">
            <summary>
            Clears out all sub-meshes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.AddSubMeshTriangles(System.Int32[])">
            <summary>
            Adds a sub-mesh triangle indices for a specific sub-mesh.
            </summary>
            <param name="triangles">The triangle indices.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.AddSubMeshTriangles(System.Int32[][])">
            <summary>
            Adds several sub-meshes at once with their triangle indices for each sub-mesh.
            </summary>
            <param name="triangles">The triangle indices for each sub-mesh.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetUVs2D(System.Int32)">
            <summary>
            Returns the UVs (2D) from a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <returns>The UVs.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetUVs3D(System.Int32)">
            <summary>
            Returns the UVs (3D) from a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <returns>The UVs.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetUVs4D(System.Int32)">
            <summary>
            Returns the UVs (4D) from a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <returns>The UVs.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetUVs(System.Int32,System.Collections.Generic.List{UnityEngine.Vector2})">
            <summary>
            Returns the UVs (2D) from a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetUVs(System.Int32,System.Collections.Generic.List{UnityEngine.Vector3})">
            <summary>
            Returns the UVs (3D) from a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetUVs(System.Int32,System.Collections.Generic.List{UnityEngine.Vector4})">
            <summary>
            Returns the UVs (4D) from a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SetUVs(System.Int32,System.Collections.Generic.IList{UnityEngine.Vector2})">
            <summary>
            Sets the UVs (2D) for a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SetUVs(System.Int32,System.Collections.Generic.IList{UnityEngine.Vector3})">
            <summary>
            Sets the UVs (3D) for a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SetUVs(System.Int32,System.Collections.Generic.IList{UnityEngine.Vector4})">
            <summary>
            Sets the UVs (4D) for a specific channel.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SetUVs(System.Int32,System.Collections.Generic.IList{UnityEngine.Vector4},System.Int32)">
            <summary>
            Sets the UVs for a specific channel with a specific count of UV components.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
            <param name="uvComponentCount">The count of UV components.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SetUVsAuto(System.Int32,System.Collections.Generic.IList{UnityEngine.Vector4})">
            <summary>
            Sets the UVs for a specific channel and automatically detects the used components.
            </summary>
            <param name="channel">The channel index.</param>
            <param name="uvs">The UVs.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetAllBlendShapes">
            <summary>
            Returns all blend shapes.
            </summary>
            <returns>An array of all blend shapes.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.GetBlendShape(System.Int32)">
            <summary>
            Returns a specific blend shape.
            </summary>
            <param name="blendShapeIndex">The blend shape index.</param>
            <returns>The blend shape.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.ClearBlendShapes">
            <summary>
            Clears all blend shapes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.AddBlendShape(DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape)">
            <summary>
            Adds a blend shape.
            </summary>
            <param name="blendShape">The blend shape to add.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.AddBlendShapes(DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape[])">
            <summary>
            Adds several blend shapes.
            </summary>
            <param name="blendShapes">The blend shapes to add.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.Initialize(UnityEngine.Mesh)">
            <summary>
            Initializes the algorithm with the original mesh.
            </summary>
            <param name="mesh">The mesh.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SimplifyMesh(System.Single)">
            <summary>
            Simplifies the mesh to a desired quality.
            </summary>
            <param name="quality">The target quality (between 0 and 1).</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.SimplifyMeshLossless">
            <summary>
            Simplifies the mesh without losing too much quality.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshSimplifier.ToMesh">
            <summary>
            Returns the resulting mesh.
            </summary>
            <returns>The resulting mesh.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions">
            <summary>
            Options for mesh simplification.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.Default">
            <summary>
            The default simplification options.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.PreserveBorderEdges">
            <summary>
            If the border edges should be preserved.
            Default value: false
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.PreserveUVSeamEdges">
            <summary>
            If the UV seam edges should be preserved.
            Default value: false
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.PreserveUVFoldoverEdges">
            <summary>
            If the UV foldover edges should be preserved.
            Default value: false
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.PreserveSurfaceCurvature">
            <summary>
            If the discrete curvature of the mesh surface be taken into account during simplification. Taking surface curvature into account can result in good quality mesh simplification, but it can slow the simplification process significantly.
            Default value: false
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.EnableSmartLink">
            <summary>
            If a feature for smarter vertex linking should be enabled, reducing artifacts in the
            decimated result at the cost of a slightly more expensive initialization by treating vertices at
            the same position as the same vertex while separating the attributes.
            Default value: true
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.VertexLinkDistance">
            <summary>
            The maximum distance between two vertices in order to link them.
            Note that this value is only used if EnableSmartLink is true.
            Default value: double.Epsilon
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.MaxIterationCount">
            <summary>
            The maximum iteration count. Higher number is more expensive but can bring you closer to your target quality.
            Sometimes a lower maximum count might be desired in order to lower the performance cost.
            Default value: 100
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.Agressiveness">
            <summary>
            The agressiveness of the mesh simplification. Higher number equals higher quality, but more expensive to run.
            Default value: 7.0
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.ManualUVComponentCount">
            <summary>
            If a manual UV component count should be used (set by UVComponentCount), instead of the automatic detection.
            Default value: false
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SimplificationOptions.UVComponentCount">
            <summary>
            The UV component count. The same UV component count will be used on all UV channels.
            Default value: 2
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper">
            <summary>
            A LOD (level of detail) generator helper.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper.FadeMode">
            <summary>
            Gets or sets the fade mode used by the created LOD group.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper.AnimateCrossFading">
            <summary>
            Gets or sets if the cross-fading should be animated by time. The animation duration
            is specified globally as crossFadeAnimationDuration.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper.AutoCollectRenderers">
            <summary>
            Gets or sets if the renderers under this game object and any children should be automatically collected.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper.SimplificationOptions">
            <summary>
            Gets or sets the simplification options.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper.SaveAssetsPath">
            <summary>
            Gets or sets the path within the project to save the generated assets.
            Leave this empty to use the default path.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper.Levels">
            <summary>
            Gets or sets the LOD levels for this generator.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.LODGeneratorHelper.IsGenerated">
            <summary>
            Gets if the LODs have been generated.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.PI">
            <summary>
            The Pi constant.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.PId">
            <summary>
            The Pi constant.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.Deg2Rad">
            <summary>
            Degrees to radian constant.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.Deg2Radd">
            <summary>
            Degrees to radian constant.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.Rad2Deg">
            <summary>
            Radians to degrees constant.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.Rad2Degd">
            <summary>
            Radians to degrees constant.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.Min(System.Double,System.Double,System.Double)">
            <summary>
            Returns the minimum of three values.
            </summary>
            <param name="val1">The first value.</param>
            <param name="val2">The second value.</param>
            <param name="val3">The third value.</param>
            <returns>The minimum value.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.Clamp(System.Double,System.Double,System.Double)">
            <summary>
            Clamps a value between a minimum and a maximum value.
            </summary>
            <param name="value">The value to clamp.</param>
            <param name="min">The minimum value.</param>
            <param name="max">The maximum value.</param>
            <returns>The clamped value.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MathHelper.TriangleArea(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Calculates the area of a triangle.
            </summary>
            <param name="p0">The first point.</param>
            <param name="p1">The second point.</param>
            <param name="p2">The third point.</param>
            <returns>The triangle area.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix">
            <summary>
            A symmetric matrix.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m0">
            <summary>
            The m11 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m1">
            <summary>
            The m12 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m2">
            <summary>
            The m13 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m3">
            <summary>
            The m14 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m4">
            <summary>
            The m22 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m5">
            <summary>
            The m23 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m6">
            <summary>
            The m24 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m7">
            <summary>
            The m33 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m8">
            <summary>
            The m34 component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.m9">
            <summary>
            The m44 component.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.Item(System.Int32)">
            <summary>
            Gets the component value with a specific index.
            </summary>
            <param name="index">The component index.</param>
            <returns>The value.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.#ctor(System.Double)">
            <summary>
            Creates a symmetric matrix with a value in each component.
            </summary>
            <param name="c">The component value.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.#ctor(System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a symmetric matrix.
            </summary>
            <param name="m0">The m11 component.</param>
            <param name="m1">The m12 component.</param>
            <param name="m2">The m13 component.</param>
            <param name="m3">The m14 component.</param>
            <param name="m4">The m22 component.</param>
            <param name="m5">The m23 component.</param>
            <param name="m6">The m24 component.</param>
            <param name="m7">The m33 component.</param>
            <param name="m8">The m34 component.</param>
            <param name="m9">The m44 component.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.#ctor(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Creates a symmetric matrix from a plane.
            </summary>
            <param name="a">The plane x-component.</param>
            <param name="b">The plane y-component</param>
            <param name="c">The plane z-component</param>
            <param name="d">The plane w-component</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.op_Addition(DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix,DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix)">
            <summary>
            Adds two matrixes together.
            </summary>
            <param name="a">The left hand side.</param>
            <param name="b">The right hand side.</param>
            <returns>The resulting matrix.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.Determinant1">
            <summary>
            Determinant(0, 1, 2, 1, 4, 5, 2, 5, 7)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.Determinant2">
            <summary>
            Determinant(1, 2, 3, 4, 5, 6, 5, 7, 8)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.Determinant3">
            <summary>
            Determinant(0, 2, 3, 1, 5, 6, 2, 7, 8)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.Determinant4">
            <summary>
            Determinant(0, 1, 3, 1, 4, 6, 2, 5, 8)
            </summary>
            <returns></returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.SymmetricMatrix.Determinant(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the determinant of this matrix.
            </summary>
            <param name="a11">The a11 index.</param>
            <param name="a12">The a12 index.</param>
            <param name="a13">The a13 index.</param>
            <param name="a21">The a21 index.</param>
            <param name="a22">The a22 index.</param>
            <param name="a23">The a23 index.</param>
            <param name="a31">The a31 index.</param>
            <param name="a32">The a32 index.</param>
            <param name="a33">The a33 index.</param>
            <returns>The determinant value.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d">
            <summary>
            A double precision 3D vector.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.zero">
            <summary>
            The zero vector.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Epsilon">
            <summary>
            The vector epsilon.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.x">
            <summary>
            The x component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.y">
            <summary>
            The y component.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.z">
            <summary>
            The z component.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Magnitude">
            <summary>
            Gets the magnitude of this vector.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.MagnitudeSqr">
            <summary>
            Gets the squared magnitude of this vector.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Normalized">
            <summary>
            Gets a normalized vector from this vector.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Item(System.Int32)">
            <summary>
            Gets or sets a specific component by index in this vector.
            </summary>
            <param name="index">The component index.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.#ctor(System.Double)">
            <summary>
            Creates a new vector with one value for all components.
            </summary>
            <param name="value">The value.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Creates a new vector.
            </summary>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.#ctor(UnityEngine.Vector3)">
            <summary>
            Creates a new vector from a single precision vector.
            </summary>
            <param name="vector">The single precision vector.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Addition(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)">
            <summary>
            Adds two vectors.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
            <returns>The resulting vector.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Subtraction(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)">
            <summary>
            Subtracts two vectors.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
            <returns>The resulting vector.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Multiply(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d,System.Double)">
            <summary>
            Scales the vector uniformly.
            </summary>
            <param name="a">The vector.</param>
            <param name="d">The scaling value.</param>
            <returns>The resulting vector.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Multiply(System.Double,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)">
            <summary>
            Scales the vector uniformly.
            </summary>
            <param name="d">The scaling vlaue.</param>
            <param name="a">The vector.</param>
            <returns>The resulting vector.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Division(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d,System.Double)">
            <summary>
            Divides the vector with a float.
            </summary>
            <param name="a">The vector.</param>
            <param name="d">The dividing float value.</param>
            <returns>The resulting vector.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_UnaryNegation(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)">
            <summary>
            Subtracts the vector from a zero vector.
            </summary>
            <param name="a">The vector.</param>
            <returns>The resulting vector.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Equality(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)">
            <summary>
            Returns if two vectors equals eachother.
            </summary>
            <param name="lhs">The left hand side vector.</param>
            <param name="rhs">The right hand side vector.</param>
            <returns>If equals.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Inequality(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)">
            <summary>
            Returns if two vectors don't equal eachother.
            </summary>
            <param name="lhs">The left hand side vector.</param>
            <param name="rhs">The right hand side vector.</param>
            <returns>If not equals.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Implicit(UnityEngine.Vector3)~DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d">
            <summary>
            Implicitly converts from a single-precision vector into a double-precision vector.
            </summary>
            <param name="v">The single-precision vector.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.op_Explicit(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)~UnityEngine.Vector3">
            <summary>
            Implicitly converts from a double-precision vector into a single-precision vector.
            </summary>
            <param name="v">The double-precision vector.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Set(System.Double,System.Double,System.Double)">
            <summary>
            Set x, y and z components of an existing vector.
            </summary>
            <param name="x">The x value.</param>
            <param name="y">The y value.</param>
            <param name="z">The z value.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Scale(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Multiplies with another vector component-wise.
            </summary>
            <param name="scale">The vector to multiply with.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Normalize">
            <summary>
            Normalizes this vector.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Clamp(System.Double,System.Double)">
            <summary>
            Clamps this vector between a specific range.
            </summary>
            <param name="min">The minimum component value.</param>
            <param name="max">The maximum component value.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.GetHashCode">
            <summary>
            Returns a hash code for this vector.
            </summary>
            <returns>The hash code.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Equals(System.Object)">
            <summary>
            Returns if this vector is equal to another one.
            </summary>
            <param name="obj">The other vector to compare to.</param>
            <returns>If equals.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Equals(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d)">
            <summary>
            Returns if this vector is equal to another one.
            </summary>
            <param name="other">The other vector to compare to.</param>
            <returns>If equals.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.ToString">
            <summary>
            Returns a nicely formatted string for this vector.
            </summary>
            <returns>The string.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.ToString(System.String)">
            <summary>
            Returns a nicely formatted string for this vector.
            </summary>
            <param name="format">The float format.</param>
            <returns>The string.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Dot(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Dot Product of two vectors.
            </summary>
            <param name="lhs">The left hand side vector.</param>
            <param name="rhs">The right hand side vector.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Cross(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Cross Product of two vectors.
            </summary>
            <param name="lhs">The left hand side vector.</param>
            <param name="rhs">The right hand side vector.</param>
            <param name="result">The resulting vector.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Angle(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Calculates the angle between two vectors.
            </summary>
            <param name="from">The from vector.</param>
            <param name="to">The to vector.</param>
            <returns>The angle.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Lerp(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,System.Double,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Performs a linear interpolation between two vectors.
            </summary>
            <param name="a">The vector to interpolate from.</param>
            <param name="b">The vector to interpolate to.</param>
            <param name="t">The time fraction.</param>
            <param name="result">The resulting vector.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Scale(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Multiplies two vectors component-wise.
            </summary>
            <param name="a">The first vector.</param>
            <param name="b">The second vector.</param>
            <param name="result">The resulting vector.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d.Normalize(DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@,DeepSpaceLabs.SAM.UnityMeshSimplifier.Vector3d@)">
            <summary>
            Normalizes a vector.
            </summary>
            <param name="value">The vector to normalize.</param>
            <param name="result">The resulting normalized vector.</param>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils">
            <summary>
            Contains utility methods for meshes.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.UVChannelCount">
            <summary>
            The count of supported UV channels.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.CreateMesh(UnityEngine.Vector3[],System.Int32[][],UnityEngine.Vector3[],UnityEngine.Vector4[],UnityEngine.Color[],UnityEngine.BoneWeight[],System.Collections.Generic.List{UnityEngine.Vector2}[],UnityEngine.Matrix4x4[],DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape[])">
            <summary>
            Creates a new mesh.
            </summary>
            <param name="vertices">The mesh vertices.</param>
            <param name="indices">The mesh sub-mesh indices.</param>
            <param name="normals">The mesh normals.</param>
            <param name="tangents">The mesh tangents.</param>
            <param name="colors">The mesh colors.</param>
            <param name="boneWeights">The mesh bone-weights.</param>
            <param name="uvs">The mesh 2D UV sets.</param>
            <param name="bindposes">The mesh bindposes.</param>
            <param name="blendShapes">The mesh blend shapes.</param>
            <returns>The created mesh.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.CreateMesh(UnityEngine.Vector3[],System.Int32[][],UnityEngine.Vector3[],UnityEngine.Vector4[],UnityEngine.Color[],UnityEngine.BoneWeight[],System.Collections.Generic.List{UnityEngine.Vector4}[],UnityEngine.Matrix4x4[],DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape[])">
            <summary>
            Creates a new mesh.
            </summary>
            <param name="vertices">The mesh vertices.</param>
            <param name="indices">The mesh sub-mesh indices.</param>
            <param name="normals">The mesh normals.</param>
            <param name="tangents">The mesh tangents.</param>
            <param name="colors">The mesh colors.</param>
            <param name="boneWeights">The mesh bone-weights.</param>
            <param name="uvs">The mesh 4D UV sets.</param>
            <param name="bindposes">The mesh bindposes.</param>
            <param name="blendShapes">The mesh blend shapes.</param>
            <returns>The created mesh.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.CreateMesh(UnityEngine.Vector3[],System.Int32[][],UnityEngine.Vector3[],UnityEngine.Vector4[],UnityEngine.Color[],UnityEngine.BoneWeight[],System.Collections.Generic.List{UnityEngine.Vector2}[],System.Collections.Generic.List{UnityEngine.Vector3}[],System.Collections.Generic.List{UnityEngine.Vector4}[],UnityEngine.Matrix4x4[],DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape[])">
            <summary>
            Creates a new mesh.
            </summary>
            <param name="vertices">The mesh vertices.</param>
            <param name="indices">The mesh sub-mesh indices.</param>
            <param name="normals">The mesh normals.</param>
            <param name="tangents">The mesh tangents.</param>
            <param name="colors">The mesh colors.</param>
            <param name="boneWeights">The mesh bone-weights.</param>
            <param name="uvs2D">The mesh 2D UV sets.</param>
            <param name="uvs3D">The mesh 3D UV sets.</param>
            <param name="uvs4D">The mesh 4D UV sets.</param>
            <param name="bindposes">The mesh bindposes.</param>
            <param name="blendShapes">The mesh blend shapes.</param>
            <returns>The created mesh.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.GetMeshBlendShapes(UnityEngine.Mesh)">
            <summary>
            Returns the blend shapes of a mesh.
            </summary>
            <param name="mesh">The mesh.</param>
            <returns>The mesh blend shapes.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.ApplyMeshBlendShapes(UnityEngine.Mesh,DeepSpaceLabs.SAM.UnityMeshSimplifier.BlendShape[])">
            <summary>
            Applies and overrides the specified blend shapes on the specified mesh.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="blendShapes">The mesh blend shapes.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.GetMeshUVs(UnityEngine.Mesh)">
            <summary>
            Returns the UV sets for a specific mesh.
            </summary>
            <param name="mesh">The mesh.</param>
            <returns>The UV sets.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.GetMeshUVs2D(UnityEngine.Mesh,System.Int32)">
            <summary>
            Returns the 2D UV list for a specific mesh and UV channel.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="channel">The UV channel.</param>
            <returns>The UV list.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.GetMeshUVs3D(UnityEngine.Mesh,System.Int32)">
            <summary>
            Returns the 3D UV list for a specific mesh and UV channel.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="channel">The UV channel.</param>
            <returns>The UV list.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.GetMeshUVs(UnityEngine.Mesh,System.Int32)">
            <summary>
            Returns the 4D UV list for a specific mesh and UV channel.
            </summary>
            <param name="mesh">The mesh.</param>
            <param name="channel">The UV channel.</param>
            <returns>The UV list.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.GetUsedUVComponents(System.Collections.Generic.IList{UnityEngine.Vector4})">
            <summary>
            Returns the number of used UV components in a UV set.
            </summary>
            <param name="uvs">The UV set.</param>
            <returns>The number of used UV components.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.ConvertUVsTo2D(System.Collections.Generic.IList{UnityEngine.Vector4})">
            <summary>
            Converts a list of 4D UVs into 2D.
            </summary>
            <param name="uvs">The list of UVs.</param>
            <returns>The array of 2D UVs.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.ConvertUVsTo3D(System.Collections.Generic.IList{UnityEngine.Vector4})">
            <summary>
            Converts a list of 4D UVs into 3D.
            </summary>
            <param name="uvs">The list of UVs.</param>
            <returns>The array of 3D UVs.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.MeshUtils.GetSubMeshIndexMinMax(System.Int32[][],UnityEngine.Rendering.IndexFormat@)">
            <summary>
            Returns the minimum and maximum indices for each submesh along with the needed index format.
            </summary>
            <param name="indices">The indices for the submeshes.</param>
            <param name="indexFormat">The output index format.</param>
            <returns>The minimum and maximum indices for each submesh.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1">
            <summary>
            A resizable array with the goal of being quicker than List&lt;T&gt;.
            </summary>
            <typeparam name="T">The item type.</typeparam>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.Length">
            <summary>
            Gets the length of this array.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.Data">
            <summary>
            Gets the internal data buffer for this array.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.Item(System.Int32)">
            <summary>
            Gets or sets the element value at a specific index.
            </summary>
            <param name="index">The element index.</param>
            <returns>The element value.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.#ctor(System.Int32)">
            <summary>
            Creates a new resizable array.
            </summary>
            <param name="capacity">The initial array capacity.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new resizable array.
            </summary>
            <param name="capacity">The initial array capacity.</param>
            <param name="length">The initial length of the array.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.#ctor(`0[])">
            <summary>
            Creates a new resizable array.
            </summary>
            <param name="initialArray">The initial array.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.Clear">
            <summary>
            Clears this array.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.Resize(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Resizes this array.
            </summary>
            <param name="length">The new length.</param>
            <param name="trimExess">If exess memory should be trimmed.</param>
            <param name="clearMemory">If memory that is no longer part of the array should be cleared.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.TrimExcess">
            <summary>
            Trims any excess memory for this array.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.Add(`0)">
            <summary>
            Adds a new item to the end of this array.
            </summary>
            <param name="item">The new item.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.ResizableArray`1.ToArray">
            <summary>
            Returns a copy of the resizable array as an actually array.
            </summary>
            <returns>The array.</returns>
        </member>
        <member name="P:DeepSpaceLabs.SAM.UnityMeshSimplifier.Internal.UVChannels`1.Item(System.Int32)">
            <summary>
            Gets or sets a specific channel by index.
            </summary>
            <param name="index">The channel index.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.UnityMeshSimplifier.Internal.UVChannels`1.Resize(System.Int32,System.Boolean)">
            <summary>
            Resizes all channels at once.
            </summary>
            <param name="capacity">The new capacity.</param>
            <param name="trimExess">If exess memory should be trimmed.</param>
        </member>
        <member name="T:DeepSpaceLabs.SAM.MiniatureAssetGenerator">
            <summary>
            A scriptable asset that allows you to generate miniaturized meshes from Terrain and other meshes, for use with the World Designer and Loading Blueprint Editor tools.
            </summary>
            <title>
            MiniatureAssetGenerator Class
            </title>
            <category>Scriptable Assets</category>
            <navigationName>
            MiniatureAssetGenerator
            </navigationName>
            <fileName>MiniatureAssetGenerator.html</fileName>
            <syntax>
            public sealed class MiniatureAssetGenerator : ScriptableObject
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.NamingConventionSample">
            <summary>
            A Naming Convention implemented as a scriptable object. You can create a NamingConvention asset via 
            Assets -> Create -> Deep Space Labs -> Core -> Naming Convention.
            <para>
            These assets are used by the different tools/components in the Terra Slicer and S.A.M. - Streamable Assets Manager packages 
            to procedurally build the names of Assets and other things at runtime or while a tool is executing. This saves on mememory as it 
            means the asset names do not need to be saved to a file and included with the game build.
            </para>
            <para>
            If a NamingConvention field is visible on a component or tool and no 
            asset is provided, a default INamingConvention implementation will be used, which has the following characteristics.
            </para>
            <para>
            First Chunk Format 2D: %g_%y_%x
            <br></br>
            First Chunk Format 3D: %g_%z_%y_%x
            <br></br>
            Supplemental Chunk (2+) Format 2D: %g_%y_%x_Chunk%c
            <br></br>
            Supplemental Chunk (2+) Format 3D:  %g_%z_%y_%x_Chunk%c
            </para>
            <para>
            When using these Formats to generate names, the %g characters are replaced by the Group Name of whatever group the Asset belongs to. In SAM, this is the 
            Group Name associated with the LOD Group (found on the Streamable Grid asset). In Terra Slicer, this is the common named provided to the Slicer Tool for 
            a set of prefabs or Terrain Data assets.
            </para>
            <para>
            %y is replaced by the Row number an Asset belongs to, while %x is replaced by the Column number. %z is replaced by the Layer number, but is only used 
            in SAM when using a 3D Streamable Grid. In addition, %c is replaced by a Chunk Number, but is only used in SAM when an LOD Group uses multi-chunking (and 
            in this case, it is only used in the Supplemental Chunk Format, which is used to generate names for Chunks 2+ in a Chunk Set).
            </para>
            <para>
            The First Chunk Format is used to generate names for the first Asset Chunk in an Asset Chunk Set, or to generate names for Assets where multi-chunking is 
            not used or not applicable (such as the Terra Slicer tool). The Supplemental Chunk Format is used to generate names for Asset Chunks 2, 3, and so on, and is only 
            used by SAM.
            </para>
            <para>
            The default naming convention automatically generates its Formats according to whether the tool/component it is being used with has 2D or 3D properties, however 
            this is not possible when you create custom Naming Convention instances. As such, you need to explicitly setup your Format fields to use the third dimension 
            (%z - which is the layer) if it is necessary (which will only be the case when using SAM and a Streamable Grid with Axes set to Three Dimensional).
            </para>
            <para>
            You can find more information about 
            Naming Conventions in the Editor Guide for the Terra Slicer or SAM.
            </para>
            </summary>
            <title>NamingConvention Class</title>
            <category>Scriptable Assets</category>
            <navigationName>NamingConvention</navigationName>
            <fileName>NamingConvention.html</fileName>
            <syntax>public sealed class NamingConvention : <see href="http://docs.unity3d.com/ScriptReference/ScriptableObject.html">ScriptableObject</see>, <see cref="T:DeepSpaceLabs.Core.INamingConvention" href="INamingConvention.html">INamingConvention</see></syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.NamingConventionInterface">
            <summary>
            Represents a Naming Convention contract.
            </summary>
            <title>INamingConvention Interface</title>
            <category>Interfaces</category>
            <navigationName>INamingConvention</navigationName>
            <fileName>INamingConvention.html</fileName>
            <syntax>public interface INamingConvention</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.NamingConventionInterface.FirstChunkFormat">
            <summary>
            Gets the format of the naming convention that does not take chunking into account. This format is always used 
            with LODs that do not utilize multi chunking. If an LOD utilizes multi chunking but the UseNonChunkFormatForSingleChunkCells 
            property returns true, this format is also used for cells that only have a single chunk. If that property returns false, 
            the ChunkFormat is used for cells that only have a single chunk.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.NamingConventionInterface.SupplementalChunkFormat">
            <summary>
            Gets the format of the naming convention that takes chunking into account. This format is always used with LODs 
            that utilize multi chunking, for cells that have 2 or more chunks. For cells that only have a single chunk, 
            this format is used when the UseNonChunkFormatForSingleChunkCells property returns false. If that property 
            returns true, the NonChunkFormat is used for cells with single chunks.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.NamingConventionInterface.NumberingStartsAt0">
            <summary>
            Gets a value indicating whether the naming convention calls for row/column/layer numbers to start at 0.
            If false, the numbers will start at 1 instead.
            </summary>
            <type>bool</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PlayerMoverCharacterMotor">
            <summary>
            A simple modification of the standard Unity Character Motor script that adds PlayerMover implementations, making it 
            comptaible for use with <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grids</see>.
            <para>
            </para>
            </summary>
            <title>
            PlayerMoverCharacterMotor Class
            </title>
            <category>Player Movers</category>
            <navigationName>
            PlayerMoverCharacterMotor
            </navigationName>
            <fileName>PlayerMoverCharacterMotor.html</fileName>
            <syntax>
            public sealed class PlayerMoverCharacterMotor : <see cref="T:DeepSpaceLabs.SAM.PlayerMover" href="PlayerMover.html">PlayerMover</see>
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PlayerMoverFPSInputController">
            <summary>
            A simple modification of the standard FPS Input Controller designed to be used in conjunction with 
            the <see cref="T:DeepSpaceLabs.SAM.PlayerMoverCharacterMotor" href="PlayerMoverCharacterMotor.html">Player Mover Character Motor</see>. This 
            script is added automatically when you add a PlayerMoverCharacterMotor script.
            <para>
            </para>
            </summary>
            <title>
            PlayerMoverFPSInputController Class
            </title>
            <category>Player Movers</category>
            <navigationName>
            PlayerMoverFPSInputController
            </navigationName>
            <fileName>PlayerMoverFPSInputController.html</fileName>
            <syntax>
            public sealed class PlayerMoverFPSInputController : MonoBehaviour
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ReusableEnumerators">
            <summary>
            The ReusableEnumerators class is used to support a system of reuseable enumerators, which avoids the garbage generated by C#'s auto generated 
            iterator classes. You will typically not interact with this class directly, and if you decide to do so, you should do so with extreme caution. The 
            class is public so that external scripts (such as the AddressableLoader) can make use of the Reusable Enumerator system; it is not really intended to be used by 
            developers, at least not at the present time.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ReusableEnumerators.GetEnumeratorNotInUse``1">
            <summary>
            Gets an enumerator not currently in use for the given type. You do not need to return the enumerator once finished. The enumerator will mark 
            itself as not in use once its MoveNext returns fale.
            </summary>
            <typeparam name="T">The type of YieldEnumerator</typeparam>
            <returns>A YieldEnumerator object that is reusable. Each time a user needs to use an enumerator, you should call this method.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ReusableEnumerators.AddUser``1(System.Boolean)">
            <summary>
            If you wish to make use of a reusable enumerator for a given type, you need to register the class you will be using the enumerator in as a user 
            of the type. This way, once the type has no more users, its enumerators can be freed for garbage collection.
            </summary>
            <typeparam name="T">The type of the YieldEnumerator you wish to register as a user for.</typeparam>
            <param name="autoCreateDefaultEnumerator">If you are certain that at least one enumberator will be needed, pass in true or leave the argument blank. If you 
            are registering as a user but are not sure that the enumerator will be needed, pass in false. This will delay creation of the first enumerator until at 
            least one user ask for it via the GetEnumeratorNotInUse method.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ReusableEnumerators.RemoveEnumeratorNotInUse``1">
            <summary>
            Can be used to remove one enumerator not currently in use. Mostly useful if you have run some 1 time operation that resulted in a 
            bunch of enumerators that you know will not need to be used again.
            </summary>
            <returns>True if an enumerator was removed, false otherwise.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ReusableEnumerators.RemoveUser``1">
            <summary>
            Deregister as a user of the YieldEnumerator type. Once the type has 0 users, its enumerators are freed for garbage collection.
            </summary>
            <typeparam name="T">The type of YieldEnumerator to deregister from</typeparam>
        </member>
        <member name="T:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter">
            <summary>
            A World Shifter implementation that works in conjuction with a Standard Hierarchy Organizer (as such, 
            it can only be used when you are using a Standard Hiearchy Organizer). For other organizer or when 
            not using a organizer, you will need to implement a custom World Shifter.
            <para>
            This shifter also assumes that the chunks used are Game Objects. If not using Game Objects, you will need to 
            use a custom World Shifter.
            </para>
            </summary>
            <title>StandardHierarchyWorldShifter Class</title>
            <category>World Shifters</category>
            <navigationName>StandardHierarchyWorldShifter</navigationName>
            <fileName>StandardHierarchyWorldShifter.html</fileName>
            <syntax>
            public sealed class StandardHierarchyWorldShifter : <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">WorldShifter</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter.FireWorldShiftingEventAutomatically">
            <summary>
            Returns false, as we manually fire the World Shifting event
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter.FireWorldShiftedEventAutomatically">
            <summary>
            Returns false, as we manually fire the World Shifted event
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter.AwakeExtended">
            <summary>
            An implementation of logic that would normally go into Awake, but since that is used by the base class, we 
            put it here instead.
            </summary>
            <displayName id="AwakeExtended">AwakeExtended()</displayName>
            <syntax>protected sealed override void AwakeExtended()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter.OnDestroyExtended">
            <summary>
            An implementation of logic that would normally go into OnDestroy, but since that is used by the base class, we 
            put it here instead.
            </summary>
            <displayName id="OnDestroyExtended">
            OnDestroyExtended()
            </displayName>
            <syntax>
            protected virtual void OnDestroyExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter.IsConfiguredToMovePlayerFromActiveGrid(DeepSpaceLabs.SAM.ActiveGrid)">
            <summary>
            Executes a query to determine if the Shifter has been configured to move the Player associated 
            with the activeGrid. This is used by the Active Grid in certain situations to avoid double movements. Returns true 
            only if Move Players is enabled and the Active Grid is included in the Active Grids With Players array.
            </summary>
            <param name="activeGrid" type="ActiveGrid" link="ActiveGrid.html">
            The active grid with the Player.
            </param>
            <returns type="bool">
            True if the World Shifter has been configured to move the player, false otherwise.
            </returns>
            <displayName id="IsConfiguredToMovePlayerFromActiveGrid">
            IsConfiguredToMovePlayerFromActiveGrid(ActiveGrid)
            </displayName>
            <syntax>
            public sealed override bool IsConfiguredToMovePlayerFromActiveGrid(ActiveGrid activeGrid)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter.ShiftWorld">
            <summary>
            Implementation of the Shift World method, which shifts the transforms in the hierarchy (organized via a 
            Standard Hierarchy Organizer).
            </summary>
            <displayName id="ShiftWorld">
            ShiftWorld()
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; ShiftWorld()
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter.CalculateNumberOfTransformsToBeShifted">
            <summary>
            Uses the Standard Hierarchy Organizer and WhatToShift value to calculate the number of transforms that will be shifted.
            </summary>
            <returns type="int">
            The number of transforms that will be shifted.
            </returns>
            <displayName id="CalculateNumberOfTransformsToBeShifted">
            CalculateNumberOfTransformsToBeShifted()
            </displayName>
            <syntax>
            protected override int CalculateNumberOfTransformsToBeShifted()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.StandardHierarchyOrganizer">
            <summary>
            Provides a default implementation of the <see cref="T:DeepSpaceLabs.SAM.HierarchyOrganizer" href="HierarchyOrganizer.html">HierarchyOrganizer</see> 
            class, which is responsible for organizing the chunks of 
            worlds into manageable hierarchies. 
            <para>
            This class provides a small number of settings to give you decent control over how 
            the organization is performed, but for more fine tuned approaches you would be better off creating a custom class 
            that derives from <see cref="T:DeepSpaceLabs.SAM.HierarchyOrganizer" href="HierarchyOrganizer.html">HierarchyOrganizer</see> class.
            </para>
            <para>
            This Organizer can be used in conjunction with a 
            <see cref="T:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter" href="StandardHierarchyWorldShifter.html">Standard Hierarchy World Shifter</see>.
            </para>
            <para>
            If using multiple Worlds at the same time, each World must use a different instance of the Organizer!
            </para>
            </summary>
            <title>StandardHierarchyOrganizer Class</title>
            <category>Hierarchy Organizers</category>
            <navigationName>StandardHierarchyOrganizer</navigationName>
            <fileName>StandardHierarchyOrganizer.html</fileName>
            <syntax>
            public sealed class StandardHierarchyOrganizer : <see cref="T:DeepSpaceLabs.SAM.HierarchyOrganizer" href="HierarchyOrganizer.html">HierarchyOrganizer</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GroupObjectsFromSameWorldGridCell">
            <summary>
            Gets a value indicating whether objects in this hiearchy organizer that reside within the same World Grid Cell 
            are set to be grouped together under a common parent.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GroupObjectsFromSameZone">
            <summary>
            Gets a value indicating whether objects in this hiearchy organizer that reside within the same Zone are set to be 
            grouped together under a common parent.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GroupObjectsFromSameWorldGrouping">
            <summary>
            Gets a value indicating whether objects in this hiearchy organizer that reside within the same World Grouping are set to be 
            grouped together under a common parent.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GroupObjectsFromSameLOD">
            <summary>
            Gets a value indicating whether objects in this hiearchy organizer that reside on the same LOD are set to be 
            grouped together under a common parent.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GroupObjectsFromSameWorldCell">
            <summary>
            Gets a value indicating whether objects in this hiearchy organizer that belong to the same World Cell are set to be 
            grouped together under a common parent.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.TransformRetrievalDisabled">
            <summary>
            Gets a value indicating whether the transform retrieval has been disabled. If disabled, you 
            cannot use the GetAll...Transforms methods!
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.RootOfEverything">
            <summary>
            Gets the root transform of all objects in the hierarchy, if such a root transform exist. If none of the grouping options are enabled, 
            this will return null.
            </summary>
            <type>Transform</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GetAllChunkTransforms">
            <summary>
            Gets a method that can be used to retrieve all transforms of the chunks themselves (game objects associated World Cells) 
            that are a part of this organizer. Can only be used when Disable Transform Retrieval is disabled.
            <para>
            Note, this method will work regardless of how your hiearchy is setup, so long as Disable Transform Retrieval is disabled.
            </para>
            <para>
            Using this method will not generate garbage unless the input list is not large enough to fit all the Transforms.
            </para>
            </summary>
            <type>
            Action&lt;List&lt;Transform&gt;&gt;
            </type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GetAllWorldGridCellTransforms">
            <summary>
            Gets a method that can be used to retrieve all World Grid Cell Transforms (used to group chunks that reside in the same  
            World Grid Cell, which is a cell from the World's imaginary World Grid) currently in this hierarchy. 
            Can only be used when Disable Transform Retrieval is disabled and Group Objects From World Grid Cell is enabled.
            <para>
            Note, using this method will not generate garbage unless the input list is not large enough to fit all the Transforms.
            </para>
            </summary>
            <type>
            Action&lt;List&lt;Transform&gt;&gt;
            </type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GetAllZoneTransforms">
            <summary>
            Gets a method that can be used to retrieve all Zone Transforms (used to group chunks from the same 
            Zone) currently in this hierarchy. 
            Can only be used when Disable Transform Retrieval is disabled and Group Objects From Same Zone is enabled.
            <para>
            Note, using this method will not generate garbage unless the input list is not large enough to fit all the Transforms.
            </para>
            </summary>
            <type>
            Action&lt;List&lt;Transform&gt;&gt;
            </type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GetAllWorldGroupingTransforms">
            <summary>
            Gets a method that can be used to retrieve all World Grouping Transforms (used to group chunks from the same 
            World Grouping) currently in this hierarchy. 
            Can only be used when Disable Transform Retrieval is disabled and Group Objects From Same World Grouping is enabled.
            <para>
            Note, using this method will not generate garbage unless the input list is not large enough to fit all the Transforms.
            </para>
            </summary>
            <type>
            Action&lt;List&lt;Transform&gt;&gt;
            </type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GetAllLODTransforms">
            <summary>
            Gets a method that can be used to retrieve all LOD Transforms (used to group chunks from the same 
            LOD) currently in this hierarchy. 
            Can only be used when Disable Transform Retrieval is disabled and Group Objects From Same LOD is enabled.
            <para>
            Note, using this method will not generate garbage unless the input list is not large enough to fit all the Transforms.
            </para>
            </summary>
            <type>
            Action&lt;List&lt;Transform&gt;&gt;
            </type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.GetAllWorldCellTransforms">
            <summary>
            Gets a method that can be used to retrieve all World Cell Transforms (used to group different chunks from the same 
            World Cell) currently in this hierarchy. 
            Can only be used when Disable Transform Retrieval is disabled and Group Objects From Same World Cell is enabled.
            <para>
            Note, using this method will not generate garbage unless the input list is not large enough to fit all the Transforms.
            </para>
            </summary>
            <type>
            Action&lt;List&lt;Transform&gt;&gt;
            </type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.NumberOfWorldGridCellTransforms">
            <summary>
            Gets a value indicating how many World Grid Cell Transforms are present in the hierarchy.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.NumberOfZoneTransforms">
            <summary>
            Gets a value indicating how many Zone Transforms are present in the hierarchy.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.NumberOfWorldGroupingTransforms">
            <summary>
            Gets a value indicating how many World Grouping Transforms are present in the hierarchy.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.NumberOfLODTransforms">
            <summary>
            Gets a value indicating how many LOD Transforms are present in the hierarchy.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.NumberOfWorldCellTransforms">
            <summary>
            Gets a value indicating how many World Cell Transforms are present in the hierarchy.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.NumberOfChunkTransforms">
            <summary>
            Gets a value indicating how many Chunk Transforms are present in the hierarchy.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.InitializeAdditional">
            <summary>
            Initializes additional stuff for the standard hierarchy organizer.
            </summary>
            <displayName id = "InitializeAdditional">
            InitializeAdditional()
            </displayName>
            <syntax>
            public sealed override void InitializeAdditional()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.AddChunkToHierarchy(System.Object,DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Adds a chunk (game object) to the hierarchy.
            </summary>
            <param name="chunk" type="GameObject">
            The chunk (game object) to add to the hierarchy.
            </param>
            <param name="worldCellChunkBelongsTo" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to. You can use information from the World Cell to 
            help organize the object into the hierarchy, for instance by using the CellOnEndlessGrid,  
            CellOnWorldGrid, and DoesCellHaveMultipleChunks properties directly or by using the 
            WorldGrouping, ZoneIndex and LevelOfDetail properties in conjunction with the convenience methods of 
            the base HierarchyOrganizer class (
            <see cref="M:DeepSpaceLabs.SAM.HierarchyOrganizer.GetLODGroupName(DeepSpaceLabs.SAM.WorldCell)" href="HierarchyOrganizer.html#GetLODGroupName">GetLODGroupName</see>, 
            <see cref="M:DeepSpaceLabs.SAM.HierarchyOrganizer.IsWorldGroupingChunkIsOn3D(DeepSpaceLabs.SAM.WorldCell)" href="HierarchyOrganizer.html#IsWorldGroupingChunkIsOn3D">IsWorldGroupingChunkIsOn3D</see>, and 
            <see cref="M:DeepSpaceLabs.SAM.HierarchyOrganizer.DoesLODChunkIsPartOfUtilizeChunking(DeepSpaceLabs.SAM.WorldCell)" href="HierarchyOrganizer.html#DoesLODChunkIsPartOfUtilizeChunking">DoesLODChunkIsPartOfUtilizeChunking</see>).
            </param>
            <displayName id = "AddChunkToHierarchy">
            AddChunkToHierarchy(GameObject, WorldCell)
            </displayName>
            <syntax>
            public sealed override void AddChunkToHierarchy(GameObject chunk, WorldCell worldCellChunkBelongsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StandardHierarchyOrganizer.RemoveChunkFromHierarchy(System.Object,DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Removes a chunk (game object) from the hierarchy. This should be relatively straightfoward and should not 
            require the lod Group Name or organizational info.
            </summary>
            <param name="chunk" type="GameObject">
            The chunk (game object) to remove from the hierarchy.
            </param>
             <param name="worldCellChunkBelongsTo" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <displayName id = "RemoveChunkFromHierarchy">
            RemoveChunkFromHierarchy(GameObject, WorldCell)
            </displayName>
            <syntax>
            public sealed override void RemoveChunkFromHierarchy(GameObject chunk, WorldCell worldCellChunkBelongsTo)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.MatPropBlockTransitioner">
            <summary>
            A custom implementation of a 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see>. 
            Please take a look at that page before continuing, as it provides an overview of what this class is responsible for.
            <para>
            This particular transition controller requires either a shader compatible with Unity's built-in LODGroup component + material 
            property blocks, or 
            a custom shader that makes use of a float that can be set using a material property block.
            </para>
            <para>
            It works by performing the transition over a fixed time period, 
            where the float in the shader (or built in lod crossfade vector value if using 'Use Unity Crossfade') 
            is set to a value between 0 (at start) and 1 (at end) for cells transitioning 
            to a "visible" state, and to a value between 1 (at start) and 0 (at end) 
            for cells transitioning to an "invisible" state. It is up to your shader to determine how this 
            float property is used, for instance by implementing true transparency or using alpha clipping (dithering).
            </para>
            <para>
            This transitioner will perform a separate transition for the root chunk and its children, grandchildren, etc., 
            so long as those objects contain a Renderer component. Also note that the material property block is applied at 
            the Renderer level, meaning it is applied to all Materials on the Renderer that use the specified shader property. 
            </para>
            <para>If you only want a specific Material to be affected, you will need to create a custom Transitioner.
            </para>
            <para>
            There is a special optimization that is performed when a renderer is not in view of the camera, whereby the renderer is immediately 
            set to its final state (either visible or invisible). This results in only renderers in view of the player being 
            transitioned, which speeds up 
            the transition process, which in turn speeds up the entire World update.
            </para>
            <para>
            The Renderer.IsVisible property is used to determine if a renderer is visible to any cameras. Within the editor, 
            the Scene View camera counts as a camera in this capacity, so if a game object visible in your scene view but not 
            in the game view, you will still notice it being transitioned.
            </para>
            <para>
            The difference between this component and the PerMaterialTransitioner is very subtle. 
            The PerMaterialTransitioner should generally only be used with the Scriptable 
            Render Pipeline batcher, in situations where you are using the same shader variant with many different meshes/materials. 
            If not using the SRP or you are using many instances of 
            the same mesh and material, you will probably be better off using this transitioner. 
            You can easily test with each transitioner to see which one is more performant.
            </para>
            </summary>
            <title>MatPropBlockTransitioner Abstract Class</title>
            <category>Visual Transition Controllers</category>
            <navigationName>MatPropBlockTransitioner</navigationName>
            <fileName>MatPropBlockTransitioner.html</fileName>
            <syntax>public sealed class MatPropBlockTransitioner : <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">CellVisualTransitionController</see></syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.AwakeExtended">
            <summary>
            Override of AwakeExtended
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.CanWorldCellsBeTransitioned(DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Queries the Mat Prop Block Transitioner to determine if World Cell's using the Chunk Type specified can be transitioned at the 
            present time.
            </summary>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type you want to find out whether is able to be transitioned.
            </param>
            <returns type="type">
            Always returns true if the Chunk Type is Non_Terrain_Game_Object. Also returns true if the Chunk Type is Unity_Terrain and 
            Allow Use With Terrain is enabled in the inspector. Otherwise returns false.
            </returns>
            <displayName id="CanWorldCellsBeTransitioned">
            CanWorldCellsBeTransitioned(ChunkType)
            </displayName>
            <syntax>
            public sealed override bool CanWorldCellsBeTransitioned(ChunkType ChunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.ResetToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the ResetToVisibleState method on the 
            <see cref="!:CellVisualTransitionController.ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)" href="CellVisualTransitionController.html#ResetToVisibleState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            </param>
            <displayName id="ResetToVisibleState">
            ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.ResetToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the ResetToInvisibleState method on the 
            <see cref="!:CellVisualTransitionController.ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)" href="CellVisualTransitionController.html#ResetToInvisibleState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the invisible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            </param>
            <displayName id="ResetToInvisibleState">
            ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public sealed override void ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells,  ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.ImmediatelyTransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the ImmediatelyTransitionToVisibleState method on the 
            <see cref="M:DeepSpaceLabs.SAM.CellVisualTransitionController.ImmediatelyTransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)" href="CellVisualTransitionController.html#ImmediatelyTransitionToVisibleState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="ImmediatelyTransitionToVisibleState">
            ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override void ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.TransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the TransitionToActivatedState method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#TransitionToActivatedState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method. If you are trying to understand how the Mat Prop Block 
            Transitioner works, please take a look at the class summary.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to an "activated" state. "Activated" in this sense just means the chunks should be made visible to the 
            player (assuming the cell is not being culled by your culling system [if present]). All cells are part of the same World Grouping and LOD.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToVisibleState">
            TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.TransitionToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the TransitionToDeactivatedState method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#TransitionToDeactivatedState">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method. If you are trying to understand how the Mat Prop Block 
            Transitioner works, please take a look at the class summary.
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to a "deactivated" state. "Deactivated" in this sense just means the chunks should be made invisible to the 
            player (assuming the cell is not being culled by your culling system [if present]). All cells are part of the same World Grouping and LOD.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToInvisibleState">
            TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MatPropBlockTransitioner.TransitionBetweenLevelsOfDetail(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType,DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            Please take a look at the description for the TransitionBetweenLevelsOfDetail method on the 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html#TransitionBetweenLevelsOfDetail">CellVisualTransitionController Base Class</see> 
            before continuing, as this description outlines all that you need to know regarding this method. If you are trying to understand how the Mat Prop Block 
            Transitioner works, please take a look at the class summary.
            </summary>
            <param name="transitionFrom" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned from 
            (i.e., they are what is currently activated that we want to deactivate). 
            This list is read only and may contain cells from different LODs.
            </param>
            <param name="transitionFromCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionFrom World Cells.
            </param>
            <param name="transitionTo" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned to 
            (i.e., they are what is currently deactivated that we want to activate). 
            This list is read only and all cells are from the same World Grouping and LOD.
            </param>
            <param name="transitionToCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionTo World Cells.
            </param>
            <displayName id="TransitionBetweenLevelsOfDetail">
            TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt;, ChunkType, ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt; transitionFrom, ChunkType transitionFromCellsChunkType, ReadOnlyList&lt;WorldCell&gt; transitionTo, ChunkType transitionToCellsChunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.StaticBatcherListener">
            <summary>
            A World Grouping Listener that performs runtime static batching on World Cell Asset Chunks (and children).
            <para>
            The batching is very rudimentary. Basically, for each World Cell, the 
            batcher collects all Game Objects (which can be the Asset Chunk itself or a descendant of the Asset Chunk) 
            with a MeshRenderer component, for each Asset Chunk attached to the World Cell.
            </para>
            <para>
            It then batches together these renderers using StaticBatchingUtility.Combine, with the first Asset Chunk game object 
            set as the parent.
            </para>
            <para>
            Only renderers that are associated with the same World Cell are batched together. This is most useful for situations where 
            each World Cell may contain one or more chunks with a lot of children that are batchable.
            </para>
            <para>
            In order for batching to work, each game object to be batched must adhere to the following guidelines:
            <br></br>
            </para>
            <para indented="true">
            1) The GameObject is active. You should either ensure the Grouping has Auto Activation enabled or you should activate the Asset Chunks 
            manually in a Grouping Listener set before this one in the array.
            </para>
            <para indented="true">
            2) The GameObject has a Mesh Filter component, and that component is enabled.
            </para>
            <para indented="true">
            3) The Mesh Filter component has a reference to a Mesh.
            </para>
            <para indented="true">
            4) The mesh has a vertex count greater than 0.
            </para>
            <para indented="true">
            5) The mesh has not already been combined with another Mesh (this component uses GetComponentsInChildren to gather 
            the game objects to be batched, and checks to make sure the first child in the collected children is not already 
            batched using its isPartOfStaticBatch property).
            </para>
            <para indented="true">
            6) The GameObject has a Mesh Renderer component, and that component is enabled.
            </para>
            <para indented="true">
            7) The Mesh Renderer component does not use any Material with a shader that has the DisableBatching tag set to true.
            </para>
            <para indented="true">
            8) All game objects to be batched use the same Material.
            </para>
            <para indented="true">
            9) Meshes you want to batch together use the same vertex attributes. For example Unity can batch meshes that use vertex position, vertex normal, and one UV with one another, but not with meshes that use vertex position, vertex normal, UV0, UV1, and vertex tangent.
            </para>
            <para indented="true">
            10) Meshes must have read/write enabled.
            </para>
            <para>
            Because of requirement 8, all Asset Chunks and children of those Asset Chunks on the World Grouping (associated with the same 
            LOD Group), must use the same material. This may require you to create more World Groupings than you would normally use, and 
            the drawbacks of that must be balanced again the performance gains of using static batching.
            </para>
            </summary>
            <title>
            Static Batcher Listener
            </title>
            <category>World Grouping Listeners</category>
            <navigationName>
            StaticBatcherListener
            </navigationName>
            <fileName>StaticBatcherListener.html</fileName>
            <syntax>
            public sealed class StaticBatcherListener : <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StaticBatcherListener.IgnoreLODTransitions">
            <summary>
            Returns false.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StaticBatcherListener.YieldBehaviorAfterMethodExecution">
            <summary>
            Returns ListenerYieldBehaviour.YieldOrContinue. 
            </summary>
            <type link="ListenerYieldBehaviour.htmml">ListenerYieldBehaviour</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StaticBatcherListener.OnAfterCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Called after a batch of cells are activated. The batching process occurs here, as Unity requires the game objects 
            to be active in order for batching to work.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells that were just Activated.
            </param>
            <param name="batchNumber" type="int">
            The batch of cells that were just Activated.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches of cells that will be passed to this method for the current grouping update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the batch of cells are part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being executed in immediate mode.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterCellsInBatchActivated">
            OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TimeSlicedExecutionController">
            <summary>
            An Exeuction Controller which tries to limit the amount of time the component that uses it exeucutes for 
            in a given frame. ShouldStartExecuting will always return true and therefore this controller does not 
            ever stop the component from beginning execution.
            <para>
            If using multiple Worlds at the same time, each World must use a different instance of the Execution Controller!
            </para>
            </summary>
            <title>
            TimeSlicedExecutionController Class
            </title>
            <category>Execution Controllers</category>
            <navigationName>
            TimeSlicedExecutionController
            </navigationName>
            <fileName>TimeSlicedExecutionController.html</fileName>
            <syntax>
            public sealed class TimeSlicedExecutionController : <see cref="T:DeepSpaceLabs.SAM.ExecutionController" href="ExecutionController.html">ExecutionController</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TimeSlicedExecutionController.TimeSlice">
            <summary>
            The amount of time (in seconds) that the component that uses this execution controller can execute for (not guaranteed).
            </summary>
            <type>double</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimeSlicedExecutionController.ShouldStartExecuting">
            <summary>
            For every frame that the component which uses this execution controller is set to execute, this method will 
            be queried to determine whether the component should execute.
            </summary>
            <returns type="bool">
            Always returns true.
            </returns>
            <displayName id="ShouldStartExecuting">
            ShouldStartExecuting()
            </displayName>
            <syntax>
            public override bool ShouldStartExecuting()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimeSlicedExecutionController.ShouldContinueExecuting">
            <summary>
            When the component which uses the execution controller wants to know whether it should yield for a frame or 
            continue executing, this method is queried.
            <para>
            Note there are a lot of methods that don't use this strategy, but instead need to always yield for a frame 
            or on some other property (WaitForSeconds for example).
            </para>
            </summary>
            <returns type="bool">
            Returns true when the total time the Current frame has executed for is less than 
            <see cref="P:DeepSpaceLabs.SAM.TimeSlicedExecutionController.TimeSlice">TimeSlice</see>.
            </returns>
            <displayName id="ShouldContinueExecuting">
            ShouldContinueExecuting()
            </displayName>
            <syntax>
            public override bool ShouldContinueExecuting()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldCellVisualizer">
            <summary>
            A special World Grouping Listener that can be added to a World Grouping in order to visualize the World Cell's bounds 
            in the Scene and Game view. This 
            class has been setup to be usable with multiple World Groupings and Worlds, however if you want each World 
            Grouping to use a different color for the 
            visualization, you will need to create separate visualizers for each.
            </summary>
            <title>
            WorldCellVisualizer Class
            </title>
            <category>World Grouping Listeners</category>
            <navigationName>
            WorldCellVisualizer
            </navigationName>
            <fileName>WorldCellVisualizer.html</fileName>
            <syntax>
            public sealed class WorldCellVisualizer : <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCellVisualizer.IgnoreLODTransitions">
            <summary>
            Overriden to return false, because the visualizer tracks World Cells and thus needs to know when lod transitions occur (because the 
            actual WorldCell objects changes when this happens).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCellVisualizer.YieldBehaviorAfterMethodExecution">
            <summary>
            Overriden to return false.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCellVisualizer.OnBeforeGroupingUpdated(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Called before a grouping is updated to perform prep work before cells are added/removed
            </summary>
            <param name="world" type="World" link="World.html">
            The World whose grouping is about to be updated.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone that is about to be updated.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping that is about to be updated.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being run in immediate mode.
            </param>
            <displayName id="OnBeforeGroupingUpdated">
            OnBeforeGroupingUpdated(World, int, int, bool)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; OnBeforeGroupingUpdated(World world, int zoneIndex, int groupingIndex, bool immediateMode)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCellVisualizer.OnAfterAllCellsActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Overriden so that the visualizer receives notification after all cells are activated. This is used to add these cells to the 
            tracked collection so that the visualizer can visualize the cells. This method is used because it functions better with the duplication 
            world reset strategy.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells that have been activated.
            </param>
            <param name="batchNumber" type="int">
            The number of the batch (1 out of 19, for instance). The visualizer does not use this information.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total number of batches in the current World update, i.e., the total number of times this 
            method will be called for the current World Update. The visualizer does not use this information.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the cells are part of a LOD transition.
            </param>
            <param name="immediateMode" type = "bool">
            Whether this method should execute in a single frame.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsActivated">
            OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCellVisualizer.OnBeforeAnyCellsDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Overriden so that the visualizer receives notification before any cells have been deactivated. This is used to remove these cells from the 
            tracked collection. This method is used because it functions better with the duplication 
            world reset strategy.
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells that will be deactivated.
            </param>
            <param name="batchNumber" type="int">
            The number of the batch (1 out of 19, for instance).
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total number of batches in the current World update, i.e., the total number of times this 
            method will be called for the current World Update. The visualizer does not use this information.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the cells are part of a LOD transition. Will always be false since the visualizer ignores LOD transitions.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeAnyCellsDeactivated">
            OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldCellReference">
            <summary>
            This is basically a wrapper for a <see cref="P:DeepSpaceLabs.SAM.WorldCellReference.WorldCell" href="WorldCell.html">WorldCell</see>. 
            It will be added to each game object (chunk) that is loaded for your world, so long 
            as the Add World Cell References option is enabled on your World component, World Grouping, or LOD. This monobehaviour is solely meant to store a 
            reference to the WorldCell the chunk/chunk belongs to, as well as the index of the chunk/chunk in the World Cell for multi chunk 
            situations. The idea is to give you a way to access the WorldCell (which contains a bunch of useful information about the object and 
            the cell it belongs to), in situations where you have access to the object itself. You can use GetComponent&lt;WorldCellReference&gt; 
            to access the WorldCellReference class, and then the WorldCell property to access the WorldCell itself.
            <para>
            By default, World Cell References are disabled, to avoid allocating extra memory for a potentially uneeded use case.
            </para>
            </summary>
            <title>
            WorldCellReference Class
            </title>
            <category>Secondary Components</category>
            <navigationName>
            WorldCellReference
            </navigationName>
            <fileName>WorldCellReference.html</fileName>
            <syntax>
            public sealed class WorldCellReference : MonoBehaviour
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCellReference.WorldCell">
            <summary>
            Gets the World Cell the game object belongs to.
            </summary>
            <type link="WorldCell.html">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCellReference.ChunkIndex">
            <summary>
            The chunk index of this game object. Remember that when using multi chunking, a World Cell can "own" several chunks.
            </summary>
            <type>int</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent">
            <summary>
            Provides a base implementation for non component classes that wish to implement the 
            <see cref="T:DeepSpaceLabs.SAM.IWorldGroupingListener" href="IWorldGroupingListener.html">IWorldGroupingListener</see> interface. 
            Unlike the WorldGroupingListener, 
            these are normal C# classes and cannot 
            be hooked up to the World Grouping in the editor, but instead need to be passed to the World Grouping via the World's 
            AddWorldGroupingListener method. Otherwise, they work effectively the same as the WorldGroupingListener derived classes.
            <para>
            World Grouping Listeners can be assigned to a World Grouping in order to receive notification before or after the 
            World Grouping is updated, and also before/after World Cells on the World Grouping are 
            activated and/or deactivated. Previously, this behaviour 
            was achieved via Cell Actions attached to the individual Asset Chunks of a cell, however this system was cumbersome as 
            it required you to attach a component to each 
            chunk game object.
            </para>
            <para>
            The new system utilizes one or more components at the World Grouping level to perform actions on a 
            collection of cells at a time. You can also utilize this system to keep 
            track of what cells are currently active, by adding the cells from one of the 'Activated' methods and removing them 
            from one of the 'Deactivated' methods.
            </para>
            <para>
            The most useful situation I can think of for doing this when trying to add integration for 3rd party assets.
            </para>
            <para>
            If a method you want to use does not need to utilize multiple frames, override the method and place the 
            code you want executed as normal, then return 
            SimpleYieldBreakEquivalentEnumerator.Instance. This will ensure no garbage is generated when the method is called.
            </para>
            </summary>
            <title>WorldGroupingListenerNonComponent Abstract Class</title>
            <category>World Grouping Listeners</category>
            <navigationName>WorldGroupingListenerNonComponent</navigationName>
            <fileName>WorldGroupingListenerNonComponent.html</fileName>
            <syntax>public abstract class WorldGroupingListenerNonComponent : <see cref="T:DeepSpaceLabs.SAM.IWorldGroupingListener" href="IWorldGroupingListener.html">IWorldGroupingListener</see></syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IsEnabled">
            <summary>
            Whether the listener is currently enabled. Its methods will only be called if it is enabled. By defualt this will always return 
            true, though you can set it to a different value if you desire.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions">
            <summary>
            Gets a value indicating whether the listener's methods will be called during LOD transitions. When an LOD transition occurs, technically a World Cell is 
            deactivated (the old LOD) and a World Cell is activated (the new LOD), however generally it is better to think of these two World Cells as the same Cell 
            that is just changing its Asset Chunks out. With that said, a lot of logic may be directed at the World Cell's Asset Chunks, and if that is the case with 
            your WorldGroupingListener, you should set this property to return false, because the Asset Chunks will change during an LOD transition. The actuall WorldCell 
            object instance will also change, so if you're storing these WorldCell objects in some way, you will also need to set this to false so that you can remove 
            the old World Cells and add the new ones.\n\nIf, on the other hand, your WorldGroupingListeners only utilize data related to the World Cell's 
            (such as position, Streamable Grid Indexes, etc.), this data will not change during an LOD Transition, so you can ignore them.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.YieldBehaviorAfterMethodExecution">
            <summary>
            Gets a value that tells the World the Listener is being used with whether it should 
            yield control (to the Unity Engine and other components your game might have), after fully executing one of its methods. 
            <para>
            The options in the ListenerYieldBehaviour enumerator give you a great 
            deal of control.
            </para>
            <para>
            NeverYield can be chosen if you need to ensure that the next Listener to run runs immediately after this one finishes.
            </para>
            <para>
            AlwaysYield, on the other hand, can be used to force the World to yield for at least a frame, which might be necessary to 
            allow whatever code you've just run to "ferment".
            </para>
            <para>
            Finally, YieldOrContinue can be used if you don't really care one way or the other 
            whether the World yields control, as it will let the Execution Controller used by the World decide.
            </para>
            </summary>
            <type link="ListenerYieldBehaviour.html">ListenerYieldBehaviour</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnBeforeGroupingUpdated">
            <summary>
            Returns a value indicating whether the World Grouping this WorldGroupingListenerNonComponent is linked to should call the 
            OnBeforeGroupingUpdated method. Please note, it is not necessary to 
            worry about this property. All you need to do is override the OnBeforeGroupingUpdated method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            OnBeforeGroupingUpdated is useful because it is called regardless of whether any cells will be activated or deactivated for the 
            given World Grouping. Therefore, you can use it to perform logic that is not dependent on cells being specifically activated or deactivated. 
            If your logic is dependent on activated or deactivated cells being present, use the OnBeforeAnyCellsActivated or 
            OnBeforeAnyCellsDeactivated methods instead, utilizing the batchNumber and totalBatchesToExpect to find the last call to the method 
            and performing the logic their, so it is only performed once.
            </para>
            <para>
            Note the method is called regardless of the IgnoreLODTransitions properties value, so long as it is overriden.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnBeforeAnyCellsDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeAnyCellsDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnBeforeCellsInBatchDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeCellsInBatchDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnAfterCellsInBatchDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterCellsInBatchDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnAfterAllCellsDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterAllCellsDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnBeforeAnyCellsActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeAnyCellsActivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnBeforeCellsInBatchActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnBeforeCellsInBatchActivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnAfterCellsInBatchActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterCellsInBatchActivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnAfterAllCellsActivated">
            <summary>
            Returns a value indicating whether the World Grouping this World Grouping Listener is linked to should call the 
            OnAfterAllCellsActivated method. Please note, when deriving from WorldGroupingListenerNonComponent, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.CallOnAfterGroupingUpdated">
            <summary>
            Returns a value indicating whether the World Grouping this WorldGroupingListenerNonComponent is linked to should call the 
            OnAfterGroupingUpdated method. Please note, it is not necessary to 
            worry about this property. All you need to do is override the OnAfterGroupingUpdated method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            OnAfterGroupingUpdated is useful because it is called regardless of whether any cells have been activated or deactivated for the 
            given World Grouping. Therefore, you can use it to perform logic that is not dependent on cells being specifically activated or deactivated. 
            If your logic is dependent on activated or deactivated cells being present, use the OnAfterAllCellsActivated or 
            OnAfterAllCellsDeactivated methods instead, utilizing the batchNumber and totalBatchesToExpect to find the last call to the method 
            and performing the logic their, so it is only performed once.
            </para>
            <para>
            Note the method is called regardless of the IgnoreLODTransitions properties value, so long as it is overriden.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.DetermineMethodCalls">
            <summary>
            Computes the values of the the Call... properties 
            (CallOnBeforeGroupingUpdated, CallOnBeforeAnyCellsDeactivated, etc.) based on whether 
            each method corresponding to each property has been overriden in your derived class.
            </summary>
            <displayName id="DetermineMethodCalls">
            DetermineMethodCalls()
            </displayName>
            <syntax>
            public void DetermineMethodCalls()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.PrecomputeUseWithLODValues">
            <summary>
            Since the default <see cref="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.UseWithLOD(System.Int32)" href="#UseWithLOD">UseWithLOD</see> 
            implementation is configured to always return true, this method is configured to do nothing.
            <para>
            If you have overriden UseWithLOD, you may want to override this method to precompute data that is used by 
            your UseWithLOD implementation.
            </para>
            <para>
            Note that this method is called once by each World Grouping using the Listener, so it may be called multiple times 
            in some cases. Usually, you should have some sort of safeguard in place to ensure the precomputation logic 
            only runs once.
            </para>
            </summary>
            <displayName id="PrecomputeUseWithLODValues">
            PrecomputeUseWithLODValues()
            </displayName>
            <syntax>
            public virtual void PrecomputeUseWithLODValues()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.UseWithLOD(System.Int32)">
            <summary>
            This method is queried before any of the methods that use cells are called, to determine if that method should be 
            invoked for the current group of cells, given the active LOD of those cells (remember, all cells in a batch 
            are always gauranteed to have the same active LOD).
            <para>
            It is virtually implemented to return true for all LODs. Override it to provide custom criteria for whether a 
            particular LOD should be used with the Listener.
            </para>
            <para>
            The value returned by this method is not cached. Each time one of the methods would be called, the method is called.
            </para>
            <para>
            This gives you a great deal of freedom, as you can adjust which LODs the Listener is being used with on the fly at runtime.
            </para>
            <para>
            However, if you know that the LODs that the Listener is being used will not change at runtime, and the computation 
            used to determine if an LOD should be used by the Listener is expensive, you should cache the computed value for each 
            LOD and use that when the method is called. Typically, should do this in AwakeExtended, so that the cached values can be used 
            as early as Start.
            </para>
            <para>
            The value is applied universally across all method calls that use cells (OnBeforeAnyCellsDeactivated, OnBeforeCellsInBatchDeactivated, 
            etc.). If you use more than 1 of these methods and need to use different criteria for determining LOD use for each one, 
            you should return true when UseWithLOD is called and instead filter each LOD within the actual methods that process the cells.
            </para>
            </summary>
            <param name="LOD" type="int">
            The active LOD of the World Cells that one of the methods (OnBeforeAnyCellsDeactivated, 
            OnBeforeCellsInBatchDeactivated, etc.) is about to be invoked for.
            <para>
            This value is 1 based, such that the first (highest quality) LOD is 1.
            </para>
            </param>
            <returns type="type">
            Return true if you want the method (OnBeforeAnyCellsDeactivated, OnBeforeCellsInBatchDeactivated, 
            etc.) to be called for the World Cells of the LOD, or false otherwise.
            </returns>
            <displayName id="UseWithLOD">
            UseWithLOD(int)
            </displayName>
            <syntax>
            public virtual bool UseWithLOD(int LOD)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnGroupingLinkEstablished(DeepSpaceLabs.SAM.World,System.Int32,System.Int32)">
            <summary>
            Called by the World when a Zone Grouping is linked to a World Grouping Listener.
            <para>
            This can be used to verify configuration settings or perform one time setup for the World and 
            grouping, rather than placing this setup code in the other On... methods which is less efficient.
            </para>
            <para>
            By default the method does nothing; override to implement logic that only needs to run once for the Grouping.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The World the Grouping belongs to.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the Zone Groupings whose link was established.
            </param>
            <param name="groupingIndex" type="int">
            The index of the grouping associated with the Zone Grouping whose link was established.
            </param>
            <displayName id="OnGroupingLinkEstablished">
            OnGroupingLinkEstablished(World, int, int)
            </displayName>
            <syntax>
            public virtual void OnGroupingLinkEstablished(World world, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnGroupingLinkRemoved(DeepSpaceLabs.SAM.World,System.Int32,System.Int32)">
            <summary>
            Called by the World when a Zone Grouping link to a World Grouping Listener is removed. This occurs when the World Grouping Listener 
            is removed using the World's RemoveWorldGroupingListener method or if the World is destroyed.
            <para>
            This can be used to cleanup data that was created in the OnGroupingLinkEstablished method.
            </para>
            <para>
            By default the method does nothing; override to implement logic that only needs to run once for the Grouping.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The World the Grouping belongs to.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the Zone Groupings whose link was removed.
            </param>
             <param name="groupingIndex" type="int">
            The index of the grouping associated with the Zone Grouping whose link was removed.
            </param>
            <displayName id="OnGroupingLinkRemoved">
            OnGroupingLinkRemoved(World, int, int)
            </displayName>
            <syntax>
            public virtual void OnGroupingLinkRemoved(World world, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnBeforeAnyCellsDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called before any cells have been deactivated during the current World Grouping Update, 
            for all cells that the World determines need to be removed/deactivated completely, and also for cells which are being 
            removed/deactivated as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that. This method is also called before duplicating a world, before the duplication process begins, with the 
            input cells being the old cells which are about to be duplicated.
            <para>
            Each of the OnCells...Deactivated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors assigned, and the neighbors Asset Chunks will be in an ACTIVATED state.
            </para>
            <para>
            This method is ideal for situations where you need to perform neigbor related cell specific actions that are not time sensitive, since the 
            actual deactivation of the cells will take place some frames after this method is called.
            </para>
            <para>
            In addition, you SHOULD USE this method for removing World Cells or World Cell related data from an internal collection 
            such as a Dictionary.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which will be deactivated in a short amount of time.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeAnyCellsDeactivated">
            OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnBeforeCellsInBatchDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called right before a batch of cells is set to be deactivated during the current World Update (deactivation 
            involves transitioning the cells to a non visible state, removing them from any HierarchyOrganizers, and removing them 
            from the internal collection of World Cells so that they are no longer "part" of the Streamable World Grouping they were a part of), 
            for all cells that the World determines need to be removed completely, and also for cells which are being 
            removed as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Removed methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks (game objects) present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors, however the state of the neighbors cannot be predicted, since this 
            method may be called before or after other cells that are to be removed have been deactivated. For example, one of its neighbors 
            may be a cell that will be LOD transitioned, so while currently its neighbor is a cell with LOD 1, once all LOD transitions are 
            processed, its new neighbor might be the same cell but of LOD 2. Or in another example, a neighbor may be not present currently, 
            but after adding new cells, may become present. As such, it is not recommended to carry out any neighbor based logic here. Use the 
            OnBeforeAnyCellsDeactivated method instead!
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right before a cell is 
            deactivated. However, do note that there is a small delay between this method being called and the deactivation of a cell, 
            since all cells in the batch are deactivated together. If you need more precise timing, you should set the World Grouping or 
            LOD to not be deactivated automatically, and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            and perform that logic there, just before you deactivate each cell.
            </para>
            <para>
            In addition, you should not use this method for removing World Cells or World Cell related data from an internal collection 
            such as a Dictionary, but instead use the OnBeforeAnyCellsDeactivated for this purpose.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which are just about to be deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeCellsInBatchDeactivated">
            OnBeforeCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnAfterCellsInBatchDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called right after a batch of cells has been deactivated during the current World Update (deactivation 
            involves transitioning the cells to a non visible state, removing them from any HierarchyOrganizers, and removing them 
            from the internal collection of World Cells so that they are no longer "part" of the Streamable World Grouping they were a part of), 
            for all cells that the World determined need to be deactivated completely, and also for cells which are being 
            deactivated as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Removed methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an DEACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors assigned, however the state of the neighbors cannot be predicted, since this 
            method may be called before or after other cells that are to be removed have been deactivated. For example, one of its neighbors 
            may be a cell that will be LOD transitioned, so while currently its neighbor is a cell with LOD 1, once all LOD transitions are 
            processed, its new neighbor might be the same cell but of LOD 2. Or in another example, a neighbor may be not present currently, 
            but after adding new cells, may become present. As such, it is not recommended to carry out any neighbor based logic here. Use the 
            OnBeforeAnyCellsDeactivated method instead!
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right before a Cell is deactivated. 
            However, do note that there will likely be a small delay between this method being called and the actual deactivation of the batch of Cell's Asset Chunks. 
            If you need very precise timing, you should disable <b>Auto Deactivate Chunks When Removing Cells</b> and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            where you perform the necessary logic just before you make the Cell's Asset Chunks Invisible and deactivate them.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have just been deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterCellsInBatchDeactivated">
            OnAfterCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnAfterAllCellsDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called after every cell on a World Grouping that the World has determined needs to be deactivated, has been deactivated for 
            a given World Update (deactivation involves transitioning the cells to a non visible state, removing them from any 
            HierarchyOrganizers, and removing them from the internal collection of World Cells so that they are no longer "part" of 
            the Streamable World Grouping they were a part of), for all cells that the World determined needed to be deactivated completely, 
            and also for cells which were deactivated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Deactivated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL NOT have its own Asset Chunks present.
            3) Each World Cell in the batch WILL NOT have cell neighbors assigned.
            </para>
            <para>
            Based on the gaurantees listed, hopefully you can see that this method is the most limited of the OnCells...Deactivated methods. No 
            Asset Chunks or neighbors are present, so this method is only suitable if you need to perform non chunk related operations after all 
            cells that are going to be deactivated have been deactivated in the current World Update.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsDeactivated">
            OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnBeforeAnyCellsActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called before any cells have been activated during the current World Grouping Update, 
            for all cells that the World determines need to be newly activated, and also for cells which are being 
            activated as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL NOT have its own Asset Chunks present.
            3) Each World Cell in the batch WILL NOT have cell neighbors assigned.
            </para>
            <para>
            This method is ideal for situations where you need to perform non chunk, neigbor related, cell specific 
            actions that are not time sensitive, since the 
            actual activation of the cells will take place some frames after this method is called.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which will be activated in a short time.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeAnyCellsActivated">
            OnBeforeAnyCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeAnyCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnBeforeCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called just before a batch of cells will be activated (activation involves transitioning 
            the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determines need to be newly activated, 
            and also for cells which are activated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in a DEACTIVATED state.
            3) Each World Cell in the batch WILL NOT have cell neighbors assigned.
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right before a Cell is activated. Do note, 
            however, that there will likely be a delay between this method being called and the actual activation of the batch of Cell's Asset Chunks. If you need very 
            precise timing, you should disable <b>Auto Activate Chunks When Adding Cells</b> and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            where you perform the necessary logic just before you activate and make the Cell's Asset Chunks Visible.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which are just about to be activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeCellsInBatchActivated">
            OnBeforeCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnBeforeCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnAfterCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called just after a batch of cells have been activated (activation involves transitioning 
            the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determined needed to be newly activated, 
            and also for cells which were activated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors assigned, and any non LOD related data of the neighbors can be considered 
            accurate. However the state of the neighbor Asset Chunks is not predictable, and the neighbor may be replaced by different cells if 
            the neighbor is undergoing an LOD transition (though do note, the neighbor is gauranteed to not be null in the future of the current 
            World Update, since the deactivation of cells which need to be completely removed is performed prior to this method being called 
            for the first time.
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right after a Cell is activated. 
            Do note, however, that there will likely be a delay between the actual activation of the batch of Cell's Asset Chunks and this method being called. I
            f you need very precise timing, you should disable <b>Auto Activate Chunks When Adding Cells</b> and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            where you perform the necessary logic just after you activate and make the Cell's Asset Chunks Visible.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have just been activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterCellsInBatchActivated">
            OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnAfterAllCellsActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called after every cell on a World Grouping that the World has determined needs to be activated, have been activated for 
            a given World Update (activation involves transitioning the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determined needed to be newly activated, 
            and also for cells which were activated as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the Asset Chunks, cell neighbors, and cell 
            neigihbor Asset Chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own Asset Chunks present, and those Asset Chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors set, and the Asset Chunks of the cell neighbors will be in an ACTIVATED state. Please 
            note, there is no gaurantee that a cell will have a neighbor, as if its on the edge of the world or next to an empty Streamable Grid Cell, 
            there may be no World Cell to serve as its neighbor.
            </para>
            <para>
            This method is well suited for neighbor related logic where you want a gaurantee that the cell neighbors will be present (if they exist) 
            and accurate (all neighbors will be true neighbors, and not possibly LOD cells that are in the process of transitioning, or cells which 
            will be deactivated; i.e., neighbors which will be nulled out or replaced in the future of this World Grouping Update).
            </para>
            <para>
            In addition, you SHOULD USE this method for adding World Cells or World Cell related data to an internal collection 
            such as a Dictionary.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. 
            In these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case 
            you do need to, you can query this value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsActivated">
            OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnBeforeGroupingUpdated(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called before a Zone Grouping is updated, regardless of whether cells will actually 
            be changed on the Grouping (because remember, all Groupings are updated during a Word update, regardless of 
            whether there are changes on that grouping!).
            <para>
            Because this method is not dependent on activated or deactivated cells 
            being present, it does not have any input WorldCell's, unlike 
            the other methods. This also means that the method is only called once per World Grouping Listener per World Grouping update.
            </para>
            <para>
            The method is also called when the Component Manager is initialized with two frame 
            initialization (for example, if it's Initialize On Awake option is enabled) 
            before the initial starting cell users are added/activated on a World Grouping. Again, this occurs regardless 
            of whether that World Grouping actually has starting cells. In these instances, immediate mode will be true.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world whose World Grouping is about to be updated.
            </param>
             <param name="zoneIndex" type="int">
            The index of the Zone associated with the cells which have been update. This is useful if using multiple Zones.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping associated with the cells which have been updated. This is useful if using the listener with 
            multiple World Groupings.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeGroupingUpdated">
            OnBeforeGroupingUpdated(World, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnBeforeGroupingUpdated(World world, int zoneIndex, int groupingIndex, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent.OnAfterGroupingUpdated(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called after a Zone Grouping has been updated, regardless of whether cells have actually 
            been changed on the Grouping (because remember, all Groupings are updated during a Word update, regardless of 
            whether there are changes on that grouping!).
            <para>
            Because this method is not dependent on activated or deactivated cells 
            being present, it does not have any input WorldCell's, unlike 
            the other methods. This also means that the method is only called once per World Grouping Listener per World Grouping update.
            </para>
            <para>
            The method is also called when the Component Manager is initialized with two frame 
            initialization (for example, if it's Initialize On Awake option is enabled) 
            after the initial starting cell users are added/activated on a World Grouping. Again, this occurs regardless 
            of whether that World Grouping actually has starting cells. In these instances, immediate mode will be true.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world whose World Grouping has just been updated
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the cells which have been update. This is useful if using multiple Zones.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping associated with the cells which have been updated. This is useful if using the listener with 
            multiple World Groupings.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize. 
            In these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however 
            in case you do need to, you can query this value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterGroupingUpdated">
            OnAfterGroupingUpdated(World, int, int, bool)
            </displayName>
            <syntax>
            public virtual IEnumerator&lt;YieldInstruction&gt; OnAfterGroupingUpdated(World world, int zoneIndex, int groupingIndex, bool immediateMode)
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell.Layer">
            <summary>
            The layer of the regin cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell.Column">
            <summary>
            The column of the regin cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell.Row">
            <summary>
            The row of the regin cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell.LOD">
            <summary>
            The LOD of the region cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell.WorldGroupingIndex">
            <summary>
            Gets the index of the World Grouping for the cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell2.Layer">
            <summary>
            The layer of the regin cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell2.Column">
            <summary>
            The column of the regin cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell2.Row">
            <summary>
            The row of the regin cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegionCell2.LOD">
            <summary>
            The LOD of the region cell.
            </summary>
            <type>int</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldShifter">
            <summary>
            Rather than duplicate the world when a world Origin Cell change occurs, you can shift the world instead. 
            To do so, you can 
            use one of the provided World Shifter classes or create your own custom class by deriving from this class.
            <para>
            The main component of your custom World Shifter class will be the ShiftWorld implementation, which is a Unity coroutine. Here, you 
            can do whatever you want, however to function correctly, you need to ensure that your world is shifted by the appropriate amount 
            (found via the <see cref="P:DeepSpaceLabs.SAM.WorldShifter.CurrentShiftAmount" href="#CurrentShiftAmount">CurrentShiftAmount</see> property).
            </para>
            <para>
            What you shift to accomplish this is entirely up to you. You can shift a root world object that contains all of your world's objects, 
            the objects themselves (recommended), or something else. A custom class gives you full control over your implementation details.
            </para>
            <para>
            The class contains four events by default: PreWorldShift, PostWorldShift, PreTransformShift and PostTransformShift. These events 
            will be available in the Unity editor for custom scripts in  your scene to subscribe to, or you can subscribe to them via code by 
            using one of the Subscribe methods (usually in OnEnable) and its corresponding Unsubscribe method (usually in OnDisbale).
            </para>
            <para>
            The PreWorldShift and PostWorldShift are fired under two scenarios. When the FireWorldShiftingEventAutomatically 
            and FireWorldShiftedEventAutomatically properties on your custom World Shifter are configured to return true, 
            or when you manually call the FirePreWorldShiftEvent or 
            FirePreWorldShiftEvent methods (do so at the appropriate time of course!). The latter can be done for more fine tuned control 
            over when the events fire. If you choose the first option, the pre event is fired immediately before the WorldShift coroutine starts 
            executing, and the post event fires immediately after it finishes executing.
            </para>
            <para>
            The PreTransformShift and PostTransformShift events will only fire if you utilize the TransformShift method from within your 
            ShiftWorld implementation, which is highly recommended. In addition to firing the events at the appropriate time, the method will 
            also add the CurrentShiftAmount to the transform's position, ensuring that everything is done correctly.
            </para>
            <para>
            However, because this class should offer maximum flexibility, it is not required that you use this method, however keep in mind that if 
            you don't use the method, the PreTransformShift and PostTransformShift events will not fire automatically. You can still fire them 
            manually using the FirePreTransformShiftEvent and FirePostTransformShiftEvent methods (at the appropriate time of course).
            </para>
            <para>
            It is possible to use the same WorldShifter object with multiple Worlds, however special care must be taken in regards to subscribers of 
            the events, to ensure that they can handle the events being fired for different Worlds.
            </para>
            </summary>
            <title>WorldShifter Abstract Class</title>
            <category>World Shifters</category>
            <navigationName>WorldShifter</navigationName>
            <fileName>WorldShifter.html</fileName>
            <syntax>public abstract class WorldShifter : MonoBehaviour</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldShifter.WorldShifting">
            <summary>
            An event that can be subscribed to in order to receive notifications just before a World shift starts.
            <para>
            The event utilizes 
            <see cref="T:DeepSpaceLabs.SAM.WorldShiftEventArgs" href="WorldShiftEventArgs.html">WorldShiftEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, WorldShiftEventArgs paramaterName).
            </para>
            <para>
            You can subscribe to this event via the Unity editor or via scripting using the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToWorldShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})" href="WorldShifter.html#SubscribeToWorldShiftingEvent">SubscribeToWorldShiftingEvent</see> method.
            </para>
            <para>
            To unsubscribe via scripting, use the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromWorldShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})" href="WorldShifter.html#UnsubscribeFromWorldShiftingEvent">UnsubscribeFromWorldShiftingEvent</see> method.
            </para>
            </summary>
            <type link="WorldShiftEvent.html">WorldShiftEvent</type>
            <displayName>WorldShifting</displayName>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldShifter.WorldShifted">
            <summary>
            An event that can be subscribed to in order to receive notifications just after a World shift is completed.
            <para>
            The event utilizes 
            <see cref="T:DeepSpaceLabs.SAM.WorldShiftEventArgs" href="WorldShiftEventArgs.html">WorldShiftEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, WorldShiftEventArgs paramaterName).
            </para>
            <para>
            You can subscribe to this event via the Unity editor or via scripting using the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToWorldShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})" href="WorldShifter.html#SubscribeToWorldShiftedEvent">SubscribeToWorldShiftedEvent</see> method.
            </para>
            <para>
            To unsubscribe via scripting, use the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromWorldShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})" href="WorldShifter.html#UnsubscribeFromWorldShiftedEvent">UnsubscribeFromWorldShiftedEvent</see> method.
            </para>
            </summary>
            <type link="WorldShiftEvent.html">WorldShiftEvent</type>
            <displayName>WorldShifted</displayName>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldShifter.TransformShifting">
            <summary>
            An event that can be subscribed to in order to receive notifications just before each Transform is shifted during the World shift.
            <para>
            The event utilizes 
            <see cref="T:DeepSpaceLabs.SAM.TransformShiftEventArgs" href="TransformShiftEventArgs.html">TransformShiftEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, TransformShiftEventArgs paramaterName).
            </para>
            <para>
            You can subscribe to this event via the Unity editor or via scripting using the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToTransformShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})" href="WorldShifter.html#SubscribeToTransformShiftingEvent">SubscribeToTransformShiftingEvent</see> method.
            </para>
            <para>
            To unsubscribe via scripting, use the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromTransformShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})" href="WorldShifter.html#UnsubscribeFromTransformShiftingEvent">UnsubscribeFromTransformShiftingEvent</see> method.
            </para>
            </summary>
            <type link="TransformShiftEvent.html">TransformShiftEvent</type>
            <displayName>TransformShifting</displayName>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldShifter.TransformShifted">
            <summary>
            An event that can be subscribed to in order to receive notifications just after each Transform is shifted during the World shift.
            <para>
            The event utilizes 
            <see cref="T:DeepSpaceLabs.SAM.TransformShiftEventArgs" href="TransformShiftEventArgs.html">TransformShiftEventArgs</see> 
            and subscribers must have a signature of void MethodName(object sender, TransformShiftEventArgs paramaterName).
            </para>
            <para>
            You can subscribe to this event via the Unity editor or via scripting using the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToTransformShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})" href="WorldShifter.html#SubscribeToTransformShiftedEvent">SubscribeToTransformShiftedEvent</see> method.
            </para>
            <para>
            To unsubscribe via scripting, use the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromTransformShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})" href="WorldShifter.html#UnsubscribeFromTransformShiftedEvent">UnsubscribeFromTransformShiftedEvent</see> method.
            </para>
            </summary>
            <type link="TransformShiftEvent.html">TransformShiftEvent</type>
            <displayName>TransformShifted</displayName>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShifter.PerformShiftInSingleFrame">
            <summary>
            Gets the value of the performShiftInSingleFrame field in the inspector. 
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShifter.CurrentWorldToBeShifted">
            <summary>
            The current world that is to be shifted. Will be null when a shift is not in progress.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShifter.CurrentShiftAmount">
            <summary>
            The amount to add to the current position of objects in the world. Will be zero when a shift is not in progress
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShifter.TotalTransformsToBeShifted">
            <summary>
            The number of transforms that will be shifted during the current world shift. Will be 0 when a shift is 
            not in progress.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftingEventAutomatically">
            <summary>
            When overriden, tells the base World Shifter class whether the WorldShifting event 
            should be fired automatically just prior to the ShiftWorld coroutine being run. This will call 
            the FireWorldShiftingEvent method if true.
            <para>
            You may return false, however you will need to fire the event manually by calling the 
            FireWorldShiftingEvent method.
            </para>
            <para>
            If you don't elect for either of these two options, the WorldShifting event will not fire. You can create 
            a custom event yourself in this case, and fire it at the time of your choosing, however there really is 
            no need for this, unless you want to utilize different arguments for the event.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftedEventAutomatically">
            <summary>
            When overriden, tells the base World Shifter class whether the WorldShifted event should be 
            fired automatically just after the ShiftWorld coroutine finishes running. This will call the 
            FireWorldShiftedEvent method if true.
            <para>
            You may return false, however you will need to fire the event manually by calling the FireWorldShiftedEvent method.
            </para>
            <para>
            If you don't elect for either of these two options, the WorldShifted event will not fire. 
            You can create a custom event yourself in this case, and fire it at the time of your choosing, 
            however there really is no need for this, unless you want to utilize different arguments for the event.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToWorldShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})">
            <summary>
            Subcribe to the WorldShifting event via code. Typically you would do this in the OnEnable method, and then call 
            the <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromWorldShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})" href="#UnsubscribeFromWorldShiftingEvent">UnsubscribeFromWorldShiftingEvent</see> 
            method in your OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, WorldShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and WorldShiftEventArgs parameters.
            </param>
            <displayName id="SubscribeToWorldShiftingEvent">
            SubscribeToWorldShiftingEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void SubscribeToWorldShiftingEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToWorldShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})">
            <summary>
            Subcribe to the WorldShifted event via code. Typically you would do this in the OnEnable method, and then call 
            the <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromWorldShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})" href="#UnsubscribeFromWorldShiftedEvent">UnsubscribeFromWorldShiftedEvent</see> 
            method in your OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, WorldShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and WorldShiftEventArgs parameters.
            </param>
            <displayName id="SubscribeToWorldShiftedEvent">
            SubscribeToWorldShiftedEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void SubscribeToWorldShiftedEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToTransformShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})">
            <summary>
            Subcribe to the TransformShifting event via code. Typically you would do this in the OnEnable method, and then call 
            the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromTransformShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})" href="#UnsubscribeFromTransformShiftingEvent">UnsubscribeFromTransformShiftingEvent</see> 
            method in your OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, TransformShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and TransformShiftEventArgs parameters.
            </param>
            <displayName id="SubscribeToTransformShiftingEvent">
            SubscribeToTransformShiftingEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void SubscribeToTransformShiftingEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.SubscribeToTransformShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})">
            <summary>
            Subcribe to the TransformShifted event via code. Typically you would do this in the OnEnable method, and then call 
            the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromTransformShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})" href="#UnsubscribeFromTransformShiftedEvent">UnsubscribeFromTransformShiftedEvent</see> 
            method in your OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, TransformShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and TransformShiftEventArgs parameters.
            </param>
            <displayName id="SubscribeToTransformShiftedEvent">
            SubscribeToTransformShiftedEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void SubscribeToTransformShiftedEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromWorldShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})">
            <summary>
            Unsubcribe from the WorldShifting event via code. Typically you would subscribe in the OnEnable method of your script, and then 
            unsubscribe in the OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, WorldShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and WorldShiftEventArgs parameters, and be the same method you 
            subscribed with.
            </param>
            <displayName id="UnsubscribeFromWorldShiftingEvent">
            UnsubscribeFromWorldShiftingEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void UnsubscribeFromWorldShiftingEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromWorldShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.WorldShiftEventArgs})">
            <summary>
            Unsubcribe from the WorldShifted event via code. Typically you would subscribe in the OnEnable method of your script, and then 
            unsubscribe in the OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, WorldShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and WorldShiftEventArgs parameters, and be the same method you 
            subscribed with.
            </param>
            <displayName id="UnsubscribeFromWorldShiftedEvent">
            UnsubscribeFromWorldShiftedEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void UnsubscribeFromWorldShiftedEvent(UnityAction&lt;System.Object, WorldShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromTransformShiftingEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})">
            <summary>
            Unsubcribe from the TransformShifting event via code. Typically you would subscribe in the OnEnable method of your script, and then 
            unsubscribe in the OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, TransformShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and TransformShiftEventArgs parameters, and be the same method you 
            subscribed with.
            </param>
            <displayName id="UnsubscribeFromTransformShiftingEvent">
            UnsubscribeFromTransformShiftingEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void UnsubscribeFromTransformShiftingEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.UnsubscribeFromTransformShiftedEvent(UnityEngine.Events.UnityAction{System.Object,DeepSpaceLabs.SAM.TransformShiftEventArgs})">
            <summary>
            Unsubcribe from the TransformShifted event via code. Typically you would subscribe in the OnEnable method of your script, and then 
            unsubscribe in the OnDisable method.
            </summary>
            <param name="subscriber" type="UnityAction&lt;System.Object, TransformShiftEventArgs&gt;">
            The subscriber, which must be a void method with System.Object and TransformShiftEventArgs parameters, and be the same method you 
            subscribed with.
            </param>
            <displayName id="UnsubscribeFromTransformShiftedEvent">
            UnsubscribeFromTransformShiftedEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt;)
            </displayName>
            <syntax>
            public void UnsubscribeFromTransformShiftedEvent(UnityAction&lt;System.Object, TransformShiftEventArgs&gt; subscriber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.Awake">
            <summary>
            The World Shifter's Awake method, called by Unity. You cannot utilize Awake in your derived class, 
            if you need to perform some sort of awake related logic, override the AwakeExtended method, which will be called by this 
            classes Awake method. Also note that you do not need to call base.AwakeExtended(); from your AwakeExtended method, as 
            this is a virtual empty method that does nothing unless you override it. Also note that this method is protected simply so 
            that if you derive from this class, you will see an error when trying to add the Awake method.
            </summary>
            <displayName id="Awake">
            Awake()
            </displayName>
            <syntax>
            protected void Awake()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.AwakeExtended">
            <summary>
            Can be overriden to perform logic that would normally go in Awake (which is used by the base class). 
            Use this instead of implementing Awake! You do not need to 
            call base.AwakeExtended if you override this, as the base method is empty.
            </summary>
            <displayName id="AwakeExtended">AwakeExtended()</displayName>
            <syntax>protected virtual void AwakeExtended()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.OnDestroy">
            <summary>
            The World Shifter's OnDestroy method, called by Unity. You cannot utilize OnDestroy in your derived class, 
            if you need to perform some sort of OnDestroy related logic, 
            override the OnDestroyExtended method, which will be called by this 
            classes OnDestroy method. Also note that you do not need to call base.OnDestroyExtended(); 
            from your OnDestroyExtended method, as 
            this is a virtual empty method that does nothing unless you override it. Also note that this method is protected simply so 
            that if you derive from this class, you will see an error when trying to add the OnDestroy method.
            </summary>
            <displayName id="OnDestroy">
            OnDestroy()
            </displayName>
            <syntax>
            protected void OnDestroy()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.OnDestroyExtended">
            <summary>
            Can be overriden to perform logic that would normally go in OnDestroy (which is used by the base class). 
            Use this instead of implementing OnDestroy! You do not need to 
            call base.OnDestroyExtended if you override this, as the base method is empty.
            </summary>
            <displayName id="OnDestroyExtended">
            OnDestroyExtended()
            </displayName>
            <syntax>
            protected virtual void OnDestroyExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.IsConfiguredToMovePlayerFromActiveGrid(DeepSpaceLabs.SAM.ActiveGrid)">
            <summary>
            When overriden, executes a query to determine if the World Shifter has been configured to move the Player associated 
            with the Active Grid. This is used by the Active Grid in certain situations to avoid double movements.
            </summary>
            <param name="activeGrid" type="ActiveGrid" link="ActiveGrid.html">
            The active grid with the Player.
            </param>
            <returns type="bool">
            True if the World Shifter has been configured to move the player, false otherwise.
            </returns>
            <displayName id="IsConfiguredToMovePlayerFromActiveGrid">
            IsConfiguredToMovePlayerFromActiveGrid(ActiveGrid)
            </displayName>
            <syntax>
            public abstract bool IsConfiguredToMovePlayerFromActiveGrid(ActiveGrid activeGrid)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.ShiftWorld">
            <summary>
            When overridden by a derived class, shifts the world. 
            You'll notice that this method is not passed any arguments. The World and shift amount are set prior to this method 
            being called, and can be retrieved via the CurrentWorldToBeShifted and CurrentShiftAmount properties. 
            <para>
            What transforms you shift in order to complete a 'World Shift' is entirely up to you.
            </para>
            </summary>
            <displayName id="ShiftWorld">
            ShiftWorld()
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; ShiftWorld()
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftingEvent">
            <summary>
            Fires the WorldShifting Event. You only need to call this if you've configured FireWorldShiftingEventAutomatically to return false 
            in your custom World Shifter class.
            </summary>
            <displayName id="FireWorldShiftingEvent">
            FireWorldShiftingEvent()
            </displayName>
            <syntax>
            protected void FireWorldShiftingEvent()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftedEvent">
            <summary>
            Fires the WorldShifted Event. You only need to call this if you've configured FireWorldShiftedEventAutomatically to return false 
            in your custom World Shifter class.
            </summary>
            <displayName id="FireWorldShiftedEvent">
            FireWorldShiftedEvent()
            </displayName>
            <syntax>
            protected void FireWorldShiftedEvent()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.ShiftTransformAndFireEvents(UnityEngine.Transform)">
            <summary>
            First, it fires the TransformShifting event if there are any subscribers. Then, it shifts the position of the input transform by the 
            value of CurrentShiftAmount. Finally, it fires the TransformShifted event if there are any subscribers.
            <para>
            This method should be called for each Transform that you wish to shift. You can elect to not use the method and shift the transforms 
            yourself, however the TransformShifting and TransformShifted methods will not be fired automatically. 
            In that case, you can manually call FireTransformShiftingEvent before you shift the transform and then FireTransformShiftedEvent 
            after you shift the transform, or elect not to use the Transform Shift events at all. The method automatically increments the 
            TransformShiftEventArgs.TransformNumberInShiftCycle so you don't need to worry about it.
            </para>
            <para>
            If you utilize this method, you should not utilize the FireTransformShiftingEvent and FireTransformShiftedEvent methods, as they 
            are mutually exclusive.
            </para>
            </summary>
            <param name="transform" type="Transform">
            The transform to shift.
            </param>
            <displayName id="ShiftTransformAndFireEvents">
            ShiftTransformAndFireEvents(Transform)
            </displayName>
            <syntax>
            protected void ShiftTransformAndFireEvents(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.FireTransformShiftingEvent(UnityEngine.Transform,System.Int32)">
            <summary>
            Manually fire the TransformShifting event. You need to track and set the transformNumberInShiftCycle value, as automatic tracking 
            is only available when using the ShiftTransformAndFireEvents method. If you use this method, you cannot use the ShiftTransformAndFireEvents method, as the 
            two are mutually exclusive. You must also make sure to call the FirePostShiftTransformEvent method.
            <para>
            Ideally you would call this method immediately before manually shifting the transform's position.
            </para>
            </summary>
            <param name="transform" type="Transform">
            The transformt that is about to be shifted.
            </param>
            <param name="transformNumberInShiftCycle" type="int">
            The transformt that is about to be shifted.
            </param>
            <displayName id="FireTransformShiftingEvent">
            FireTransformShiftingEvent(Transform, int)
            </displayName>
            <syntax>
            public void FireTransformShiftingEvent(Transform transform, int transformNumberInShiftCycle)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.FireTransformShiftedEvent(UnityEngine.Transform,System.Int32)">
            <summary>
            Manually fire the TransformShifted event. You need to track and set the transformNumberInShiftCycle value, as automatic tracking 
            is only available when using the ShiftTransformAndFireEvents method. If you use this method, you cannot use the ShiftTransformAndFireEvents method, as the 
            two are mutually exclusive. You must also make sure to call the FirePreShiftTransformEvent method.
            <para>
            Ideally you would call this method immediately after manually shifting the transform's position.
            </para>
            </summary>
            <param name="transform" type="Transform">
            The transformt that has just been shifted.
            </param>
            <param name="transformNumberInShiftCycle" type="int">
            The transformt that is about to be shifted.
            </param>
            <displayName id="FireTransformShiftedEvent">
            FireTransformShiftedEvent(Transform, int)
            </displayName>
            <syntax>
            public void FireTransformShiftedEvent(Transform transform, int transformNumberInShiftCycle)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldShifter.CalculateNumberOfTransformsToBeShifted">
            <summary>
            A method which should be overriden to return the total number of transforms that will be shifted by your 
            implementation of the ShiftWorld coroutine. This is basically the number of times you will call 
            the <see cref="M:DeepSpaceLabs.SAM.WorldShifter.ShiftTransformAndFireEvents(UnityEngine.Transform)" href="#ShiftTransformAndFireEvents">ShiftTransformAndFireEvents</see> method, or the total transforms you will 
            shift manually if you elect not to use that method. This is for use with 
            the PreTransformShift and PostTransformShift events, so that the TotalTransformsInShiftCycle property 
            in the event args can be set properly. If you don't intend to use these events, you don't need to 
            worry about this method (just return 0).
            <para>
            Please note that this is not necessarily a count of the total number of transforms in your World, and some transforms may be 
            children of other transforms, which are shifted automatically when their parents are shifted. Rather, this is a count of the total 
            number of transforms that are shifted either manually by you (transform.position = transform.position + CurrentShiftAmount), or the 
            total number of transforms shifted via the ShiftTransformAndFireEvents method.
            </para>
            <para>
            Also note that the CurrentWorldToBeShifted and CurrentShiftAmount properties will be set prior to this method being called, 
            so you can access them if you need to in order to determine the value returned.
            </para>
            </summary>
            <returns type="int">
            The number of transforms that will be shifted.
            </returns>
            <displayName id="CalculateNumberOfTransformsToBeShifted">
            CalculateNumberOfTransformsToBeShifted()
            </displayName>
            <syntax>
            protected abstract int CalculateNumberOfTransformsToBeShifted()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TransformShiftEvent">
            <summary>
            Represents a Transform Shift event. The intent of this class is solely to add the ability to subscribe to an event in the Unity 
            inspector when the World is shifted. This event is not found on the World class, but is instead found in custom 
            <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">World Shifter</see> classes.
            <para>
            The idea is to allow other scripts to receive notification exactly at the time of 
            shifting. Each transform that is shifted as a result of a world shift fires an event both before and after it is shifted (assuming 
            the custom WorldShifter class is setup correctly).
            </para>
            <para>
            To subscribe to this event, in a separate MonoBehaviour class, create a public method with System.Object and 
            TransformShiftEventArgs parameters. The name of the method or parameters does not matter. After saving the class, 
            add it to a Game Object in your scene, and then in your World Shifter's inspector, add a new listener by pressing the 
            + button on the event you care about (or both). Drag the MonoBehaviour that will be the listerner to the field that appears, 
            and then select the method you created in the drop down list.
            </para>
            <para>
            Alternatively, the WorldShifter has Subscribe and Unsubscribe events for hooking up listeners during runtime via code (make sure to 
            Unsubscribe!). Usually this is done in the OnEnable and OnDisable methods of your MonoBehaviour.
            </para>
            <para>
            The <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">WorldShifter</see> 
            documentation also contains information on how to subscribe to these events, along with more detailed information.
            </para>
            <para>
            Do not store a reference to the args when your listener is called, as the properties of the args are 
            reset or set to null immediately after the event that uses it is done firing.
            </para>
            </summary>
            <title>
            TransformShiftEvent Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>TransformShiftEvent</navigationName>
            <fileName>TransformShiftEvent.html</fileName>
            <syntax>
            public class TransformShiftEvent : UnityEvent&lt;World, Transform, Vector3Double, int&gt;
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldShiftEvent">
            <summary>
            Represents a World Shift event. The intent of this class is solely to add the ability to subscribe to an event in the Unity 
            inspector when the World is shifted. This event is not found on the World class, but is instead found in custom 
            <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">World Shifter</see> classes.
            <para>
            The idea is to allow other scripts to receive notification exactly at the time of 
            shifting. When a World Shifter class is setup correctly, a PreWorldShift and PostWorldShift event is fired before and after 
            the world is shifted as a whole. If you need more fine grained control over logic that is dependent on individual transforms 
            of the World being shifted, take a look at the 
            <see cref="T:DeepSpaceLabs.SAM.TransformShiftEvent" href="TransformShiftEvent.html">TransformShiftEvent</see> instead.
            </para>
            <para>
            To subscribe to this event, in a separate MonoBehaviour class, create a public method with System.Object and 
            WorldShiftEventArgs parameters. 
            The name of the method or parameters does not matter. After saving the class, add it to a Game Object in your scene, 
            and then in your World Shifter's inspector, add a new listener by pressing the + button on the event you care about (or both). 
            Drag the MonoBehaviour that will be the listerner to the field that appears, and then select the method you created in the drop down list.
            </para>
            <para>
            Alternatively, the WorldShifter has Subscribe and Unsubscribe events for hooking up listeners during runtime via code (make sure to 
            Unsubscribe!). Usually this is done in the OnEnable and OnDisable methods of your MonoBehaviour.
            </para>
            <para>
            The <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">WorldShifter</see> 
            documentation also contains information on how to subscribe to these events, along with more detailed information.
            </para>
            <para>
            Do not store a reference to the args when your listener is called, as the properties of the args are 
            reset or set to null immediately after the event that uses it is done firing.
            </para>
            </summary>
            <title>
            WorldShiftEvent Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>WorldShiftEvent</navigationName>
            <fileName>WorldShiftEvent.html</fileName>
            <syntax>
            public class WorldShiftEvent : UnityEvent&lt;System.Object, <see href="WorldShiftEventArgs.html">WorldShiftEventArgs</see>&gt;
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.MoveTransformOnWorldShift">
            <summary>
            A MonoBehaviour that can be added to a game object in order to move a transform not 
            included in the World's hierarchy when the 
            World is shifted. The move will be carried out either before or after the World has been 
            shifted, depending on how 'Move Before World Shift' is setup.
            <para>
            If you need to move multiple Transforms, consider using the 
            <see cref="T:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift" href="MoveTransformsOnWorldShift.html">MoveTransformsOnWorldShift</see> 
            class instead.
            </para>
            </summary>
            <title>
            MoveTransformOnWorldShift Class
            </title>
            <category>Secondary Components</category>
            <navigationName>MoveTransformOnWorldShift</navigationName>
            <fileName>MoveTransformOnWorldShift.html</fileName>
            <syntax>
            public class MoveTransformOnWorldShift : MonoBehaviour
            </syntax>
            <inspector name="Move Before World Shift" type="bool">
            If true, the transform will be moved before the world shift occurs. If false, the transform will be moved after the world shift 
            occurs (i.e. all transforms associated with the World have been moved).
            <para>
            If you need more fine grained control, 
            for instance moving a transform when a specific game object is moved, you will need to create a custom script.
            </para>
            </inspector>
            <inspector name="Transform To Move" type="Transform">
            The transform to move. If null, the transform of the game object this script is attached to will be used.
            </inspector>
            <inspector name="World IDs To Filter" type="int[]">
            A set of World IDs which you can use to filter by. If set, the transform will only be moved when the World passed into 
            the method has an ID that matches one of the IDs set here. If no IDs are set (length = 0), all Worlds will trigger a move. 
            Note however, this will only matter when multiple Worlds utilize the same World Shifter object that this script is subscribed to. 
            If you only have one World using the World Shifter object, there is no need to specify a World ID.
            </inspector>
        </member>
        <member name="T:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift">
            <summary>
            A MonoBehaviour that can be added to a game object in order to move multiple transforms not 
            included in the World's hierarchy when the 
            World is shifted. The move will be carried out either before or after the World has been 
            shifted, depending on how 'Move Before World Shift' is setup.
            <para>
            Note that you can add/remove/set the transforms at runtime as well via scripting.
            </para>
            </summary>
            <title>
            MoveTransformsOnWorldShift Class
            </title>
            <category>Secondary Components</category>
            <navigationName>MoveTransformsOnWorldShift</navigationName>
            <fileName>MoveTransformsOnWorldShift.html</fileName>
            <syntax>
            public class MoveTransformsOnWorldShift : MonoBehaviour
            </syntax>
            <inspector name="Move Before World Shift" type="bool">
            If true, the transforms will be moved before the world shift occurs. If false, the transforms will be moved after the world shift 
            occurs (i.e. all transforms associated with the World have been moved).
            <para>
            If you need more fine grained control, 
            for instance moving a transform when a specific game object is moved, you will need to create a custom script.
            </para>
            </inspector>
            <inspector name="Transforms To Move" type="Transform">
            The transforms to move. Must be assigned explicitly.
            </inspector>
            <inspector name="World IDs To Filter" type="int[]">
            A set of World IDs which you can use to filter by. If set, the transforms will only be moved when the World passed into 
            the method has an ID that matches one of the IDs set here. If no IDs are set (length = 0), all Worlds will trigger a move. 
            Note however, this will only matter when multiple Worlds utilize the same World Shifter object that this script is subscribed to. 
            If you only have one World using the World Shifter object, there is no need to specify a World ID.
            </inspector>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift.SetTransforms(UnityEngine.Transform[])">
            <summary>
            Replaces all Transforms to be moved with the ones in the input array. This clears the existing transforms; if that 
            is not the behavior that you want, use AddTransforms instead.
            <para>
            Also note that the Transforms in the input array are copied to an internal list. The array is not stored and used.
            </para>
            </summary>
            <param name="newTransformsToMove" type="Transform[]">
            The new set of Transforms to use.
            </param>
            <displayName id="SetTransforms1">
            SetTransforms(Transform[])
            </displayName>
            <syntax>
            public void SetTransforms(Transform[] newTransformsToMove)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift.SetTransforms(System.Collections.Generic.List{UnityEngine.Transform})">
            <summary>
            Replaces all Transforms to be moved with the ones in the input list. This clears the existing transforms; if that 
            is not the behavior that you want, use AddTransforms instead.
            <para>
            Also note that the Transforms in the input list are copied to an internal list. The input list is not stored and used.
            </para>
            </summary>
            <param name="newTransformsToMove" type="List&lt;Transform&gt;">
            The new set of Transforms to use.
            </param>
            <displayName id="SetTransforms2">
            SetTransforms(List&lt;Transform&gt;)
            </displayName>
            <syntax>
            public void SetTransforms(List&lt;Transform&gt; newTransformsToMove)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift.ClearTransforms">
            <summary>
            Clears all Transforms currently set.
            </summary>
            <displayName id="ClearTransforms">
            ClearTransforms()
            </displayName>
            <syntax>
            public void ClearTransforms()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift.RemoveTransform(UnityEngine.Transform)">
            <summary>
            Removes a single Transform from the internal list of transforms to move.
            </summary>
            <param name="transform" type="Transform">
            The transform to remove.
            </param>
            <displayName id="RemoveTransform">
            RemoveTransform(Transform)
            </displayName>
            <syntax>
            public void RemoveTransform(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift.RemoveTransforms(System.Collections.Generic.List{UnityEngine.Transform})">
            <summary>
            Removes multiple Transforms from the internal list of transforms to move.
            </summary>
            <param name="transforms" type="List&lt;Transform&gt;">
            The transforms to remove.
            </param>
            <displayName id="RemoveTransforms">
            RemoveTransforms(List&lt;Transform&gt;)
            </displayName>
            <syntax>
            public void RemoveTransforms(List&lt;Transform&gt; transforms)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift.AddTransform(UnityEngine.Transform)">
            <summary>
            Adds a single Transform to the internal list of transforms to move.
            </summary>
            <param name="transform" type="Transform">
            The transform to add.
            </param>
            <displayName id="AddTransform">
            AddTransform(Transform)
            </displayName>
            <syntax>
            public void AddTransform(Transform transform)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.MoveTransformsOnWorldShift.AddTransforms(System.Collections.Generic.List{UnityEngine.Transform})">
            <summary>
            Adds multiple Transforms to the internal list of transforms to move.
            </summary>
            <param name="transforms" type="List&lt;Transform&gt;">
            The transforms to add.
            </param>
            <displayName id="AddTransforms">
            AddTransforms(List&lt;Transform&gt;)
            </displayName>
            <syntax>
            public void AddTransforms(List&lt;Transform&gt; transforms)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.GridLODDetails">
            <summary>
            Stores information on a Streamable Grid LOD Group. You can modify this information via the Streamable Grid's inspector.
            </summary>
            <title>GridLODDetails Class</title>
            <category>Primary Non Components</category>
            <navigationName>GridLODDetails</navigationName>
            <fileName>GridLODDetails.html</fileName>
            <syntax>public sealed class GridLODDetails: <see cref="T:DeepSpaceLabs.SAM.IIdentifiable" href="IIdentifiable.html">IIdentifiable</see></syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.ChunksUsePositionalData">
            <summary>
            Gets a value indicating if the LOD Chunks uses positional data. If the Chunk Type is None, this 
            always returns false. If it is Unity_Terrain, it always returns true. Otherwise, it returns the value of 
            'Uses Positional Data' set in the insepctor of the LOD Group on the Streamable Grid.
            <para>
            In order to avoid some calculation each time this is called, this value is set during Streamable Grid initialization, and 
            thus should not be used before it has been initialized.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.ChunkType_PreInitSafe">
            <summary>
            Gets the Chunk Type used by this LOD Group (type of Asset Chunks that are loaded via Chunk Streamers).
            </summary>
            <type link="ChunkType.html">ChunkType</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.DoAllCellsUseSameNumberOfChunks">
            <summary>
            Gets a value indicating whether all Streamable Grid cells associated with this LOD Group use the same number of chunks. You can only 
            access this property after the Streamable Grid has been initialized.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.GroupName_PreInitSafe">
            <summary>
            Gets the Group Name asigned to this LOD Group in the Streamable Grid inspector. Note, if the Group Name 
            of the LOD Group has been manually changed either pre or post World initialization, it will 
            not be reflected here.
            <para>
            As such, if you are trying to retrieve the actual Group Name in use by the LOD Group, it is safer to use the 
            World's <see cref="M:DeepSpaceLabs.SAM.World.GetLODGroupName(System.Int32,System.Int32,System.Int32)" href="World.html#GetLODGroupName">GetLODGroupName</see> method instead.
            </para>
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.LevelOfDetail">
            <summary>
            Gets which level of detail these details belongs to on the Streamable Grid. You can find this number in the LOD Groups tab of 
            the Streamable Grid, under the "Add LOD Group" button. It is the number shown on the tabs that allow you to select each LOD Group.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.NamingConvention">
            <summary>
            Gets the naming convention used by this LOD Group.
            </summary>
            <type link="INamingConvention.html">INamingConvention</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridLODDetails.NamingConvention_PreInitSafe(System.Boolean)">
            <summary>
            Gets the Naming Convention used by the LOD before the Grid has been initialized. If you know the Streamable Grid has been initialized, 
            using the NamingConvention property will be faster and is recommended, however if you are not sure, or know that the Grid has 
            not been initialized, you must use this method to avoid errors.
            </summary>
            <param name="isGrid3D" type="bool">
            Whether the Streamable Grid used the Three Dimensional Axes Type.
            </param>
            <displayName id="NamingConvention_PreInitSafe">
            NamingConvention_PreInitSafe(bool)
            </displayName>
            <syntax>
            public INamingConvention NamingConvention_PreInitSafe(bool isGrid3D)
            </syntax>
            <returns type="INamingConvention" link="INamingConvention.html">
            The naming convention. Will return a default convention if the Naming Convention set on the LOD is null.
            </returns>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.StreamableGridCellWithChunkSetToUse_PreInitSafe">
            <summary>
            When UseSingleChunkSetForAllCells_PreInitSafe return true, this returns the cell on the Streamable Grid whose chunks will be 
            used for all World Cells on this LOD. All included Chunk Streamers can make use 
            of this functionality, however note that if you create a custom Chunk Streamer, you will need to add the necessary code 
            to make this work, or else disable this option in the inspector of your Streamable Grid.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.UseSingleChunkSetForAllCells_PreInitSafe">
            <summary>
            Gets a value indicating whether this LOD is using a single chunk set (from the 
            Streamable Grid Cell indicated by StreamableGridCellWithObjectSetToUse) for all World Cells. All included Chunk Streamers can make use 
            of this functionality, however note that if you create a custom Chunk Streamer, you will need to add the necessary code 
            to make this work, or lease disable this option in the inspector of your Streamable Grid.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.UsesTerrain">
            <summary>
            Gets a value indicating whether the LOD Group uses Unity Terrain.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.UtilizesMultiChunking_PreInitSafe">
            <summary>
            Gets a value indicating whether this LOD Group utilizes multiple chunks for its cells. If this is true, the naming 
            convention you set for this Streamable Grid LOD Group must include the special %c characters in the Supplemental Chunk Format field. This format 
            is used for Chunks 2+ in each cell's chunk set.
            <para>
            If you are trying to retrieve the number of chunks a particular cell has, 
            you do not need to check this property first before 
            calling the appropriate method. 
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.VisualStateOfStoredAssetsWhenActive_PreInitSafe">
            <summary>
            Gets the stored visual state of the assets associated with this LOD, which is only applicable when using a Cell Visual Transition Controller. 
            To determine this, imagine the assets were added to the scene and put into an active state (using SetActive(true) for game objects for instance), 
            and then positioned according to the PositionOfChunks property of whatever World Cell they are associated with. If the objects would be visible after 
            this, the stored state is Visible. Otherwise, it is 
            Invisible.
            <para>
            Another way to think about it is to consider the Cell Visual Transition Controller you are using. It transitions objects from a visible state 
            to an invisible state, or vice versa. Does the stored state of your assets match the state they would be in if your controller transitioned 
            them to a visible state? If so, then the stored state is Visible. Otherwise it is Invisible.
            </para>
            </summary>
            <type link="VisualState.html">VisualState</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.StreamableGrid">
            <summary>
            Gets the Streamable Grid this LOD Group is a part of.
            </summary>
            <type link="StreamableGrid.html">StreamableGrid</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.RootState">
            <summary>
            Gets the state of the root game objects in Scene Based Asset Chunks for this LOD Group.
            <para>
            At runtime this is just used to ensure the actual state of root objects in Scene Based Asset Chunks 
            match what you have specified. If the LOD Group does not use Scene Based Asset Chunks, this setting is ignored.
            </para>
            </summary>
            <type link="RootState.html">RootState</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.GridLODDetails.ID">
            <summary>
            An ID that identifies this LOD Group. It is assigned automatically at the time the LOD Group is created and will never change, regardless of 
            whether you change the order of the LOD Group on the Streamable Grid.
            <para>Is is also gauranteed to be 
            unique (in relation to other LOD Groups on the same Streamable Grid). You can use this ID to retrieve the LOD Details instead of using the 
            LOD Number, which is more reliable as the LOD Number may change as you re-order LOD Groups and/or add/remove LOD Groups.
            </para>
            <para>
            Note, if you remove an LOD Group and re-add it, the ID of the LOD Group will likely change!
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridLODDetails.GetCellChunksUsingEndlessGridCell(DeepSpaceLabs.SAM.Cell)">
            <summary>
             Gets the number of chunks used by a particular Endless Grid Cell for this LOD Group.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">The cell whose number of chunks you wish to know.</param>
            <returns type="int">The number of chunks used by the cell.</returns>
            <displayName id="GetCellChunksUsingEndlessGridCell">
            GetCellChunksUsingEndlessGridCell(Cell)
            </displayName>
            <syntax>
            public ReturnType GetCellChunksUsingEndlessGridCell(Cell endlessGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridLODDetails.GetCellChunksUsingStreamableGridCell(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Gets the number of chunks used by a particular Streamable Grid Cell for this LOD Group.
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The cell whose number of chunks you wish to know.
            </param>
            <returns type="int">
            The number of chunks used by the cell.
            </returns>
            <displayName id="GetCellChunksUsingStreamableGridCell">
            GetCellChunksUsingStreamableGridCell(Cell)
            </displayName>
            <syntax>
            public int GetCellChunksUsingStreamableGridCell(Cell streamableGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridLODDetails.GetCellChunksUsingArrayIndex(System.Int64)">
            <summary>
            Gets the number of chunks used by a particular Streamable Grid Cell for this LOD Group, however uses the 
            flattened index of the Streamable Grid Cell.
            </summary>
            <param name="flattenedStreamableGridIndex" type="long">
            The index of the cell whose number of chunks you wish to know. You may come by this value in two ways.
            <para>
            The first is by using the Streamable Grid's 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndex" href="StreamableGrid.html#FlattenCellIndex">FlattenCellIndex</see> function on a single 
            Streamable Grid Cell (<b>note that you cannot use 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndexForSparseEnabledArray" href="StreamableGrid.html#FlattenCellIndexForSparseEnabledArray">FlattenCellIndexForSparseEnabledArray</see>, as it returns values incompatible with this method</b>).
            </para>
            <para>
            The second is by iterating over the flattened indexes of all enabled cells via the Streamable Grid's 
            <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.FlattenedIndexesOfEnabledCells" href="StreamableGrid.html#FlattenedIndexesOfEnabledCells">FlattenedIndexesOfEnabledCells</see> method, which returns an enumerable 
            object that can be iterated over.
            </para>
            </param>
            <returns type="int">
            The number of chunks used by the cell.
            </returns>
            <displayName id="GetCellChunksUsingArrayIndex">
            GetCellChunksUsingArrayIndex(int)
            </displayName>
            <syntax>
            public int GetCellChunksUsingArrayIndex(int flattenedStreamableGridIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridLODDetails.TryGetExtraData_PreInitSafe(System.String,System.String@)">
            <summary>
            Tries to get extra data stored on this LOD Group using a key string value.
            <para>
            This data must be configured in one of two ways. Via the Streamable Grid inspector, either in the 
            global extra data for the Streamable Grid, or in the Extra Data section for the LOD. Or via the 
            SetExtraData_PreInitSafe method.
            If you used one of the preset keys, make sure the key you pass into this method matches how this preset appears in the inspector exactly!
            </para>
            <para>
            The method works by first trying to access the LOD Group specific extra data, and if that extra data contains a matching key, it returns the 
            data from the LOD Group. If no matching key is found in the LOD Group's extra data, the method searches the Streamable Grid's global extra data for the key, 
            and returns the data if found. If no key is found in either place, data is set to null and false is returned.
            </para>
            </summary>
            <param name="key" type="string">
            The key used to access the extra data.
            </param>
            <param name="data" type="string">
            If the method returns true, this will contain the extra data associated with the input key. If it returns false, this will be null.
            </param>
            <returns type="bool">
            True if the extra data was successfully retrieved. False otherwise.
            </returns>
            <displayName id="TryGetExtraData_PreInitSafe">
            TryGetExtraData_PreInitSafe(string, out string)
            </displayName>
            <syntax>
            public bool TryGetExtraData_PreInitSafe(string key, out string data)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridLODDetails.SetExtraData_PreInitSafe(System.String,System.String)">
            <summary>
            Sets the data for a given key. 
            <para>
            This will replace any existing data using the key for this LOD, or create a new entry if there is no existing entry using the key.
            </para>
            <para>
            Generally speaking, you should call this method before SAM has been initialized in order to ensure that anything making use of the 
            Extra Data will have the correct value, as most things making use of it will retrieve the extra data just once (when SAM is 
            initialized) and cache the value for performance reasons.
            </para>
            <para>
            If the extra data you are trying to change is stored in the Global Extra Data instead, you should use the Streamable Grid's 
            <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.SetGlobalExtraData_PreInitSafe(System.String,System.String)" href="StreamableGrid.html#SetGlobalExtraData_PreInitSafe">SetGlobalExtraData_PreInitSafe</see> method instead.
            </para>
            </summary>
            <param name="key" type="string">
            The key used to set the extra data.
            </param>
            <param name="data" type="string">
            The data to set.
            </param>
            <displayName id="SetExtraData_PreInitSafe">
            SetExtraData_PreInitSafe(string, string)
            </displayName>
            <syntax>
            public void SetExtraData_PreInitSafe(string key, string data)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridLODDetails.GetChunksArrayAsNativeArray(Unity.Collections.Allocator)">
            <summary>
            Creates and returns a Native Array that represents the chunk values for each cell on the Streamable Grid in association 
            with this LOD Group.
            <para>
            The only use case for this is if you need to do some processing involving the number of chunks and 
            you have an incredibly large number of cells on the Streamable Grid.
            </para>
            <para>
            Otherwise you should make use of the other "GetCellChunks..." methods instead.
            </para>
            <para>
            Note that if all cells use the same number of chunks, the array will be of length 1 with the uniform value stored at index 0.
            </para>
            </summary>
            <param name="allocationType" type="Allocator">
            The type of allocation to use for the Native Array.
            </param>
            <returns type="NativeArray&lt;int&gt;">
            The native array. Will be of length 1 if all cells have the same number of chunks.
            </returns>
            <displayName id="GetChunksArrayAsNativeArray">
            GetChunksArrayAsNativeArray(Allocator)
            </displayName>
            <syntax>
            public NativeArray&lt;int&gt; GetChunksArrayAsNativeArray(Allocator allocationType)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.HierarchyOrganizer">
            <summary>
            Provides a base implementation for Hierarchy Organizers, which are responsible for organizing the chunks of 
            <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">Worlds</see> into manageable hierarchies.
            <para>
            If using multiple <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">Worlds</see> at the same time, each 
            <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see> must use a different instance of the Hierarchy Organizer!
            </para>
            </summary>
            <title>HierarchyOrganizer Abstract Class</title>
            <category>Hierarchy Organizers</category>
            <navigationName>HierarchyOrganizer</navigationName>
            <fileName>HierarchyOrganizer.html</fileName>
            <syntax>
            public abstract class HierarchyOrganizer : MonoBehaviour
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.HierarchyOrganizer.MinChunksToAddPerFrame">
             <summary>
            The minimum number of chunks that will be added to the hierarchy in a single frame. Once this number is reached, SAM will query the World's
            <see cref="T:DeepSpaceLabs.SAM.ExecutionController" href="ExecutionController.html">Execution Controller</see> via ShouldContinueExecuting to see if another Add 
            Chunk cycle should be run, or if the add chunk process should yield for a frame.
             </summary>
             <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.HierarchyOrganizer.MinChunksToRemovePerFrame">
             <summary>
            The minimum number of chunks that will be removed from the hierarchy in a single frame. Once this number is reached, SAM will query the World's
            <see cref="T:DeepSpaceLabs.SAM.ExecutionController" href="ExecutionController.html">Execution Controller</see> via ShouldContinueExecuting to see if another 
            Remove Chunk cycle should be run, or if the remove chunk process should yield for a frame.
             </summary>
             <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.HierarchyOrganizer.World">
            <summary>
            Gets the world associated with the Hierarchy Organizer
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.HierarchyOrganizer.TransformHandler">
            <summary>
            Gets the transform handler associated with the Hierarchy Organizer.
            </summary>
            <type link="ISelfCreatingNewObjectHandler.html">ISelfCreatingNewObjectHandler&lt;Transform&gt;</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.HierarchyOrganizer.Initialize(DeepSpaceLabs.SAM.World,DeepSpaceLabs.SAM.ISelfCreatingNewObjectHandler{UnityEngine.Transform})">
            <summary>
            Initializes the hierarchy organizer. Each world should have a separate organizer object. This method needs to be called 
            before any other methods are called on the organizer. You can access the World and Transform Handler's passed into this 
            method from your derived classes via the same named properties. Note that when used with a World, this method is called 
            automatically by the World, so you don't need to call it yourself.
            </summary>
            <param name="world" type="World" link="World.html">
            The world whose chunks will be organized.
            </param>
            <param name="transformHandler" type="ISelfCreatingNewObjectHandler&lt;Transform&gt;" link="ISelfCreatingNewObjectHandler.html">
            A handler object which controls the retrieval of Transforms. These transforms are used as empty game object 
            parents to children for organizational purposes.
            </param>
            <displayName id = "Initialize">
            Initialize(World, ISelfCreatingNewObjectHandler&lt;Transform&gt;)
            </displayName>
            <syntax>
            public abstract void Initialize(World world, ISelfCreatingNewObjectHandler&lt;Transform&gt; transformHandler)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.HierarchyOrganizer.InitializeAdditional">
            <summary>
            Override in your derived class to perform additional initialization.
            </summary>
            <displayName id = "InitializeAdditional">
            InitializeAdditional()
            </displayName>
            <syntax>
            public virtual void InitializeAdditional()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.HierarchyOrganizer.AddChunkToHierarchy(System.Object,DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Adds a chunk (game object) to the organized hierarchy.
            </summary>
            <param name="chunk" type="GameObject">
            The chunk (game object) to add to the organized hierarchy.
            </param>
            <param name="worldCellChunkBelongsTo" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to. You can use information from the World Cell to 
            help organize the object into the hierarchy.
            </param>
            <displayName id = "AddChunkToHierarchy">
            AddChunkToHierarchy(GameObject, WorldCell)
            </displayName>
            <syntax>
            public abstract void AddChunkToHierarchy(GameObject chunk, WorldCell worldCellChunkBelongsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.HierarchyOrganizer.RemoveChunkFromHierarchy(System.Object,DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Removes a chunk (game object) from the organized hierarchy.
            </summary>
            <param name="chunk" type="GameObject">
            The chunk (game object) to remove from the organized hierarchy.
            </param>
            <param name="worldCellChunkBelongsTo" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <displayName id = "RemoveChunkFromHierarchy">
            RemoveChunkFromHierarchy(GameObject)
            </displayName>
            <syntax>
            public abstract void RemoveChunkFromHierarchy(GameObject chunk, WorldCell worldCellChunkBelongsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.HierarchyOrganizer.GetLODGroupName(DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Convenience method for getting the Group Name of a chunk. You could do the same thing yourself manually, 
            but it is easier to just use this method.
            </summary>
            <param name="worldCellThatChunkBelongsTo" type="WorldCell" link="WorldCell.html">
            The World Cell that the object belongs to.
            </param>
            <displayName id = "GetLODGroupName">
            GetLODGroupName(WorldCell)
            </displayName>
            <syntax>
            public string GetLODGroupName(WorldCell worldCellThatChunkBelongsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.HierarchyOrganizer.IsWorldGroupingChunkIsOn3D(DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Convenience method for determining whether the World Grouping that a chunk is on is 3D.
            </summary>
            <param name="worldCellThatChunkBelongsTo" type="WorldCell" link="WorldCell.html">
            The World Cell that the object belongs to.
            </param>
            <displayName id = "IsWorldGroupingChunkIsOn3D">
            IsWorldGroupingChunkIsOn3D(WorldCell)
            </displayName>
            <syntax>
            public bool IsWorldGroupingChunkIsOn3D(WorldCell worldCellThatChunkBelongsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.HierarchyOrganizer.DoesLODChunkIsPartOfUtilizeChunking(DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Convenience method for determining whether the LOD that the chunk is associated with utilizes chunking.
            </summary>
            <param name="worldCellThatChunkBelongsTo" type="WorldCell" link="WorldCell.html">
            The World Cell that the object belongs to.
            </param>
            <displayName id = "DoesLODChunkIsPartOfUtilizeChunking">
            DoesLODChunkIsPartOfUtilizeChunking(WorldCell)
            </displayName>
            <syntax>
            public bool DoesLODChunkIsPartOfUtilizeChunking(WorldCell worldCellThatChunkBelongsTo)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LoadingBlueprintRepository">
            <summary>
            The repository is meant to serve as a tangible reference to a collection of 
            <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprints</see>, and aids in the inuitive changing of blueprints midgame.
            </summary>
            <title>LoadingBlueprintRepository Class</title>
            <category>Scriptable Assets</category>
            <navigationName>LoadingBlueprintRepository</navigationName>
            <fileName>LoadingBlueprintRepository.html</fileName>
            <syntax>public sealed class LoadingBlueprintRepository : ScriptableObject</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprintRepository.NumberOfBlueprints">
            <summary>
            Gets the number of blueprints in this repository.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LoadingBlueprintRepository.GetLoadingBlueprintByIndex(System.Int32)">
            <summary>
            Gets a loading blueprint stored at the input index within this repository.
            </summary>
            <param name="indexOfBlueprintInRepository" type="int">
            The index of the blueprint. The indexes are the numbers you see to the left of each blueprint in the inspector of 
            your repository (1: , 2: , etc. - they are not the IDs!).
            <para>
            Generally speaking, we recommended using either  
            <see cref="M:DeepSpaceLabs.SAM.LoadingBlueprintRepository.GetLoadingBlueprintByName(System.String,System.Int32@)" href="#GetLoadingBlueprintByName">GetLoadingBlueprintByName</see> 
            or <see cref="M:DeepSpaceLabs.SAM.LoadingBlueprintRepository.GetLoadingBlueprintByID(System.Int32,System.Int32@)" href="#GetLoadingBlueprintByID">GetLoadingBlueprintByID</see> 
            method instead because if you remove a blueprint 
            from a repository, all blueprints after the removed one will have their indexes decremented. If the code calling this method is not changed to reflect these 
            decremented indexes, it's possble the code will expect a different blueprint than it receives.
            </para>
            </param>
            <returns type="Loading Blueprint" link="LoadingBlueprint.html">The Loading Blueprint at the specified index.</returns>
            <displayName id="GetLoadingBlueprintByIndex">
            GetLoadingBlueprintByIndex(int)
            </displayName>
            <syntax>
            public LoadingBlueprint GetLoadingBlueprintByIndex(int indexOfBlueprintInRepository)
            </syntax>
            <exception cref="T:System.IndexOutOfRangeException">
            Thrown if the index is not valid (less than 1 or greater than the number of blueprints in the respository)
            </exception>
            <exception cref="T:System.NullReferenceException">
            Thrown if the index points to a null blueprint, which should never happen. If it does, please contact me!!
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LoadingBlueprintRepository.GetLoadingBlueprintByID(System.Int32,System.Int32@)">
            <summary>
            Gets the loading blueprint with the specified ID from this repository.
            </summary>
            <param name="ID" type="int">
            The ID of the loading blueprint to get. You can identify this via the repositories inspector. 
            The ID is in parentheses to the right of each Blueprint Type (ID = #).
            </param>
            <param name="indexOfBlueprintInRepository" type="int">
            The index of the loading blueprint within the repository, set after the method returns.
            </param>
            <returns type="LoadingBlueprint" link="LoadingBlueprint.html">
            The loading blueprint with the ID.
            </returns>
            <displayName id="GetLoadingBlueprintByID">
            GetLoadingBlueprintByID(int, out int)
            </displayName>
            <syntax>
            public LoadingBlueprint GetLoadingBlueprintByID(int ID, out int indexOfBlueprintInRepository)
            </syntax>
            <exception cref="T:System.ArgumentException">
            Thrown when the ID does not correspond with a loading blueprint in the repository.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LoadingBlueprintRepository.GetLoadingBlueprintByName(System.String,System.Int32@)">
            <summary>
            Gets the loading blueprint of this repository using the provided name.
            </summary>
            <param name="nameOfBlueprintInRepository" type="string">
            The name of the blueprint.
            </param>
            <param name="indexOfBlueprintInRepository">
            The one based index of the blueprint in the repository, which will be set upon method conclusion.
            </param>
            <returns type="Loading Blueprint" link="LoadingBlueprint.html">The Loading Blueprint with the specified name.</returns>
            <displayName id="GetLoadingBlueprintByName">
            GetLoadingBlueprintByName(string, out int)
            </displayName>
            <syntax>
            public LoadingBlueprint GetLoadingBlueprintByName(string nameOfBlueprintInRepository, out int indexOfBlueprintInRepository)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidNameException" link="InvalidNameException.html">
            Thrown if the name is not valid.
            </exception>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LoadingBlueprint">
            <summary>
            Defines a loading blueprint, which is a collection of one or more loading patterns.
            <para>
            Loading Patterns are used in conjuction with the Player's position to determine which cells should be 
            loaded at any given time.
            </para>
            <para>
            Loading Blueprints are defined within 
            <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprintRepository" href="LoadingBlueprintRepository.html">Loading Blueprint Repositories</see>, 
            which offer a single access point for multiple 
            loading blueprints. The repository simplifies the process of switching loading blueprints at runtime (which has many uses, 
            not least of which is increasing performance or graphics fidelity to target the player's hardware [either automatically or by 
            allowing the player to adjust graphics settings in a menu]). Without the repository, saving changes to loading blueprints 
            at runtime (using save data) would be much more difficult.
            </para>
            <para>
            Each <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see> can be assigned a Loading Blueprint Repositories. 
            You can then choose a default Loading Blueprint for each Active Grid Grouping to use.
            </para>
            </summary>
            <title>LoadingBlueprint Class</title>
            <category>Primary Non Components</category>
            <navigationName>LoadingBlueprint</navigationName>
            <fileName>LoadingBlueprint.html</fileName>
            <syntax>public sealed class LoadingBlueprint</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.Is3D">
            <summary>
            Gets a value indicating whether the Loading Blueprint has cells on all three dimensions (X, Y, and Z). 3D Blueprints can only be used with 
            Active Grid Groupings synced to 3D World Groupings, while 2D Blueprints can only be used with Active Grid Groupings synced to 
            2D World Groupings.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.LoadingBlueprintType">
            <summary>
            Gets the loading blueprint type of this loading blueprint.
            </summary>
            <type link="LoadingBlueprintType.html">LoadingBlueprintType</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.MaxLevelsOfDetail">
            <summary>
            Gets the maximum number of LODs used by this loading blueprint. Some individual Loading Patterns may have less 
            LODs than this value.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.Name">
            <summary>
            Gets the name of the Loading Blueprint.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.RepositoryID">
            <summary>
            Gets the repository index of the Loading Blueprint, which is assigned to the Blueprint when it is added to the repository and will 
            never change so long as the Blueprint is not removed from the repository.
            <para>
            This is more reliable than the Name, as even if the Name changes this 
            ID will remain the same.
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.InnerAreaColumns">
            <summary>
            Gets the number of inner area columns in the Loading Blueprint.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.InnerAreaLayers">
            <summary>
            Gets the number of inner area layers in the Loading Blueprint. Only valid when the loading blueprint 
            is 3D.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.InnerAreaRows">
            <summary>
            Gets the number of inner area rows in the Loading Blueprint.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.SectionColumns">
            <summary>
            Gets the number of sectional columns in the Loading Blueprint. Only valid when the loading blueprint 
            type is Uniform Sectioned
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.SectionLayers">
            <summary>
            Gets the number of sectional layers in the Loading Blueprint. Only valid when the loading blueprint 
            type is Uniform Sectioned and the blueprint is 3D.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.LoadingBlueprint.SectionRows">
            <summary>
            Gets the number of sectional rows in the Loading Blueprint. Only valid when the loading blueprint 
            type is Uniform Sectioned
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LoadingBlueprint.GetCells(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell,System.Collections.Generic.ICollection{DeepSpaceLabs.SAM.LODCell})">
            <summary>
            Gets the Cells for the given loading pattern (using patternKey). Note that internally the loading pattern Cells are just a 
            collection of offsets from the first Cell in the inner area of the loading pattern.
            <para>
            Therefore, in order to get a collection of 
            useful cells that corresponds to the World, it is necessary to 
            provide the value of the first cell in the inner area.
            </para>
            </summary>
            <param name="patternKey" type="Cell" link="Cell.html">
            The Cell that identifies the loading pattern to get Cells for. If using a Uniform Ring or Uniform Custom Shape Blueprint, this value is 
            ignored, as there is only a single default loading pattern to choose from.
            <para>
            For Sectioned Blueprints, the pattern key is the sectioned Cell whose pattern of Cells you want to retrieve. For instance, the bottom left most 
            sectioned cell would always be Cell(1,1) or Cell(1,1,1) [for 3D blueprints].
            </para>
            <para>
            For Non Uniform Blueprints, the key is the Streamable Grid Cell that is at the center of the pattern (typically the Cell the player is standing in), and should be the same as firstCellInInnerArea.
            </para>
            </param>
            <param name="firstCellInInnerArea" type="Cell" link="Cell.html">
            The value of the first cell in the inner area of the loading pattern identified by patternKey. Used to assign real world 
            values to the cells, because otherwise they are just offsets. If you want the raw offset values, simply pass in Cell.Zero.
            <para>
            When using a Non Unfirom Blueprint, this Cell should be the same Cell as patternKey (unless you are trying to get raw offset values), 
            since Non Uniform blueprints only contain 
            patterns with a single inner area Cell.
            </para>
            </param>
            <param name="cells" type="ICollection&gt;LODCell&lt;" link="LODCell.html">
            The collection of LOD Cells which this method will add the cells to. Used to save on memory, as you can reuse the same 
            collection (clearing before hand of course) before calling the method. Note that use of the 
            <see cref="!:ActiveGrid.GetRegisteredActiveCells(int, ICollection&lt;LODCell&gt;, bool)" href="ActiveGrid.html#GetRegisteredActiveCells">ActiveGrid.GetRegisteredActiveCells</see> 
            method automatically clears the collection if it is not empty, so you don't have to. The collection can be 
            any type that implements the ICollection&lt;LODCell&gt; interface, such as a lists or hash set.
            </param>
            <displayName id="GetCells">
            GetCells(Cell, Cell, ICollection&lt;LODCell&gt;)
            </displayName>
            <syntax>
            public void GetCells(Cell patternKey, Cell firstCellInInnerArea, ICollection&gt;LODCell&lt; cells)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LoadingBlueprint.GetCells(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell,System.Collections.Generic.ICollection{DeepSpaceLabs.SAM.ZoneGroupingLODCell},System.Int32,System.Int32)">
            <summary>
            Gets the Cells for the given loading pattern (using patternKey). Note that internally the loading pattern Cells are just a 
            collection of offsets from the first Cell in the inner area of the loading pattern.
            <para>
            Therefore, in order to get a collection of 
            useful cells that corresponds to the World, it is necessary to 
            provide the value of the first cell in the inner area.
            </para>
            </summary>
            <param name="patternKey" type="Cell" link="Cell.html">
            The Cell that identifies the loading pattern to get Cells for. If using a Uniform Ring or Uniform Custom Shape Blueprint, this value is 
            ignored, as there is only a single default loading pattern to choose from.
            <para>
            For Sectioned Blueprints, the pattern key is the sectioned Cell whose pattern of Cells you want to retrieve. For instance, the bottom left most 
            sectioned cell would always be Cell(1,1) or Cell(1,1,1) [for 3D blueprints].
            </para>
            <para>
            For Non Uniform Blueprints, the key is the Streamable Grid Cell that is at the center of the pattern (typically the Cell the player is standing in), and should be the same as firstCellInInnerArea.
            </para>
            </param>
            <param name="firstCellInInnerArea" type="Cell" link="Cell.html">
            The value of the first cell in the inner area of the loading pattern identified by patternKey. Used to assign real world 
            values to the cells, because otherwise they are just offsets. If you want the raw offset values, simply pass in Cell.Zero.
            <para>
            When using a Non Unfirom Blueprint, this Cell should be the same Cell as patternKey (unless you are trying to get raw offset values), 
            since Non Uniform blueprints only contain 
            patterns with a single inner area Cell.
            </para>
            </param>
            <param name="cells" type="ICollection&gt;LODCell&lt;" link="LODCell.html">
            The collection of LOD Cells which this method will add the cells to. Used to save on memory, as you can reuse the same 
            collection (clearing before hand of course) before calling the method. Note that use of the 
            <see cref="!:ActiveGrid.GetRegisteredActiveCells(int, ICollection&lt;LODCell&gt;, bool)" href="ActiveGrid.html#GetRegisteredActiveCells">ActiveGrid.GetRegisteredActiveCells</see> 
            method automatically clears the collection if it is not empty, so you don't have to. The collection can be 
            any type that implements the ICollection&lt;LODCell&gt; interface, such as a lists or hash set.
            </param>
            <displayName id="GetCells">
            GetCells(Cell, Cell, ICollection&lt;LODCell&gt;)
            </displayName>
            <syntax>
            public void GetCells(Cell patternKey, Cell firstCellInInnerArea, ICollection&gt;LODCell&lt; cells)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkDestroyer">
            <summary>
            Provides a base implementation for Chunk Destroyers.
            <para>Chunk Destroyers can be used to customize the destruction strategy used by the Stremable Assets Manager. Basically, whenever an object
            needs to be destroyed, rather than calling GameObject.Destroy on the object (the default behaviour when no Chunk Destroyer is present),
            the chunk will be passed off to the Chunk Destroyer.</para>
            <para>
            This allows you to create custom destruction solutions that fit your particular child-parent hiearchy.
            </para>
            <para>
            For instance, you can create a destroyer that destroys all grandchildren in one frame, then all those grandchildren's parents 
            in the next frame, and finally the root game object in the last frame.
            </para>
            <para>
            The Destroyer must be supplied in the "Chunk Destroyer" option in the inspector of whatever
            <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href = "ChunkManager.html">ChunkManager</see> Component you are using.
            </para>
            </summary>
            <title>ChunkDestroyer Abstract Class</title>
            <category>Chunk Destroyers</category>
            <navigationName>ChunkDestroyer</navigationName>
            <fileName>ChunkDestroyer.html</fileName>
            <syntax>public abstract class ChunkDestroyer : MonoBehaviour</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkDestroyer.DestroyChunksOnCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.MemoryFreeingStrategy,DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser,System.Boolean)">
            <summary>
            When overridden by a derived class and assigned to a Chunk Manager, 
            can be used to customize the behaviour for how chunks (game objects/chunks) 
            are removed from the active scene.
            <para>
            Note that in most instances all chunks will be present, however if your game removes chunks manually (i.e., outside 
            of the scope of SAM), you should take this into account and check to make sure the chunks are not null before 
            trying to destroy them.
            </para>
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells with the chunks needing to be destroyed/unloaded. You must use the DetachChunksFromCell to get each 
            chunk from each cell, which is only available when the WorldCell is casted to a IDetachableWorldCell. This method both 
            retrieves the chunk and nulls out the cells reference to it. Since World Chunks are reused internally by SAM, 
            this latter point is very important. Failing to call DetachChunksFromCell for all 
            chunks on all cells will certainly result in unexpected behaviour.
            </param>
            <param name="memoryFreeingStrategy" type = "MemoryFreeingStrategy" link="MemoryFreeingStrategy.html">
            The Memory Freeing Strategy set in the inspector of the calling Chunk Manager. 
            You can make use of this value or ignore it.
            </param>
            <param name="ChunkStreamerUser" type = "ChunkStreamer.ChunkStreamerUser">
            The user which triggered the method call. Typically you will not need the data from this user, however it is provided in case you do. If you 
            are using the Chunk Destroyer with a custom Chunk Streamer that utilizes a custom ChunkStreamerUser derived class, you can cast this user object to 
            the type you know it is.
            </param>
            <param name="waitOnFinalMemoryFreeing" type="bool">
            If memoryFreeingStrategy is not set to Dont Free Memory, this controls whether the destroyer will wait on the final memory freeing operation before 
            yielding control back to the calling Chunk Streamer. Setting this to false may speed up the World Update Speed, or it may not, since the memory 
            freeing strategy will block other Async operations from executing.
            </param>
            <displayName id="DestroyChunksOnCells">
            DestroyChunksOnCells(List&lt;WorldCell&gt;, MemoryFreeingStrategy, ChunkStreamer.ChunkStreamerUser, bool)
            </displayName>
            <syntax
            >public abstract IEnumerator&lt;YieldInstruction&gt; DestroyChunksOnCells(List&lt;WorldCell&gt; cells, MemoryFreeingStrategy memoryFreeingStrategy, ChunkStreamer.ChunkStreamerUser ChunkStreamerUser, bool waitOnFinalMemoryFreeing)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ComponentManager">
            <summary>
            Defines a manager which handles a variety of task, from handling persistent data to initializing all 
            <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">Worlds</see> and
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grids</see> in the scene. There should only be one Component Manager in each of your scenes.
            <para>
            You can destroy and create Active Grids and Worlds during runtime via the Component Manager class. To create these 
            components at runtime, you will need to provide one or more prototypes. Prototypes store default configuration data 
            as well as references to other crucial components that cannot be identified at runtime. Prototypes should be attached 
            to disabled game objects.
            </para>
            <para>
            To save/load data, use one of the provided implmentations of IPersistentStateManager (or create your own) in combination with the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Save(DeepSpaceLabs.SAM.IPersistentStateManager)" href="#Save">Save</see> and <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Load(DeepSpaceLabs.SAM.IPersistentStateManager,System.Boolean)" href="#Load">Load</see> methods.
            </para>
            <para>
            There is a limited window in which persistent data can be loaded via the Load method. This window 
            will close immediately when CreatePersistentActiveGrid, CreateNonPersistentActiveGrid, CreatePersistentWorld, 
            or CreateNonPersistentWorld are called for the first time. It will also close once 
            the Component Manager has been initialized. You can delay initialization by unchecking "Initialize On Awake," but you 
            will have to manually call Initialize or InitializeGradually.
            </para>
            </summary>
            <title>ComponentManager Class</title>
            <category>Primary Components</category>
            <navigationName>ComponentManager</navigationName>
            <fileName>ComponentManager.html</fileName>
            <syntax>public sealed class ComponentManager : MonoBehaviour, <see href = "IIdentifiable.html">IIdentifiable</see></syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ComponentManager.ID">
            <summary>
            The ID that uniquely identifies this Component Manager.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ComponentManager.InitializationProgress">
            <summary>
            Gets the progress of a gradual initialization operation, which you can use in a loading bar when Initializing the Component Manager. Ranges between 0f (before 
            initialization has begun) and 1f (after initialization completes).
            <para>
            Does not track progress for single frame initialization!
            </para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ComponentManager.InitializationTriggered">
            <summary>
            Gets a value indicating whether one of the Component Manager's initialization 
            methods has been called already.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ComponentManager.IsInitialized">
            <summary>
            Gets a value indicating whether the Component Manager has been fully Initialized (and without errors). 
            <para>
            If initialized gradually, this returns true only after the gradual initiation completes. If initialized immediately, this returns true after the second frame of initializaiton.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ComponentManager.WasInitializedGradually">
            <summary>
            Gets a value indicating whether the Component Manager was initialized gradually. If false, it means Initialize was used to 
            initialize the manager, either from a manual method call or because Initialize on Awake was enabled on the manager. Note, you should 
            only check this property if IsInitialized returns true.
            </summary>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ComponentManager.ComponentManagerInitialized">
            <summary>
            An event that can be subscribed to in order to receive notification after the Component Manager (and thus all 
            Worlds and Active Grids currently loaded) has been initialized. This is useful as you have the gaurantee that 
            your Worlds/Active Grids will be loaded (assuming the Active Grids have their Load Cells option enabled), so you can 
            for example get the list of currently active LODCells from an Active Grid you are using, or retrieve a World Cell 
            from the World.
            <para>
            Note that the event is only fired once, so it's best to unsubscribe from the event once it fires. Also note that the 
            sender argument is an Object, but this will be the Component Manager you are using in the scene, so you can safely cast the sender 
            to a ComponentManager object if you need to.
            </para>
            <para>
            It is not necessary to ubsubscribe to this event. The Component Manager will set the event to null after it has been 
            initialized, since it will never be used again.
            </para>
            </summary>
            <validSubscriber>void MethodName(object sender)</validSubscriber>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ComponentManager.ActiveGridInitializing">
            <summary>
            An event that can be subscribed to in order to receive notification right before an  
            Active Grid is initialized.
            </summary>
            <validSubscriber>void MethodName(object sender, ActiveGrid activeGrid)</validSubscriber>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ComponentManager.ActiveGridInitialized">
            <summary>
            An event that can be subscribed to in order to receive notification right after an  
            Active Grid is initialized.
            </summary>
            <validSubscriber>void MethodName(object sender, ActiveGrid activeGrid)</validSubscriber>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ComponentManager.WorldInitializing">
            <summary>
            An event that can be subscribed to in order to receive notification right before a 
            World is initialized.
            </summary>
            <validSubscriber>void MethodName(object sender, World world)</validSubscriber>
        </member>
        <member name="E:DeepSpaceLabs.SAM.ComponentManager.WorldInitialized">
            <summary>
            An event that can be subscribed to in order to receive notification right after a 
            World is initialized.
            </summary>
            <validSubscriber>void MethodName(object sender, World world)</validSubscriber>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.Initialize">
            <summary>
            Initializes the Component Manager over two frames. This in turn closes the window for loading persistent data  
            and initializes all non prototype 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grids</see>/<see cref="T:DeepSpaceLabs.SAM.World" href="World.html">Worlds</see> in the scene.
            <para>
            This should only be used if "Initialize On Awake" is unchecked in the inspector, and then only at the beginning 
            of the game from another scripts Awake method. If the game has started (i.e., the update cycle is running), you should use 
            InitializeGradually instead (for performance reasons).
            </para>
            <para>
            This is meant to be used for debugging and testing mostly. For an actual game, it is recommended to use 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.InitializeGradually" href="#InitializeGradually">InitializeGradually</see> 
            as it offers better performance and can be used with a loading screen.
            </para>
            <para>
            Progress Tracking is also only available when using <see cref="M:DeepSpaceLabs.SAM.ComponentManager.InitializeGradually" href="#InitializeGradually">InitializeGradually</see> 
            (using the <see cref="P:DeepSpaceLabs.SAM.ComponentManager.InitializationProgress" href="#InitializationProgress">InitializationProgress</see> property).
            </para>
            </summary>
            <displayName id="Initialize">Initialize()</displayName>
            <syntax>public void Initialize()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.InitializeGradually">
            <summary>
            Initialzes the Component Manager over a series of frames. This coroutine exits only after all initial World Cells and Asset 
            Chunks have been loaded, which allows you to display a loading screen or use some other device to hide the game world until it is fully loaded.
            <para>
            This should only be used if "Initialize On Awake" is unchecked in the inspector.
            </para>
            <para>
            The progress of this method can be tracked via the 
            <see cref="P:DeepSpaceLabs.SAM.ComponentManager.InitializationProgress" href="#InitializationProgress">InitializationProgress</see> property, 
            which should only be queried after the method starts executing. Once the 
            Initialization process is completed, that property will always return 1f.
            </para>
            <para>
            Because this method is more performant and progress can be tracked, we recommend it for a live game (non testing environment).
            </para>
            </summary>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="InitializeGradually">InitializeGradually()</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; InitializeGradually()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.DoesOldDataExist(DeepSpaceLabs.SAM.PersistentDataController)">
            <summary>
            Can be used to determine whether any persistent data saved using the Persistent Data Controller 
            exist for this Component Manager. If such data exist, you should use 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(DeepSpaceLabs.SAM.PersistentDataController,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{System.String},System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})" href="ComponentManager.html#ConvertOldSaveData1">ConvertOldSaveData</see> 
            to convert it to the format used by your Persistent State Manager, before calling the 
            Component Manager's Load method.
            <para>
            This method should only be used at runtime (in game).
            </para>
            </summary>
            <param name="persistentDataController" type="PersistentDataController" link="PersistentDataController.html">
            The Persistent Data Controller that would have been used to save the data. Note that the PersistentDataController found in the old 
            DynamicLoadingKit namespace is not valid here; you will need to convert your custom PersistentDataController or 
            PlayerPrefsPersistentDataController to a version from the DeepSpaceLabs.SAM namespace.
            </param>
            <returns type="bool">
            True if data exist, false otherwise.
            </returns>
            <displayName id="DoesOldDataExist">
            DoesOldDataExist(PersistentDataController)
            </displayName>
            <syntax>
            public bool DoesOldDataExist(PersistentDataController persistentDataController)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.DuplicateIDException" link="DuplicateIDException.html">
            If World components exist with the same ID, this exception may be thrown. The same goes for Active Grid components using the same ID.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(DeepSpaceLabs.SAM.PersistentDataController,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{System.String},System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})">
            <summary>
            Use this to convert data that was saved via the Component Manager using a Persistent Data Controller to a format compatible with Persistent State Managers. 
            This method will basically load the data and re-save it using the passed in Persistent State Manager, so the Persistent State Manager should be setup to save data just as if the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Save(DeepSpaceLabs.SAM.IPersistentStateManager)" href="ComponentManager.html#Save">Save</see> method were being used. The data is only loaded for re-saving purposes, it will not be used by the Component Manager when 
            it is initialized like the normal <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Load(DeepSpaceLabs.SAM.IPersistentStateManager,System.Boolean)" href="ComponentManager.html#Load">Load</see> method. As such, you will still need to call the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Load(DeepSpaceLabs.SAM.IPersistentStateManager,System.Boolean)" href="ComponentManager.html#Load">Load</see> method once you have converted the data.
            <para>
            Under some scenarios it is possible for the conversion to fail, either in part or in total. When this happens, a DataConversionException will be thrown. It is recommended to place this method's 
            invocation in a try/catch statement, catching the DataConversionException and handling it properly. If the exception is not thrown, it means the data was converted 100% successfully and you can 
            delete the old data either manually or using the DeleteOldData method. Conversion failures may be fixable through modifications to your scene (common), or they may be due to corrupted save data (rare).
            </para>
            <para>
            Please note that for runtime created Active Grids and Worlds, the protoype ID is now used to identify prototypes rather than the index of the prototype in the Prototype Array. Since the old save data 
            will still be using the index, it's important to ensure the ordering of prototypes is the same now as it was when the data was saved, and that all prototypes that were in use at the time of 
            saving are still in use, so that the prototypes can be matched correctly. In addition, the ID's of the prototypes must be configured so that all prototypes of a specific component type (World or 
            Active Grid) use unique ID's (note, they do not need to be different than non prototypes that have been added to the scene in the Unity Editor, as these use a different pool of IDs).
            </para>
            <para>
            Once conversion has been executed, you are free to re-order and remove prototypes, so long as you do not change the IDs and do not remove prototypes that are present in persistent data.
            </para>
            </summary>
            <param name="persistentDataController" type="PersistentDataController" link="PersistentDataController.html">
            The upgraded persistent data controller that represents the old persistent data controller that was used to save the data you want to convert. 
            If you haven't upgraded your Persistent Data Controller yet, please take a look at the Pertinent Data Controller Section in the 
            Upgrading Chapter of the In-Editor Guide.
            </param>
            <param name="persistentStateManager" type="IPersistentStateManager" link="IPersistentStateManager.html">
            The new Persistent State Manager to use to re-save the old data. This manager should be configured correctly to save to a save file. The file should be set prior to calling this method.
            </param>
            <param name="oldDataKeys" type="List&lt;string&gt;">
            When data conversion is 100% successful, this list will be full of every key associated with the old persistent data. You can then manually delete the old save data associated with these keys using the 
            Persistent Data Controller, or pass the list into the <see cref="M:DeepSpaceLabs.SAM.ComponentManager.DeleteOldData(DeepSpaceLabs.SAM.PersistentDataController,System.Collections.Generic.List{System.String})" href="ComponentManager.html#DeleteOldData">DeleteOldData</see> method to let the Component Manager do it automatically. 
            The passed in list must not be null or a DataConversionException will be thrown; also note that the list is cleared by the method so you don't need to clear it beforehand.
            </param>
            <param name="oldActiveGridData" type="List&lt;OldActiveGridData&gt;" link="OldActiveGridData.html">
            Active Grids that were formerly ring based used some settings to define there inner area and outer ring width. These settings are no longer used with the addition of Loading Blueprints, so the conversion method basically 
            ignores them. However, you may wish to manually set your Active Grids to specific Loading Blueprints based on the saved inner area size and outer ring width value. If you are interested in doing this, you can pass in a 
            non null, empty List and for each Active Grid (inspector or runtime created) that has persistent data saved in the old data, an entry will be added to the list. You can 
            then use the ActiveGrid.PreInitialize_SetLoadingBlueprint method to set the Loading Blueprint that best matches the old data.
            </param>
            <displayName id="ConvertOldSaveData1">
            ConvertOldSaveData(PersistentDataController, IPersistentStateManager, List&lt;string&gt;, [List&lt;OldActiveGridData&gt;])
            </displayName>
            <syntax>
            public void ConvertOldSaveData(PersistentDataController persistentDataController, IPersistentStateManager persistentStateManager, List&lt;string&gt; oldDataKeys, List&lt;OldActiveGridData&gt; oldActiveGridData = null)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.DataConversionException" link="DataConversionException.html">
            The conversion method is setup so that if any single piece of the old data cannot be converted correctly, this exception is thrown. This is primarily intende to give you an idea on whether the conversion 
            was successful. If conversion is 100% successful, oldDataKeys will be full of keys belonging to the old data, which you can delete manually or use with the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.DeleteOldData(DeepSpaceLabs.SAM.PersistentDataController,System.Collections.Generic.List{System.String})" href="ComponentManager.html#DeleteOldData">DeleteOldData</see> method if you want to clear the old save data.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(System.String,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})">
            <summary>
            Use this to convert old data saved using the Component Manager's GetSaveData method (no longer available) to a format compatible with Persistent State Managers. 
            This method will basically load the data and re-save it using the passed in Persistent State Manager, so the Persistent State Manager should be setup to save data just as if the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Save(DeepSpaceLabs.SAM.IPersistentStateManager)" href="ComponentManager.html#Save">Save</see> method were being used. The data is only loaded for re-saving purposes, it will not be used by the Component Manager when 
            it is initialized like the normal <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Load(DeepSpaceLabs.SAM.IPersistentStateManager,System.Boolean)" href="ComponentManager.html#Load">Load</see> method. As such, you will still need to call the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Load(DeepSpaceLabs.SAM.IPersistentStateManager,System.Boolean)" href="ComponentManager.html#Load">Load</see> method once you have converted the data.
            <para>
            Under some scenarios it is possible for the conversion to fail, either in part or in total. When this happens, a DataConversionException will be thrown. It is recommended to place this method's 
            invocation in a try/catch statement, catching the DataConversionException and handling it properly. If the exception is not thrown, it means the data was converted 100% successfully and you can 
            delete the old string data if you wish. Conversion failures may be fixable through modifications to your scene (common), or they may be due to corrupted save data (rare).
            </para>
            <para>
            Please note that for runtime created Active Grids and Worlds, the protoype ID is now used to identify prototypes rather than the index of the prototype in the Prototype Array. Since the old save data 
            will still be using the index, it's important to ensure the ordering of prototypes is the same now as it was when the data was saved, and that all prototypes that were in use at the time of 
            saving are still in use, so that the prototypes can be matched correctly. In addition, the ID's of the prototypes must be configured so that all prototypes of a specific component type (World or 
            Active Grid) use unique ID's (note, they do not need to be different than non prototypes that have been added to the scene in the Unity Editor, as these use a different pool of IDs).
            </para>
            <para>
            Once conversion has been executed, you are free to re-order and remove prototypes, so long as you do not change the IDs and do not remove prototypes that are present in persistent data.
            </para>
            </summary>
            <param name="oldSaveData" type="string">
            The old data you wish to convert.
            </param>
            <param name="persistentStateManager" type="IPersistentStateManager" link="IPersistentStateManager.html">
            The new Persistent State Manager to use to re-save the old data. This manager should be configured correctly to save to a save file. The file should be set prior to calling this method.
            </param>
            <param name="oldActiveGridData" type="List&lt;OldActiveGridData&gt;" link="OldActiveGridData.html">
            Active Grids that were formerly ring based used some settings to define there inner area and outer ring width. These settings are no longer used with the addition of Loading Blueprints, so the conversion method basically 
            ignores them. However, you may wish to manually set your Active Grids to specific Loading Blueprints based on the saved inner area size and outer ring width value. If you are interested in doing this, you can pass in a 
            non null, empty List and for each Active Grid (inspector or runtime created) that has persistent data saved in the old data, an entry will be added to the list.
            </param>
            <displayName id="ConvertOldSaveData2">
            ConvertOldSaveData(string, IPersistentStateManager, [List&lt;OldActiveGridData&gt;])
            </displayName>
            <syntax>
            public static void ConvertOldSaveData(string oldSaveData, IPersistentStateManager persistentStateManager, List&lt;OldActiveGridData&gt; oldActiveGridData = null)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.DataConversionException" link="DataConversionException.html">
            The conversion method is setup so that if any single piece of the old data cannot be converted correctly, this exception is thrown. This is primarily intended to give you an idea of whether the conversion 
            was successful. If conversion is 100% successful, you can safely delete the old save data. If it fails and this exception is thrown, you can examine the exception message to determine whether it's an issue 
            that can be fixed with changes to the scene or not.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.DeleteOldData(DeepSpaceLabs.SAM.PersistentDataController,System.Collections.Generic.List{System.String})">
            <summary>
            Convenience method for deleting old data saved using a Persistent Data Controller. You can use this method after calling 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(DeepSpaceLabs.SAM.PersistentDataController,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{System.String},System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})" href="ComponentManager.html#ConvertOldSaveData1">ConvertOldSaveData</see> 
            (PersistentDataController version) and having it complete 100% successfully (no DataConversionException thrown). That method will populate the oldDataKeys list with all of the keys associated with the old data. 
            This method then just cycles through these keys and calls 
            <see cref="M:DeepSpaceLabs.SAM.PersistentDataController.TryDeleteData(System.String)" href="PersistentDataController.html#TryDeleteData">PersistentDataController.TryDeleteData</see> for each one.
            </summary>
            <param name="persistentDataController" type="PersistentDataController" link="PersistentDataController.html">
            The upgraded persistent data controller that represents the old persistent data controller that was used to save the data you want to delete. 
            If you haven't upgraded your Persistent Data Controller yet, please take a look at the Pertinent Data Controller Section in the Upgrading Chapter.
            <para>
            This should match the Persistent Data Controller you passed into the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(DeepSpaceLabs.SAM.PersistentDataController,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{System.String},System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})" href="ComponentManager.html#ConvertOldSaveData1">ConvertOldSaveData</see> 
            method.
            </para>
            </param>
            <param name="oldDataKeys" type="List&lt;string&gt;">
            When data conversion is 100% successful using the 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(DeepSpaceLabs.SAM.PersistentDataController,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{System.String},System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})" href="ComponentManager.html#ConvertOldSaveData1">ConvertOldSaveData</see> method, 
            the oldDataKeys list will be filled with every key associated with the old persistent data. Pass that list into this method to delete the data associated with the keys. The list is cleared upon completion.
            </param>
            <displayName id="DeleteOldData">
            DeleteOldData(PersistentDataController, List&lt;string&gt;)
            </displayName>
            <syntax>
            public void DeleteOldData(PersistentDataController persistentDataController, List&lt;string&gt; oldDataKeys)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.Load_EventUsable(UnityEngine.MonoBehaviour)">
            <summary>
            Like the Load method, however this method can be "hooked up" to a Unity Event via the inspector. Note that to accomplish this, the parameter 
            type is MonoBehaviour, however this MonoBehaviour must implement the 
            <see cref="T:DeepSpaceLabs.SAM.IPersistentStateManager" href="IPersistentStateManager.html">IPersistentStateManager</see> interface or an exception will be thrown! Also note 
            that unlike the other Load method, this method does not allow you specify performComponentManagerIDCheck. This is necessary because 
            Unity events only allow for one parameter. Because of this, performComponentManagerIDCheck is treated as true. If you need to use a value of 
            false, you will need to use the other method that allows you to explicitly set performComponentManagerIDCheck.
            <para>
            Loads save data that was saved via the Save method. You can use one of the provided MonoBehaviour implmentations of this 
            interface or create your own implementation, as the interface 
            provides maximum flexibility to control how your save system works.
            </para>
            <para>
            VERY IMPORTANT: There is a limited window in which persistent data can be loaded via this method. This window 
            will close immediately when CreatePersistentActiveGrid, CreateNonPersistentActiveGrid, CreatePersistentWorld, 
            or CreateNonPersistentWorld are called for the first time. It will also close once 
            the Component Manager has been initialized (usually via the SAMInitializer).
            </para>
            </summary>
            <param name="persistentStateManager" type = "MonoBehaviour">
            The persistent state manager for the Component Manager to use to setup the state of this Component Manager and all persistent Worlds 
            and Active Grids. Must implement the <see cref="T:DeepSpaceLabs.SAM.IPersistentStateManager" href="IPersistentStateManager.html">IPersistentStateManager</see> interface.
            </param>
            <displayName id="Load_EventUsable">
            Load_EventUsable(MonoBehaviour)
            </displayName>
            <syntax>
            public void Load_EventUsable(MonoBehaviour persistentStateManager)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called and Use Custom Save/Load Solution is not checked in the inspector, or if the 
            Component Manager passed the phase where persistent save data can be loaded.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when this method is called and persistentStateManager does not implement the IPersistentStateManager interface.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPersistentDataException" link="InvalidPersistentDataException.html">
            Thrown when this method is called and the persistent data loaded is found to be invalid. This really should not happen 
            and indicates a critical error in your save/load process.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.Load(DeepSpaceLabs.SAM.IPersistentStateManager,System.Boolean)">
            <summary>
            Loads save data that was saved via the Save method. This method makes use of the
            <see cref="T:DeepSpaceLabs.SAM.IPersistentStateManager" href="IPersistentStateManager.html">IPersistentStateManager</see> interface. 
            You can use one of the provided implmentations of this interface or create your own implementation, as the interface 
            provides maximum flexibility to control how your save system works.
            <para>
            VERY IMPORTANT: There is a limited window in which persistent data can be loaded via this method. This window 
            will close immediately when CreatePersistentActiveGrid, CreateNonPersistentActiveGrid, CreatePersistentWorld, 
            or CreateNonPersistentWorld are called for the first time. It will also close once 
            the Component Manager has been initialized (usually via the SAMInitializer).
            </para>
            </summary>
            <param name="persistentStateManager" type = "IPersistentStateManager" link="IPersistentStateManager.html">
            The persistent state manager for the Component Manager to use to setup the state of this Component Manager and all persistent Worlds 
            and Active Grids.
            </param>
            <param name="performComponentManagerIDCheck" type = "bool">
            If true, the method will perform a check of this Component Manager's ID against the ID stored in the save data. If they do not match, an 
            exception will be thrown.
            <para>
            You should usually pass in true, however if you have changed the Component Manager ID for some reason and are sure the save data that will be 
            loaded by the Persistent State Manager corresponds to this Component Manager, you can pass in false, otherwise the load operation will fail.
            </para>
            </param>
            <displayName id="Load">
            Load(IPersistentStateManager, bool)
            </displayName>
            <syntax>
            public void Load(IPersistentStateManager persistentStateManager, bool performComponentManagerIDCheck)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown when this method is called and Use Custom Save/Load Solution is not checked in the inspector, or if the 
            Component Manager passed the phase where persistent save data can be loaded.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when this method is called and persistentStateManager is set to null.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPersistentDataException" link="InvalidPersistentDataException.html">
            Thrown when this method is called and the persistent data loaded is found to be invalid. This really should not happen 
            and indicates a critical error in your save/load process.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.CreateNonPersistentActiveGridUsingTransform(System.Int32,DeepSpaceLabs.SAM.World,UnityEngine.Transform,DeepSpaceLabs.SAM.PlayerMover)">
            <summary>
            Creates and initializes a non-persistent Active Grid based on the prototype 
            and the specified optional parameters.
            The grid data will not be saved with the component manager's save data.
            <para>
            When the Active Grid is initialized, the World the grid is 
            synced to will also be initialized, as well as this Component Manager if it has not 
            already been initialized.
            </para>
            <para>
            Note, however, that you will need to manually enable World Updating on the Active Grid via the 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean)" href="ActiveGrid.html#TrySetIfWorldShouldBeUpdated1">
            TrySetIfWorldShouldBeUpdated
            </see> 
            or 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(System.Boolean)" href="ActiveGrid.html#TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate1">
            TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate
            </see> method. With World Updating disabled (the default state if one of those methods are not called), 
            the Active Grid will not trigger the World to load/unload objects!
            </para>
            </summary>
            <param name="IDOfPrototypeToConstructGridFrom" type="int">
            The ID of the Prototype to use to construct the Runtime Active Grid. Remember, all Active Grid Prototypes in use in the current scene must have unique IDs.
            </param>
            <param name="alternateWorldToSyncTo" type="World" link="World.html">
            An alternate world for the grid to start synced to. This world can be either persistent or non persistent.
            </param>
            <param name="alternatePlayerToAssociateWithGrid" type="Transform">
            If provided, the grid will use this Transform to create a Transform based Player upon initialization, 
            otherwise the grid will be associated with the default Player of the 
            prototype (determined by Player Type). If a transform is not passed in and no player is assigned 
            via the prototype's inspector, an exception will be thrown.
            </param>
            <param name="playerMoverToAssociateWithGrid" type="PlayerMover" link="PlayerMover.html">
            If provided, the grid will use this PlayerMover when moving the Player. 
            If alternatePlayerToAssociateWithGrid is set and playerMoverToAssociateWithGrid is null, 
            the Active Grid will not use the default PlayerMover of the prototype. 
            Instead, the player mover will be set to null and the Player will be moved by setting 
            its Position property. Therefore, you must be sure to provide a valid object for this argument
            if you provide an alternate player transform and want to make use of PlayerMover.
            </param>
            <returns type="ActiveGrid" link="ActiveGrid.html">
            The created and initialized non persistent Active Grid.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when IDOfPrototypeToConstructGridFrom 
            is invalid.
            </exception>
            <exception cref="T:UnityEngine.MissingComponentException">
            Thrown when persistentDataToSetStateFrom is not null and contains a World that should exist but does not anymore.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the Component Manager has been fully initialized.
            </exception>
            <displayName id="CreateNonPersistentActiveGridUsingTransform">
            CreateNonPersistentActiveGridUsingTransform(int, [World], [Transform], [PlayerMover]])
            </displayName>
            <syntax>
            public ActiveGrid CreateNonPersistentActiveGridUsingTransform(int IDOfPrototypeToConstructGridFrom, World alternateWorldToSyncTo = null, Transform alternatePlayerToAssociateWithGrid = null, PlayerMover playerMoverToAssociateWithGrid = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.CreateNonPersistentActiveGridUsingIPlayer(System.Int32,DeepSpaceLabs.SAM.World,DeepSpaceLabs.SAM.IPlayer,DeepSpaceLabs.SAM.PlayerMover)">
            <summary>
            Creates and initializes a non-persistent Active Grid based on the prototype 
            and the specified optional parameters.
            The grid data will not be saved with the component manager's save data.
            <para>
            When the Active Grid is initialized, the World the grid is 
            synced to will also be initialized, as well as this Component Manager if it has not 
            already been initialized.
            </para>
            <para>
            Note, however, that you will need to manually enable World Updating on the Active Grid via the 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean)" href="ActiveGrid.html#TrySetIfWorldShouldBeUpdated1">
            TrySetIfWorldShouldBeUpdated
            </see> 
            or 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(System.Boolean)" href="ActiveGrid.html#TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate1">
            TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate
            </see> method. With World Updating disabled (the default state if one of those methods are not called), 
            the Active Grid will not trigger the World to load/unload objects!
            </para>
            </summary>
            <param name="IDOfPrototypeToConstructGridFrom" type="int">
            The prototype to construct the grid from (number shown in inspector).
            </param>
            <param name="alternateWorldToSyncTo" type="World" link="World.html">
            An alternate world for the grid to start synced to. This world can be either persistent or non persistent.
            </param>
            <param name="alternatePlayerToAssociateWithGrid" type="IPlayer" link="IPlayer.html">
            If provided, the grid will use this IPlayer to create as the Player upon initialization, 
            otherwise the grid will be associated with the default Player of the 
            prototype (determined by Player Type). If a IPlayer is not passed in and no player is assigned 
            via the prototype's inspector, an exception will be thrown.
            </param>
            <param name="playerMoverToAssociateWithGrid" type="PlayerMover" link="PlayerMover.html">
            If provided, the grid will use this PlayerMover when moving the Player. 
            If alternatePlayerToAssociateWithGrid is set and playerMoverToAssociateWithGrid is null, 
            the Active Grid will not use the default PlayerMover of the prototype. 
            Instead, the player mover will be set to null and the Player will be moved by setting 
            its Position property. Therefore, you must be sure to provide a valid object for this argument
            if you provide an alternate player and want to make use of PlayerMover.
            </param>
            <returns type="ActiveGrid" link="ActiveGrid.html">
            The created and initialized non persistent Active Grid.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when IDOfPrototypeToConstructGridFrom  
            is invalid.
            </exception>
            <exception cref="T:UnityEngine.MissingComponentException">
            Thrown when persistentDataToSetStateFrom is not null and contains a World that should exist but does not anymore.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the Component Manager has been fully initialized.
            </exception>
            <displayName id="CreateNonPersistentActiveGridUsingIPlayer">
            CreateNonPersistentActiveGridUsingIPlayer(int, [World], [IPlayer], [PlayerMover]])
            </displayName>
            <syntax>
            public ActiveGrid CreateNonPersistentActiveGridUsingIPlayer(int IDOfPrototypeToConstructGridFrom, World alternateWorldToSyncTo = null, IPlayer alternatePlayerToAssociateWithGrid = null, PlayerMover playerMoverToAssociateWithGrid = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.CreatePersistentActiveGrid(System.Int32,DeepSpaceLabs.SAM.World)">
            <summary>
            Creates and initializes a persistent Active Grid based on the prototype 
            and the specified optional parameters.
            The persistent grid data will be saved with the component manager's save data, and 
            can only be synced with persistenet worlds.
            <para>
            When the Active Grid is initialized, the World the grid is 
            synced to will also be initialized, as well as this Component Manager if it has not 
            already been initialized.
            </para>
            <para>
            Note, however, that you will need to manually enable World Updating on the Active Grid via the 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdated(System.Boolean)" href="ActiveGrid.html#TrySetIfWorldShouldBeUpdated1">
            TrySetIfWorldShouldBeUpdated
            </see> 
            or 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate(System.Boolean)" href="ActiveGrid.html#TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate1">
            TrySetIfWorldShouldBeUpdatedThenWaitForWorldUpdate
            </see> method. With World Updating disabled, the Active Grid will not trigger the World to load/unload objects!
            </para>
            <para>
            Notice that unlike with non persisten Active Grids, there is no option to provide an alternate 
            player or player mover. This is because there is no way to save the alternate player and player mover 
            with the grid's persistent data, therefore persistent grids are limited to having to use the player 
            assigned to the prototype!
            </para>
            </summary>
            <param name="IDOfPrototypeToConstructGridFrom" type="int">
            The ID of the Prototype to use to construct the Runtime Active Grid. Remember, all Active Grid Prototypes in use in the current scene must have unique IDs. Because this Active Grid is 
            Persistent, it will be saved with persistent data and reconstructed when the Load method is called. The ID of the Prototype is saved with the data, and as such, this ID 
            must remain the same, or the data will be discarded.
            </param>
            <param name="alternatePersistentWorldToSyncTo" type="World" link="World.html">
            An alternate world for the grid to start synced to. This must be a persistent world.
            </param>
            <returns type="ActiveGrid" link="ActiveGrid.html">
            The created and initialized persistent Active Grid.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when prototypeToConstructGridFrom 
            is invalid. Valid values range from 1 to [number of prototypes].
            </exception>
            <exception cref="T:UnityEngine.MissingComponentException">
            Thrown when persistentDataToSetStateFrom is not null and contains a World that should exist but does not anymore.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPersistenceException" link="InvalidPersistenceException.html">
            Thrown when alternatePersistentWorldToSyncTo not null and is not a persistent World.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the Component Manager has been fully initialized.
            </exception>
            <displayName id="CreatePersistentActiveGrid">
            CreatePersistentActiveGrid(int, [World])
            </displayName>
            <syntax>
            ActiveGrid CreatePersistentActiveGrid(int IDOfPrototypeToConstructGridFrom, World alternatePersistentWorldToSyncTo = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.TryGetActiveGridByID(System.Int32,DeepSpaceLabs.SAM.ActiveGrid@)">
            <summary>
            Tries to get the <see href = "ActiveGrid.html">Active Grid</see> specified by ID. 
            </summary>
            <param name="ID" type="int">The ID of the Active Grid to get.</param>
            <param name="activeGrid" type="ActiveGrid" link="ActiveGrid.html">When this method returns, contains the
            value associated with the specified ID if the ID is found; otherwise, null.</param>
            <returns type = "bool">A bool indicating whether the ActiveGrid was found.</returns>
            <displayName id="TryGetActiveGridByID">TryGetActiveGridByID(int, out ActiveGrid)</displayName>
            <syntax>public bool TryGetActiveGridByID(int ID, out ActiveGrid activeGrid)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.DestroyActiveGrid(System.Int32)">
            <summary>
            Destroys the Active Grid with IDOfActiveGridToDestroy. All cell users associated with the Active Grid are removed from cells on the World the Active Grid
            is Currently synced to. If those cells have no more cell users after this removal, the cell chunks are removed from the scene.
            <para>This removal is performed over a series of frames for performance reasons, however this method destroys the Active Grid immediately and does not wait
            for the cell users (and associated cell chunks) to be removed from the world. If you need to wait for this process to complete (perhaps you only want to perform
            some action after the cell users/asset chunks have been removed), use <see cref ="M:DeepSpaceLabs.SAM.ComponentManager.DestroyActiveGridAndWaitForCellUsersToBeRemoved(System.Int32)" href = "#DestroyActiveGridAndWaitForCellUsersToBeRemoved">DestroyActiveGridAndWaitForCellUsersToBeRemoved</see> instead.</para>
            </summary>
            <param name="IDOfActiveGridToDestroy" type = "int">The ID of the Active Grid to destroy.</param>
            <example>
            <code>
            class DestroyActiveGridExample
            {
                ActiveGrid myActiveGrid;
                
                public void OnDestroyActiveGrid()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    componentManager.DestroyActiveGrid(myActiveGrid.ID);
                }
            }
            </code>
            </example>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfActiveGridToDestroy is not the ID of a valid Active Grid in the scene.
            </exception>
            <displayName id="DestroyActiveGrid">DestroyActiveGrid(int)</displayName>
            <syntax>public void DestroyActiveGrid(int IDOfActiveGridToDestroy)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.DestroyActiveGridAndWaitForCellUsersToBeRemoved(System.Int32)">
            <summary>
            Destroys the <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see> with IDOfActiveGridToDestroy. 
            All cell users associated with the Active Grid are removed from the cells on the World the Active Grid
            is Currently synced to. If those cells have no more cell users after this removal, the cell chunks are removed from the scene.
            <para>This removal is performed over a series of frames for performance reasons, and the Active Grid will only be destroyed after this removal
            process completes. This method should be used if you need to know when the cell users/objects are removed and want to wait for the process to complete.
            Use like any other coroutine.</para>
            </summary>
            <param name="IDOfActiveGridToDestroy" type = "int">The ID of the Active Grid to destroy.</param>
            <example>Normal StartCoroutine Example
            <code>
            class DestroyActiveGridExample
            {
                ActiveGrid myActiveGrid;
                
                //This method should have been called via StartCoroutine
                public IEnumerator OnDestroyActiveGrid()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    yield return StartCoroutine(componentManager.DestroyActiveGridAndWaitForCellUsersToBeRemoved(myActiveGrid.ID));
                }
            }
            </code>
            </example>
            <example>Coroutine without using StartCoroutine
            <code>
            class DestroyActiveGridExample
            {
                ActiveGrid myActiveGrid;
                
                //This method should be started using StartCoroutine or iterated over manually in another coroutine
                public IEnumerator&lt;YieldInstruction&gt; OnDestroyActiveGrid()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    IEnumerator&lt;YieldInstruction&gt; e = componentManager.DestroyActiveGridAndWaitForCellUsersToBeRemoved(myActiveGrid.ID);
                    while(e.MoveNext())
                        yield return e.Current;
                }
            }
            </code>
            </example>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfActiveGridToDestroy is not the ID of a valid Active Grid in the scene.
            </exception>
            <displayName id="DestroyActiveGridAndWaitForCellUsersToBeRemoved">DestroyActiveGridAndWaitForCellUsersToBeRemoved(int)</displayName>
            <syntax>public IEnumerator&lt;YieldInstruction&gt; DestroyActiveGridAndWaitForCellUsersToBeRemoved(int IDOfActiveGridToDestroy)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.ActiveGridsInScene">
            <summary>
            Can be used to iterate over the collection of ActiveGrids in the scene in a garbage free manner.
            </summary>
            <returns type="Dictionary&lt;int, ActiveGrid&gt;.ValueCollection">
            Internally the Active Grids in the scene are stored in a dictionary, with the Active Grids as values. This returns those values, which you 
            can iterate over using a foreach statement.
            </returns>
            <displayName id="ActiveGridsInScene">
            ActiveGridsInScene()
            </displayName>
            <syntax>
            public Dictionary&lt;int, ActiveGrid&gt;.ValueCollection ActiveGridsInScene()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.CreatePersistentWorld(System.Int32,System.String[][][],System.Nullable{UnityEngine.Vector3},System.Nullable{DeepSpaceLabs.SAM.Cell},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.String})">
            <summary>
            Creates and initializes a persistent World using the information from the 
            prototype and optional parameters.
            The persistent world will be saved with the component manager's save data, 
            and both persistent and non persistent Active Grids can sync to it. Calling this method will 
            initialize this Component Manager if it has not already been initialized.
            </summary>
            <param name="IDOfPrototypeToConstructWorldFrom" type="int">
            The ID of the Prototype to use to construct the Runtime World. Remember, all World Prototypes in use in the current scene must have unique IDs. Because this World is 
            Persistent, it will be saved with persistent data and reconstructed when the Load method is called. The ID of the Prototype is saved with the data, and as such, this ID 
            must remain the same, or the data will be discarded.
            </param>
            <param name="alternateGroupNamesToUse" type="string[][][]">
            A 3D array of alternate group names that each LOD of each World Grouping on each Zone of the world should start with. 
            The group names controls which asset chunks are loaded by the world. If a particular index is null,
            the Group Name from the save data will be used for it. If the save data is null, the default Group Name 
            from the Streamable Grid on the prototype will be used.
            <para>
            The first dimension of the array represents the zones on the World. The length of this array must be set to however many Zones your World contains. 
            If you don't need to set the Group Names for a particular Zone, you can set the first index to null, like this: alternateGroupNamesToUse[zoneIndex] = null;
            </para>
            <para>
            The second dimension represents the World Grouping for a particular zone, for example alternateGroupNamesToUse[0][0] represents the Zone 1, Grouping 1. 
            If you only need need to modify the LOD Groups for some but not all World Groupings for a zone, you can set this index to null, like so: 
            alternateGroupNamesToUse[zoneIndex][groupingIndex] = null. If you need to set at least one Zone Grouping in a Zone, you need to 
            initialize this array to the full length (as many World Groupings as there are on the World), even if 
            you don't need to modify all Zone Groupings on that Zone.
            </para>
            <para>
            The third and final dimension represents each LOD Group for each Zone Grouping. You can set an index to null if that LOD Group Name does not 
            need to be modified (alternateGroupNamesToUse[zoneIndex][groupingIndex][lodIndex] = null. 
            If you need to set at least one LOD Group in a Zone Grouping, you need to 
            initialize this array to the full length (as many LOD Groups as there are on the Streamable Grid associated with the Zone Grouping), even if 
            you don't need to modify all LOD Group names on that Zone Grouping.
            </para>
            </param>
            <param name="alternateWorldOrigin" type="Vector3">
            An alternate world origin for the created World to use. If null, the world origin from the save data will be used. If the 
            save data is null, the prototypes world origin will be used.
            </param>
            <param name="alternateOriginCell" type="Cell" link="Cell.html">
            An alternate Origin Cell for the created World to use. If null, the Origin Cell specified in the save data will be used.
            If the save data is null, the Origin Cell from the prototype is used.
            <para>
            Note, this Origin Cell is 1 based, i.e., the bottom left most cell of the world has an index of row = 1, column = 1, and 
            layer = 1 (for 3D worlds). The Origin Cell in the save data, on the other hand, is 0 based.
            </para>
            </param>
            <param name="worldRegionNumbersToAutoLoad" type="List&lt;int&gt;">
            A list of valid World Region Numbers (as shown in the prototypes inspector) that you would like to be auto loaded. This is in addition to any World Regions that 
            have Auto Load enabled in the prototype inspector, and any World Regions indicated by worldRegionNamesToAutoLoad.
            </param>
            <param name="worldRegionNamesToAutoLoad" type="List&lt;string&gt;">
            A list of valid World Region Names (as shown in the prototypes inspector) that you would like to be auto loaded. This is in addition to any World Regions that 
            have Auto Load enabled in the prototype inspector, and any World Regions indicated by worldRegionNumbersToAutoLoad.
            </param>
            <returns type="World" link="World.html">
            The created and initialized persistent World.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when IDOfPrototypeToConstructWorldFrom 
            is invalid.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the Component Manager has been fully initialized.
            </exception>
            <displayName id="CreatePersistentWorld">CreatePersistentWorld(int, [string[][][]], [Vector3?], [Cell?], [List&lt;int&gt;], [List&lt;string&gt;])</displayName>
            <syntax>public World CreatePersistentWorld(int IDOfPrototypeToConstructWorldFrom, string[][][] alternateGroupNamesToUse = null, Vector3? alternateWorldOrigin = null, Cell? alternateOriginCell = null, List&lt;int&gt; worldRegionNumbersToAutoLoad = null, List&lt;string&gt; worldRegionNamesToAutoLoad = null)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.CreateNonPersistentWorld(System.Int32,System.String[][][],System.Nullable{UnityEngine.Vector3},System.Nullable{DeepSpaceLabs.SAM.Cell},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.String})">
            <summary>
            Creates and initializes a non persistent World using the information from 
            the prototype and optional parameters.
            The non persistent world will be saved with the component manager's save data, 
            but only non persistent Active Grid's  will be able to sync to it. Calling this method will 
            initialize this Component Manager if it has not already been initialized.
            </summary>
            <param name="IDOfPrototypeToConstructWorldFrom" type="int">
            The ID of the Prototype to use to construct the Runtime World. Remember, all World Prototypes in use in the current scene must have unique IDs.
            </param>
            <param name="alternateGroupNamesToUse" type="string[][][]">
            A 3D array of alternate group names that each LOD of each World Grouping on each Zone of the world should start with. 
            The group names controls which asset chunks are loaded by the world. If a particular index is null,
            the Group Name from the save data will be used for it. If the save data is null, the default Group Name 
            from the Streamable Grid on the prototype will be used.
            <para>
            The first dimension of the array represents the zones on the World. The length of this array must be set to however many Zones your World contains. 
            If you don't need to set the Group Names for a particular Zone, you can set the first index to null, like this: alternateGroupNamesToUse[zoneIndex] = null;
            </para>
            <para>
            The second dimension represents the World Grouping for a particular zone, for example alternateGroupNamesToUse[0][0] represents the Zone 1, Grouping 1. 
            If you only need need to modify the LOD Groups for some but not all World Groupings for a zone, you can set this index to null, like so: 
            alternateGroupNamesToUse[zoneIndex][groupingIndex] = null. If you need to set at least one Zone Grouping in a Zone, you need to 
            initialize this array to the full length (as many World Groupings as there are on the World), even if 
            you don't need to modify all Zone Groupings on that Zone.
            </para>
            <para>
            The third and final dimension represents each LOD Group for each Zone Grouping. You can set an index to null if that LOD Group Name does not 
            need to be modified (alternateGroupNamesToUse[zoneIndex][groupingIndex][lodIndex] = null. 
            If you need to set at least one LOD Group in a Zone Grouping, you need to 
            initialize this array to the full length (as many LOD Groups as there are on the Streamable Grid associated with the Zone Grouping), even if 
            you don't need to modify all LOD Group names on that Zone Grouping.
            </para>
            </param>
            <param name="alternateWorldOrigin" type="Vector3">
            An alternate world origin for the created World to use. If null, the world origin from the save data will be used. If  
            save data is not present, the prototypes world origin will be used.
            </param>
            <param name="alternateOriginCell" type="Cell" link="Cell.html">
            An alternate Origin Cell for the created World to use. If null, the Origin Cell specified in the save data will be used.
            If the save data is null, the Origin Cell from the prototype is used.
            <para>
            Note, this Origin Cell is 1 based, i.e., the bottom left most cell of the world has an index of row = 1, column = 1, and 
            layer = 1 (for 3D worlds). The Origin Cell in the save data, on the other hand, is 0 based.
            </para>
            </param>
            <param name="worldRegionNumbersToAutoLoad" type="List&lt;int&gt;">
            A list of valid World Region Numbers (as shown in the prototypes inspector) that you would like to be auto loaded. This is in addition to any World Regions that 
            have Auto Load enabled in the prototype inspector, and any World Regions indicated by worldRegionNamesToAutoLoad.
            </param>
            <param name="worldRegionNamesToAutoLoad" type="List&lt;string&gt;">
            A list of valid World Region Names (as shown in the prototypes inspector) that you would like to be auto loaded. This is in addition to any World Regions that 
            have Auto Load enabled in the prototype inspector, and any World Regions indicated by worldRegionNumbersToAutoLoad.
            </param>
            <returns type="World" link="World.html">
            The created and initialized non persistent World.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidPrototypeException" link ="InvalidPrototypeException.html">
            Thrown when IDOfPrototypeToConstructWorldFrom 
            is invalid.
            </exception>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the Component Manager has been fully initialized.
            </exception>
            <displayName id="CreateNonPersistentWorld">
            CreateNonPersistentWorld(int, [string[][][]], [Vector3?], [Cell?], [List&lt;int&gt;], [List&lt;string&gt;])
            </displayName>
            <syntax>public World CreateNonPersistentWorld(int IDOfPrototypeToConstructWorldFrom, string[][][] alternateGroupNamesToUse = null, Vector3? alternateWorldOrigin = null, Cell? alternateOriginCell = null, List&lt;int&gt; worldRegionNumbersToAutoLoad = null, List&lt;string&gt; worldRegionNamesToAutoLoad = null)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.TryGetWorldByID(System.Int32,DeepSpaceLabs.SAM.World@)">
            <summary>
            Tries to get the <see cref = "T:DeepSpaceLabs.SAM.World" href = "World.html">World</see> specified by worldID. 
            </summary>
            <param name="worldID" type ="int">The ID of the World to get.</param>
            <param name="world" type = "World" link = "World.html">When this method returns, contains the
            value associated with the specified worldID if the worldID is found; otherwise, null.</param>
            <returns type = "bool">A bool indicating whether the World was found.</returns>
            <displayName id="TryGetWorldByID">TryGetWorldByID(int, World)</displayName>
            <syntax>public bool TryGetWorldByID(int worldID, out World world)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.DestroyWorld(System.Int32)">
            <summary>
            Destroys the World with IDofWorldToDestroy. All World Cells and Asset Chunks associated with the World are removed from the scene.
            <para>
            This removal is performed over a series of frames for performance reasons, 
            though the World's destruction will be reflected 
            in the persistent data if you save during the process. 
            </para>
            <para>
            If you care about when the removal process completes (and thus when the
            World is actually destroyed) use DestroyWorldAndWaitForChunksToBeRemoved instead 
            and provide a callback method.
            </para>
            </summary>
            <param name="IDOfWorldToDestroy" type="int">The ID of the World to destroy.</param>
            <example>
            <code>
            class DestroyWorldExample
            {
                World myWorld;
                
                public void OnDestroyWorld()
                {
                    //You should only have one component manager in the scene
                    ComponentManager componentManager = GameObject.FindObjectOfType&lt;ComponentManager&gt;();
                    
                    componentManager.DestroyWorld(myWorld.ID);
                }
            }
            </code>
            </example>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfWorldToDestroy is not the ID of a valid World in the scene.
            </exception>
            <displayName id="DestroyWorld">DestroyWorld(int)</displayName>
            <syntax>public void DestroyWorld(int IDOfWorldToDestroy)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.DestroyWorldAndWaitForChunksToBeRemoved(System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            This method is virtually the same as <see cref="M:DeepSpaceLabs.SAM.ComponentManager.DestroyWorld(System.Int32)" href="#DestroyWorld">DestroyWorld</see>, except with this method you 
            can pass in a System.Action which will be called just before the World has been destroyed (but after all 
            World Cells and Asset Chunks associated with the World have been removed from the scene). Note that the World argument that is 
            passed into your Action will be valid for only the frame that the action is called, because the actual 
            World object is destroyed just after the action completes.
            </summary>
            <param name="IDOfWorldToDestroy" type="int">
            The ID of the World to destroy.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            A callback action which will be called just before the World is destroyed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InvalidIDException" link="InvalidIDException.html">
            Thrown when IDOfWorldToDestroy is not the ID of a valid World in the scene.
            </exception>
            <displayName id="DestroyWorldAndWaitForChunksToBeRemoved">
            DestroyWorldAndWaitForChunksToBeRemoved(int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; DestroyWorldAndWaitForChunksToBeRemoved(int IDOfWorldToDestroy, Action&lt;World&gt; onCompletedCallback)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.WorldsInScene">
            <summary>
            Can be used to iterate over the collection of Worlds in the scene in a garbage free manner.
            </summary>
            <returns type="Dictionary&lt;int, World&gt;.ValueCollection">
            Internally the Worlds in the scene are stored in a dictionary, with the Worlds as values. This returns those values, which you 
            can iterate over using a foreach statement.
            </returns>
            <displayName id="WorldsInScene">
            WorldsInScene()
            </displayName>
            <syntax>
            public Dictionary&lt;int, World&gt;.ValueCollection WorldsInScene()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.Save_EventUsable(UnityEngine.MonoBehaviour)">
            <summary>
            Like the <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Save(DeepSpaceLabs.SAM.IPersistentStateManager)" href="#Save">Save</see> method, however this method can be "hooked up" to a Unity Event via the inspector.
            <para>
            Saves this component manager data, including the data of all persistent 
            Active Grids and Worlds in the scene in a single frame.
            </para>
            <para>
            While the Component Manager chooses which data is saved, the actual mechanism for saving is under the control of whatever MonoBehaviour you 
            pass into this method, however note that the MonoBehaviour you pass in must implement the 
            <see cref="T:DeepSpaceLabs.SAM.IPersistentStateManager" href="IPersistentStateManager.html">IPersistentStateManager</see> interface or else an exception will be thrown.
            </para>
            <para>
            It should go without saying, but this method can only be called after the Component Manager has been initialized.
            </para>
            </summary>
            <param name="persistentStateManager" type="MonoBehaviour">
            The persistent state manager to use to save the data. Must implement the IPersistentStateManager interface.
            </param>
            <displayName id="Save_EventUsable"
            >Save_EventUsable(MonoBehaviour)
            </displayName>
            <syntax>
            public void Save_EventUsable(MonoBehaviour persistentStateManager)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown when called before the Component Manager has been initialized.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when this method is called and persistentStateManager does not implement the IPersistentStateManager interface.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.Save(DeepSpaceLabs.SAM.IPersistentStateManager)">
            <summary>
            Saves this component manager data, including the data of all persistent 
            Active Grids and Worlds in the scene in a single frame.
            <para>
            While the Component Manager chooses which data is saved, the actual mechanism for saving is under the control of whatever 
            <see cref="T:DeepSpaceLabs.SAM.IPersistentStateManager" href="IPersistentStateManager.html">Persistent State Manager</see> 
            you pass into this method.
            </para>
            <para>
            It should go without saying, but this method can only be called after the Component Manager has been initialized.
            </para>
            </summary>
            <param name="persistentStateManager" type="IPersistentStateManager" href="IPersistentStateManager.html">
            The persistent state manager to use to save the data.
            </param>
            <displayName id="Save"
            >Save(IPersistentStateManager)
            </displayName>
            <syntax>
            public void Save(IPersistentStateManager persistentStateManager)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown when called before the Component Manager has been initialized.
            </exception>
            <exception cref="T:System.ArgumentNullException">
            Thrown when this method is called and persistentStateManager is null.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.SubscribeToCellPlayerIsInChangedEvents(DeepSpaceLabs.SAM.World,System.Int32,System.Action{System.Object,DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs})">
            <summary>
            Subscribe to Cell Player Is In Changed Events, which is an event Active Grid's fire when the cell the player is in changes. Always make sure you call 
            UnsubscribeFromCellPlayerIsInChangedEvents at a later time when using this method! Usually, it's best to put the Subscribe in OnEnable and Unsubscribe in 
            OnDisable.
            <para>
            While you can subscribe to this event directly via an Active Grid, doing so here is typically much easier as you can specify a World and/or 
            World Grouping to listen to, and then have access to the events from all Active Grids that are synced to that World and/or Grouping.
            </para>
            </summary>
            <param name="filterWorld" type="World" link="World.html">
            A World you can use to filter out events. Notification of an event will only occur when an Active Grid firing the event is synced to this World. If you 
            provide a filterWorld but no filterWorldGrouping, then you will receive notification for all World Groupings firing the event. If you do not provide a 
            filterWorld (passing in null), then you will receive notification for all Active Grids firing the event, for the World Groupings not 
            filtered out via filterGridLayer.
            </param>
            <param name="filterWorldGrouping" type="int">
            The World Grouping to use to filter events. If a valid value is provided (1 or greater), the subscriber will only be notified of events that occur on this 
            World Grouping (and only for the filterWorld if provided). An invalid value (0 or less) will be interpreted as the subscriber wanting to be notified of 
            events on all World Groupings. For instance, if you want to receive notification about every event on every Active Grid and World Grouping, pass in null for 
            filterWorld and 0 for filterGridLayer. If you want to receive notifications about all events on all World Groupings for any Active Grids synced to a 
            specific World, provide a filterWorld but pass in 0 for filterGridLayer. If you want to be notified of events on World Grouping 1 for any Active Grid, 
            pass in null for filterWorld and 1 for filterGridLayer.
            <para>
            If you want to be notified of events from 1 or more World Groupings (but not all), you can call this method multiple times, once per each World Grouping.
            </para>
            </param>
            <param name="methodToSubscribe" type="Action&lt;object, CellPlayerIsInChangedEventArgs&gt;">
            The method that will be called when an event from the correct Active Grid and World Grouping is triggered.
            </param>
            <displayName id="SubscribeToCellPlayerIsInChangedEvents">
            SubscribeToCellPlayerIsInChangedEvents(World, int, Action&lt;object, CellPlayerIsInChangedEventArgs&gt;)
            </displayName>
            <syntax>
            public void SubscribeToCellPlayerIsInChangedEvents(World filterWorld, int filterWorldGrouping, Action&lt;object, CellPlayerIsInChangedEventArgs&gt; methodToSubscribe)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.UnsubscribeToCellPlayerIsInChangedEvents(DeepSpaceLabs.SAM.World,System.Int32,System.Action{System.Object,DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs})">
            <summary>
            Unsubscribe from Cell Player Is In Changed Events, which is an event Active Grid's fire when the cell the player is in changes. This method should be 
            paired with a previous call to SubscribeFromCellPlayerIsInChangedEvents! Usually, it's best to put the Subscribe in OnEnable and Unsubscribe in 
            OnDisable.
            </summary>
            <param name="filterWorld" type="World" link="World.html">
            The World you provided (or null if you passed in null) when you called SubscribeFromCellPlayerIsInChangedEvents.
            </param>
            <param name="filterWorldGrouping" type="int">
            The filterWorldGrouping you provided when you called SubscribeFromCellPlayerIsInChangedEvents.
            </param>
            <param name="methodToUnsubscribe" type="Action&lt;object, CellPlayerIsInChangedEventArgs&gt;">
            The method that was provided when you called SubscribeFromCellPlayerIsInChangedEvents.
            </param>
            <displayName id="UnsubscribeToCellPlayerIsInChangedEvents">
            UnsubscribeToCellPlayerIsInChangedEvents(World, int, Action&lt;object, CellPlayerIsInChangedEventArgs&gt;)
            </displayName>
            <syntax>
            public void UnsubscribeToCellPlayerIsInChangedEvents(World filterWorld, int filterWorldGrouping, Action&lt;object, CellPlayerIsInChangedEventArgs&gt; methodToUnsubscribe)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ComponentManager.DestroyActiveGridsAndWorldsAndUnloadWorldCells">
            <summary>
            Can be used to destroy every initialized Active Grid and World in the scene. Before doing so, all World Cells associated with the Active Grids and 
            Worlds are removed from the scene. This is useful for removing scene assets that have been loaded and kept in the scene, 
            specifically when your Scene Chunk Streamer has the 'Keep Scenes Intact' option enabled.
            <para>
            When that option is enabled, the loaded scenes that 
            contain Streamable Asset Chunks are kept in the scene, and these scenes will not be removed automatically when the scene containing the Component 
            Manager and other Streamable Assets Manager game objects is unloaded. In these circumstances, it is necessary to manually remove the 
            scene assets prior to unloading the main scene that contains the Component Manager and other game objects. You can use this method for that purpose.
            </para>
            <para>
            Once this method is called, you should not interact with any Streamable Assets Manager objects, including this Component Manager. Therefore, if you wish 
            to save data, you should do so before calling this method. The only correct use of this method is to call it, wait for it to complete, and then 
            unload the main containing the Component Manager and other SAM game objects.
            </para>
            </summary>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="DestroyActiveGridsAndWorldsAndUnloadWorldCells">
            DestroyActiveGridsAndWorldsAndUnloadWorldCells()
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; DestroyActiveGridsAndWorldsAndUnloadWorldCells()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SingletonEqualityComparer`2">
            <summary>
            All Equality Comparers used by the kit are derived from this class. Equality Comparers do not store data, therefore to save on 
            unecessary objects being created, you can utilize a singleton for all kit comparers, rather than initializing a new object whenever 
            a comparer is needed.
            <para>
            If you wish to create a new equality comparer that can be used like a singleton, keep in mind that the generic type parameter T is 
            the type that the comparer compares, while U is the Type of your comparer class implementation. Check out the other Comparers to see how the 
            class definition is setup.
            </para>
            </summary>
            <title>
            SingletonEqualityComparer Class
            </title>
            <category>Equality Comparers</category>
            <navigationName>
            SingletonEqualityComparer
            </navigationName>
            <fileName>SingletonEqualityComparer.html</fileName>
            <syntax>
            public abstract class SingletonEqualityComparer&lt;T, U&gt; : EqualityComparer&lt;T&gt; where U : class, new()
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SingletonEqualityComparer`2.Instance">
            <summary>
            Returns the singleton instance of the equality comparer.
            </summary>
            <type>U</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TwoDimensionalCellComparer">
            <summary>
            An equality comparer for a Cell structure that treats the cells as two dimensional (ignoring the layer field on the cells).
            <para>
            It is recommended to use this comparer rather than the Cell's built in equality and GetHashCode methods if your cell is 2D, 
            as the built in methods treat the cell as a 3D cell. You may also wish to use this when you don't know whether the cells will 
            be 2D or 3D ahead of time. In this case, you can use the base EqualityComparer&lt;Cell&gt; for your type, and instantiate a 
            2D or 3D equality comparare at runtime depending on your cell type (which will typically depend on the Axes uses by your Streamable Grid).
            </para>
            </summary>
            <title>
            TwoDimensionalCellComparer Class
            </title>
            <category>Equality Comparers</category>
            <navigationName>
            TwoDimensionalCellComparer
            </navigationName>
            <fileName>TwoDimensionalCellComparer.html</fileName>
            <syntax>
            public sealed class TwoDimensionalCellComparer : SingletonEqualityComparer&lt;Cell, TwoDimensionalCellComparer&gt;
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TwoDimensionalCellComparer.Equals(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            Determines whether two 2D cells are equal (layer field is ignored)
            </summary>
            <param name="cell1" type="Cell" link="Cell.html">
            The first cell.
            </param>
            <param name="cell2" type="Cell" link="Cell.html">
            The second cell.
            </param>
            <returns type="bool">
            True of the two cells are equal, false if they are not. The layer field is ignored for the comparison
            </returns>
            <displayName id="Equals">
            Equals(Cell, Cell)
            </displayName>
            <syntax>
            public override bool Equals(Cell cell1, Cell cell2)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TwoDimensionalCellComparer.GetHashCode(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Calculates a hash code using the row and column fields of the cell.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">
            The cell who's hash code you wish to get.
            </param>
            <returns type="int">
            The hash code of the cell.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode(Cell)
            </displayName>
            <syntax>
            public override int GetHashCode(Cell cell))
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ThreeDimensionalCellComparer">
            <summary>
            An equality comparer for a Cell structure that treats the cells as three dimensional (using the layer field on the cells).
            <para>
            The built in equality and GetHashCode methods on the Cell structure already use the layer field, so it may not be becessary for you to 
            use this class. However, you may wish to use this when you don't know whether the cells will 
            be 2D or 3D ahead of time. In this case, you can use the base EqualityComparer&lt;Cell&gt; for your type, and instantiate a 
            2D or 3D equality comparare at runtime depending on your cell type (which will typically depend on the Axes uses by your Streamable Grid).
            </para>
            </summary>
            <title>
            ThreeDimensionalCellComparer Class
            </title>
            <category>Equality Comparers</category>
            <navigationName>
            ThreeDimensionalCellComparer
            </navigationName>
            <fileName>ThreeDimensionalCellComparer.html</fileName>
            <syntax>
            public sealed class ThreeDimensionalCellComparer :  SingletonEqualityComparer&lt;Cell, ThreeDimensionalCellComparer&gt;
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ThreeDimensionalCellComparer.Equals(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            Determines whether two 3D cells are equal.
            </summary>
            <param name="cell1" type="Cell" link="Cell.html">
            The first cell.
            </param>
            <param name="cell2" type="Cell" link="Cell.html">
            The second cell.
            </param>
            <returns type="bool">
            True of the two cells are equal, false if they are not.
            </returns>
            <displayName id="Equals">
            Equals(Cell, Cell)
            </displayName>
            <syntax>
            public override bool Equals(Cell cell1, Cell cell2)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ThreeDimensionalCellComparer.GetHashCode(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Calculates a hash code using the row, column and layer fields of the cell.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">
            The cell who's hash code you wish to get.
            </param>
            <returns type="int">
            The hash code of the cell.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode(Cell)
            </displayName>
            <syntax>
            public override int GetHashCode(Cell cell))
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TwoDimensionalChunkCellComparer">
            <summary>
            An equality comparer for a ChunkCell structure that treats the cells as two dimensional (ignoring the layer field on the cells Cell property).
            <para>
            It is recommended to use this comparer rather than the Chunk Cell's built in equality and GetHashCode methods if your cell is 2D, 
            as the built in methods treat the cell as a 3D cell. You may also wish to use this when you don't know whether the cells will 
            be 2D or 3D ahead of time. In this case, you can use the base EqualityComparer&lt;ChunkCell&gt; for your type, and instantiate a 
            2D or 3D equality comparare at runtime depending on your cell type (which will typically depend on the Axes uses by your Streamable Grid).
            </para>
            </summary>
            <title>
            TwoDimensionalChunkCellComparer Class
            </title>
            <category>Equality Comparers</category>
            <navigationName>
            TwoDimensionalChunkCellComparer
            </navigationName>
            <fileName>TwoDimensionalChunkCellComparer.html</fileName>
            <syntax>
            public class TwoDimensionalChunkCellComparer :  SingletonEqualityComparer&lt;ChunkCell, TwoDimensionalChunkCellComparer&gt;
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TwoDimensionalChunkCellComparer.Equals(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            Determines whether two 2D chunk cells are equal (layer field of Cell is ignored)
            </summary>
            <param name="cell1" type="ChunkCell" link="ChunkCell.html">
            The first cell.
            </param>
            <param name="cell2" type="ChunkCell" link="ChunkCell.html">
            The second cell.
            </param>
            <returns type="bool">
            True of the two cells are equal, false if they are not. The layer field of Cell is ignored for the comparison.
            </returns>
            <displayName id="Equals">
            Equals(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public override bool Equals(ChunkCell cell1, ChunkCell cell2)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TwoDimensionalChunkCellComparer.GetHashCode(DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            Calculates a hash code using the ChunkIndex, Cell.Row and Cell.Column fields of the chunk cell.
            </summary>
            <param name="cell" type="ChunkCell" link="ChunkCell.html">
            The cell who's hash code you wish to get.
            </param>
            <returns type="int">
            The hash code of the cell.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode(ChunkCell)
            </displayName>
            <syntax>
            public override int GetHashCode(ChunkCell cell))
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ThreeDimensionalChunkCellComparer">
            <summary>
            An equality comparer for a ChunkCell structure that treats the cells as three dimensional (using the layer field from the Cell property).
            <para>
            The built in equality and GetHashCode methods on the ChunkCell structure already use the layer field, so it may not be becessary for you to 
            use this class. However, you may wish to use this when you don't know whether the cells will 
            be 2D or 3D ahead of time. In this case, you can use the base EqualityComparer&lt;ChunkCell&gt; for your type, and instantiate a 
            2D or 3D equality comparare at runtime depending on your cell type (which will typically depend on the Axes uses by your Streamable Grid).
            </para>
            </summary>
            <title>
            ThreeDimensionalChunkCellComparer Class
            </title>
            <category>Equality Comparers</category>
            <navigationName>
            ThreeDimensionalChunkCellComparer
            </navigationName>
            <fileName>ThreeDimensionalChunkCellComparer.html</fileName>
            <syntax>
            public sealed class ThreeDimensionalChunkCellComparer :  SingletonEqualityComparer&lt;ChunkCell, ThreeDimensionalChunkCellComparer&gt;
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ThreeDimensionalChunkCellComparer.Equals(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            Determines whether two 3D cells are equal.
            </summary>
            <param name="cell1" type="ChunkCell" link="ChunkCell.html">
            The first cell.
            </param>
            <param name="cell2" type="ChunkCell" link="ChunkCell.html">
            The second cell.
            </param>
            <returns type="bool">
            True of the two cells are equal, false if they are not.
            </returns>
            <displayName id="Equals">
            Equals(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public override bool Equals(ChunkCell cell1, ChunkCell cell2)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ThreeDimensionalChunkCellComparer.GetHashCode(DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            Calculates a hash code using the chunkIndex, row, column and layer fields of the cell.
            </summary>
            <param name="cell" type="ChunkCell" link="ChunkCell.html">
            The cell who's hash code you wish to get.
            </param>
            <returns type="int">
            The hash code of the cell.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode(ChunkCell)
            </displayName>
            <syntax>
            public override int GetHashCode(ChunkCell cell))
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.CellVisualTransitionController">
            <summary>
            Provides a base implementation for a Cell Visual Transition Controller.
            <para>
            A cell visual transition controller is responsible for controlling the visibility 
            of a cell as it is added to the scene, removed from the scene, or transitioned from one LOD to another. 
            For instance, you may wish to fade between different levels of detail to make the transition less apparent to the user, 
            or have an object rise up/down as it they are added or removed from the scene.
            </para>
            <para>
            Assuming the LOD the World Cells are coming from uses Chunks (either Terrain, Non Terrain Game Objects, or non Game Object based objects), 
            each World Cell in the list contains a chunk array with 
            references to the root chunk objects belonging to each cell (note, if not using multi chunking, this will just be a 
            array with a single chunk). 
            </para>
            <para>
            How you display the objects belonging to your World Cell's is up to you, though typically if using Game Objects, the objects 
            will contain a Renderer component that you can manipulate. You may have a single root object with no children, or the root objects 
            may have many children. It is up to you to correctly transition all objects that should be visible.
            </para>
            <para>
            Note that when Asset Chunks are stored in the Visible State, ImmediatelyTransitionToInvisibleState is called while the World Cell's the Asset Chunks 
            belong to are still Deactivated in order to ensure they are in the proper Invisible State before Activation. In the same respect, after World Cell's have 
            been Deactivated, ImmediatelyTransitionToVisibleState is called to place the Asset Chunks back in their starting Visible State, before sending them back to the 
            Chunk Manager. This ensures the state of reused Asset Chunks and newly loaded Asset Chunks remains consistent. As a result of this behaviour you should keep the 
            following points in mind:
            <para>
            1) Activating and/or Deactivating Asset Chunks within the Transition Controller method is generally a bad idea, as you may Activate an Asset Chunk that is not meant to be 
            Activated. If you must Activate/Deactivate Asset Chunks, you should check to see if they are 
            </para>
            </para>
            <para>
            Your chunk assets can either be stored (within your project hierarchy) in a visible or invisible visual state. Which option you choose 
            is up to you, however you need to set the LOD setting (on your Streamable Grid asset) called Visual State Of Stored Assets When Active to the 
            state you choose, and note the following:
            </para>
            <para>
            If stored in a visible state, SAM needs to perform an extra step before detaching assets from cells as well as after attaching 
            assets to cells. The former step is required to ensure assets passed to the Chunk Manager (which may be pooled) match 
            the state of assets loaded by your Chunk Streamers. The <see cref="M:DeepSpaceLabs.SAM.CellVisualTransitionController.ResetToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)" href="CellVisualTransitionController.html#ImmediatelyTransitionToVisibleState.html">ImmediatelyTransitionToVisibleState</see>method is used for this purpose. 
            The latter step is needed to make the assets invisible before being activated and before 
            the transition process begins. It does this by calling 
            <see cref="M:DeepSpaceLabs.SAM.CellVisualTransitionController.ResetToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)" href="CellVisualTransitionController.html#ImmediatelyTransitionToInvisibleState.html">ImmediatelyTransitionToInvisibleState</see>. Both methods 
            may incur a performance penalty. If you notice a performance issue related to this, you can eliminate it by 
            setting up your assets to be in an invisible state by default, and changing the setting on your Streamable Grid LOD to match. However, typically 
            there is no issue and leaving your assets in the visible visual state is recommended for editing purposes (especially when that editing 
            is done via the World Designer tool). Therefore, it is recommended to set your assets to the visual state, and only change them to the invisible 
            state if you notice performance issues.
            </para>
            <para>
            The nomenclature "visible" and "invisible" is used because in 99% of cases it accurately describes 
            the state of the objects before and after the transition. With that said, it is not a requirement that your objects 
            be actually "invisible" when in the Invisible State. This is a game specific implementation detail! However, in most 
            instances the player will notice "popping in" of objects if they are not truly invisible when they are in the 
            Invisible State.
            </para>
            <para>
            By default any custom classes that you derive from this one will only work with LODs using ChunkType.Non_Terrain_Game_Object. To 
            change this, you can enable or disable permissions by calling AllowChunkType and DisallowChunkType. When you allow a specific 
            ChunkType, all LODs on a World Grouping that is using the transition controller and that are setup to use that Chunk Type, will have 
            its World Cell's transitioned using the methods of the transition controller. You can also remove a permission for a Chunk Type 
            by calling DisallowChunkType, which will stop World Cell's from LODs that use that Chunk Type from being transitioned.
            </para>
            </summary>
            
            <title>CellVisualTransitionController Abstract Class</title>
            <category>Visual Transition Controllers</category>
            <navigationName>CellVisualTransitionController</navigationName>
            <fileName>CellVisualTransitionController.html</fileName>
            <syntax>public abstract class CellVisualTransitionController : MonoBehaviour</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.UpdateFrequency">
            <summary>
            Gets or Sets the Update Frequency of transitions.
            <para>
            This is the frequency (in seconds) at which transition positions 
            will be calculated. The value should be some factor smaller than the Transition Time set.
            </para>
            <para>
            Larger values may 
            result in better performance when transitioning a large number of objects, however will also result in 
            jerkier motion.
            </para>
            <para>
            When you set this value, the WaitPeriod object is updated to reflect the new value. Generally speaking, 
            you will want to use the WaitPeriod object in your coroutine in order to yield, rather than getting  
            the UpdateFrequency directly.
            </para>
            <para>
            If 'Use Alt Settings For LOD Transitions' is false, this will change the Update Frequency for all transitions, otherwise 
            it will only effect non LOD transitions.
            </para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.MakeInvisibleCurve">
            <summary>
            The Animation Curve defined in the inspector that can be used to transition the Cells from Visible to Invisible. Custom 
            Transitioners can choose whether to use this curve or not.
            </summary>
            <type>AnimationCurve</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.MakeVisibleCurve">
            <summary>
            The Animation Curve defined in the inspector that can be used to transition the Cells from Invisible to Visible. Custom 
            Transitioners can choose whether to use this curve or not.
            </summary>
            <type>AnimationCurve</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.TransitionTime">
            <summary>
            Gets or sets the the Transition Time set in the inspector (set should only be called in Play Mode or build). 
            Your custom Transition Controller does not need to use this value, 
            though it is usually easiest to make use of it.
            <para>
            The total transition time is set at the beginning of each method call, therefore adjustments to this 
            value mid-game will only be applied the next time one of the methods is executed.
            </para>
            <para>
            If 'Use Alt Settings For LOD Transitions' is false, this will change the Transition Time for all transitions, otherwise 
            it will only effect non LOD transitions.
            </para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.WaitPeriod">
            <summary>
            Gets the WaitForSeconds object which is based on the UpdateFrequency. If the UpdateFrequency is 0, this will return null, 
            which will allow you to yield for a single frame.
            <para>
            You can yield return this object to have your transitioner pause execution for the UpdateFrequency time, effectively 
            allowing you to control the frequency at which your transitioner updates the Cell Transitions.
            </para>
            </summary>
            <type>WaitForSeconds</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.UseAltSettingsForLODTransitions">
            <summary>
            Gets or sets whether to use alternative settings for LOD Transitions. This must return true in order to set 
            the alternative LOD Transition properties.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.LODTransitionUpdateFrequency">
            <summary>
            The getter gets the Update Frequency to use for LOD Transitions, which is the frequency (in seconds) at which changes in LOD Transitions will be 
            updated. The value should be some factor smaller than the LOD Transition Time set.
            <para>
            The getter takes into account the current value of 
            'Use Alt Settings For LOD Transitions' in order to return the correct value.
            </para>
            <para>
            The setter sets the LOD Update Frequency setting (shown in the inspector), however this value will only be returned by 
            the getter when 'Use Alt Settings For LOD Transitions' is true.
            </para>
            <para>
            When you set this value and 'Use Alt Settings For LOD Transitions' is true, the LODTransitionWaitPeriod 
            object is updated to reflect the new value. Generally speaking, 
            you will want to use the LODTransitionWaitPeriod object in your coroutine in order to yield, rather than getting  
            the LODTransitionUpdateFrequency directly.
            </para>
            <para>
            Larger values may 
            result in better performance when transitioning a large number of objects, however will also result in 
            jerkier motion.
            </para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.LODTransitionMakeInvisibleCurve">
            <summary>
            Gets the correct Animation Curve that should be used to transition LOD Cells from Invisible to Visible 
            according to the value of 'Use Alt Settings For LOD Transitions'.
            <para>
            Custom Transitioners can choose whether to use this curve or not.
            </para>
            </summary>
            <type>AnimationCurve</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.LODTransitionMakeVisibleCurve">
            <summary>
            Gets the correct Animation Curve that should be used to transition LOD Cells from Visible to Invisible 
            according to the value of 'Use Alt Settings For LOD Transitions'.
            <para>
            Custom Transitioners can choose whether to use this curve or not.
            </para>
            </summary>
            <type>AnimationCurve</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.LODTransitionTime">
            <summary>
            The getter gets the transition time to use for LOD Transitions, 
            according to the value of 'Use Alt Settings For LOD Transitions'.
            <para>
            The setter sets the LOD Transition Time setting (shown in the inspector), however this value will only be returned by 
            the getter when 'Use Alt Settings For LOD Transitions' is true.
            </para>
            <para>
            The total transition time is set at the beginning of each call to the TransitionBetweenLevelsOfDetail method, therefore adjustments to this 
            value mid-game will only be applied the next time one of the methods is executed.
            </para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellVisualTransitionController.LODTransitionWaitPeriod">
            <summary>
            Gets the WaitForSeconds object which is based on the LODTransitionUpdateFrequency 
            (if 'Use Alt Settings For LOD Transitions' is true) or UpdateFrequency (if 'Use Alt Settings For LOD Transitions' is false). 
            If the frequency is 0, this will return null, which will allow you to yield for a single frame.
            <para>
            You can yield return this object to have your transitioner pause execution for the update frequency time, effectively 
            allowing you to control the frequency at which your transitioner updates the Cell Transitions during LOD Transitions.
            </para>
            </summary>
            <type>WaitForSeconds</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.Awake">
            <summary>
            The CellVisualTransitionController's Awake method, called by Unity. You cannot utilize Awake in your derived class. 
            If you need to perform some sort of Awake related logic, override the AwakeExtended method, which will be called by this 
            classes Awake method. Also note that you do not need to call base.AwakeExtended(); from your AwakeExtended method, as 
            this is a virtual empty method that does nothing unless you override it. Also note that this method is protected simply so 
            that if you derive from this class, you will see an error when trying to add the Awake method.
            </summary>
            <displayName id="Awake">
            Awake()
            </displayName>
            <syntax>
            protected void Awake()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.AwakeExtended">
            <summary>
            Can be overriden to implement custom Awake logic in your custom Controller. Needed because the base CellVisualTransitionController already 
            makes use of Unity's Awake method.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected virtual void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.CanWorldCellsBeTransitioned(DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            During Awake while the Application is playing, this method is queried for each asset Chunk Type in order to determine if World Cell's that use each Chunk Type can be transitioned using the 
            Controller. You do not need to call this yourself, it is called automatically by SAM! The results of the queries are stored, so whatever values are first 
            returned for each each Chunk Type will be used so long as the Controller is not unloaded.
            <para>
            You must override this method in your derived class. You can choose which Chunk Types are allowed by returning 
            false for those you don't want to allow, and true for those you do.
            </para>
            What value you return for each Chunk Type is up to you.
            <para>
            If transitioning between LODs and only one LOD group has a Chunk Type that can be transitioned, it will be transitioned via 
            the TransitionToVisibleState or TransitionToInvisibleState methods instead of TransitionBetweenLevelsOfDetail.
            </para>
            <para>
            This method may at times be used with the World Asset Editor. If you setup the allowable types to use at runtime (in Awake or Start), you must 
            have some way to differentiate between an editor call and runtime call, and be able to return a valid answer to the method call in either case. 
            Within the editor, you should always return true for Chunk Types that could be transitioned using your controller.
            </para>
            </summary>
            <param name="chunkType" type="ChunkType" link="ChunkType.html">
            The Chunk Type you want to find out whether is able to be transitioned.
            </param>
            <returns type="type">
            Should return true if World Cell's using Chunk Type can be transitioned, false otherwise. If false, World Cell's with that Chunk Type will not be 
            transitioned using this controller, however you can change your settings later to allow that type to be used in the future.
            </returns>
            <displayName id="CanWorldCellsBeTransitioned">
            CanWorldCellsBeTransitioned(ChunkType)
            </displayName>
            <syntax>
            public abstract bool CanWorldCellsBeTransitioned(ChunkType ChunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.ResetToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            When overridden by a derived class, resets the state of the Asset Chunks belonging to the input World Cells to the Visible Visual State. 
            <para>
            Please note the differences between this method, ImmediatelyTransitionToVisibleState, TransitionToVisibleState, and what happens to the transitionToCells in TransitionBetweenLevelsOfDetail. 
            <para>
            This method has the following characteristics:
            </para>
            <para>
            1) The World Cells passed in may be Activated or Deactivated. Usually when isApplicationPlaying == true, the cells will be Deactivated. Whatever state the Cells are in, they should 
            be left in that state! This method SHOULD NOT change the state of the World Cells or Asset Chunks.
            </para>
            <para>
            2) This method CAN AND SHOULD manipulate properties to ensure state of Asset Chunks matches state of other Visible Asset Chunks (Transform.position, opacity, etc.).
            </para>
            <para>
            3) This method SHOULD NOT run secondary logic, as usually logic is not needed by the World Designer tool, or if isApplicationPlaying is true, the logic should only be run when 
            the Asset Chunks go from invisible to visible in the eyes of the player, which only occurs in ImmediatelyTransitionToVisibleState, TransitionToVisibleState or TransitionBetweenLevelsOfDetail.
            </para>
            ImmediatelyTransitionToVisibleState, TransitionToInvisibleState and TransitionBetweenLevelsOfDetail have the following characteristics:
            </para>
            <para>
            1) The World Cells passed in (transitionToCells for TransitionBetweenLevelsOfDetail) will either be in an Activated state, or you must immediately Activate their 
            Asset Chunks (via GameObject.SetActive(true) for instance) before transitioning them to the Visible State (only if they aren't already Activated, which is controllable by you, the Developer!).
            </para>
            <para>
            2) Methods SHOULD manipulate properties to make the Asset Chunks belonging to the World Cells Visible (Transform.position, opacity, etc.).
            </para>
            <para>
            3) Secondary logic may be OPTIONALLY run that is tightly coupled to the visibility of the Asset Chunks (enabling interactability, for instance). 
            </para>
            <para>
            Generally speaking, while the application is playing this method is used on World Cells that use Asset Chunks stored in the Visible State. It is needed to get 
            those chunks (which are transitioned to the Invisible State during the World Cells' deactivation) back to their stored Visible State. This is required so that 
            if the Asset Chunks are re-used by the Chunk Manager, they are in the same Visible Stored State that 
            newly loaded Asset Chunks (loaded via the Chunk Streamer) will be in. This ensures all Asset Chunks served by the Chunk Manager are always in the same state.
            </para>
            <para>
            Outside of Play Mode within the Editor, the method is used by the World Designer tool for Asset Chunks that are stored in the Invisible Visual State. In such instances, the Asset Chunk state 
            needs to be reset from Invisible to Visible and from Visible To Invisible at different points, in order to ensure the Assets can be seen in the editor while also ensuring that they can be 
            saved in the proper state. Note that when the Asset Chunks are stored in the Visible Visual State, this resetting behaviour is not necessary, and as such, we 
            recommended to store assets in the Visible Visual State, especially if you notice issues with the loading/saving process in the World Designer tool and narrow down the issue to 
            this method (or ResetToInvisibleState).
            </para>
            <para>
            You can differentiate between where the method is being used (while the application is playing or from the World Designer tool) using the isApplicationPlaying argument.
            </para>
            <para>
            The list of cells are guaranteed to come from the same LOD and World Grouping. You can access the number of chunks a cell has via the NumChunks property. Access the chunks directly via 
            the GetChunkBelongingToCell method, which takes a one based index as argument identifying the chunk you wish 
            to retrieve (the first chunk is at index 1, second chunk at index 2, and so on). You should account for missing chunks by checking to 
            make sure the chunks are not null, to allow the transitioner to be used with the World Asset Editor in cases where chunks have 
            been manually deleted by the editor user.
            </para>
            <para>
            If being used by the World Designer tool (isApplicationPlaying == false), it's possible that some of the Asset Chunks in one or more World Cells will be null. This is expected and should be 
            accounted for. Null objects can simply be skipped.
            </para>
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the visible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            <para>
            If false, you should account for the possibility of null Asset Chunks (which can simply be skipped).
            </para>
            </param>
            <displayName id="ResetToVisibleState">
            ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public abstract void ResetToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.ResetToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            When overridden by a derived class, resets the state of the Asset Chunks belonging to the input World Cells to the Invisible Visual State. 
            <para>
            Please note the differences between this method, TransitionToInvisibleState, and what happens to the transitionFromCells in TransitionBetweenLevelsOfDetail.
            <para>
            This method has the following characteristics:
            </para>
            <para>
            1) The World Cells passed in may be Activated or Deactivated. Usually when isApplicationPlaying == true, the cells will be Deactivated.
            </para>
            <para>
            2) Method CAN AND SHOULD manipulate properties to ensure state of Asset Chunks matches state of other Invisible Asset Chunks (Transform.position, opacity, etc.).
            </para>
            <para>
            3) Because of characteristic 1, this method SHOULD NOT change the state of the World Cells or Asset Chunks.
            </para>
            <para>
            4) Method should not run secondary logic, as usually logic is not needed by the World Designer tool, or if isApplicationPlaying is true, the logic should only be run when 
            the Asset Chunks go from visible to invisible in the eyes of the player, which only occurs in TransitionToInvisibleState or TransitionBetweenLevelsOfDetail.
            </para>
            TransitionToInvisibleState and TransitionBetweenLevelsOfDetail have the following characteristics:
            </para>
            <para>
            1) The World Cells passed in (transitionFromCells for TransitionBetweenLevelsOfDetail) will ALWAYS be in an Activated State.
            </para>
            <para>
            2) Methods SHOULD manipulate properties to make the Asset Chunks belonging to the World Cell's Invisible (Transform.position, opacity, etc.).
            </para>
            <para>
            3) Methods may OPTIONALLY deactivate the Asset Chunks (via GameObject.SetActive(false) for instance) after the Asset Chunks have been made Invisible.
            </para>
            <para>
            4) Secondary logic may be OPTIONALLY run that is tightly coupled to the visibility of the Asset Chunks (disabling interactability, for instance). 
            </para>
            <para>
            Generally speaking, while the application is playing this method is used on World Cells that are already deactivated and invisible to the Player, but whose Asset Chunk are stored in 
            the Visible State. In order to ensure the state of the Asset Chunks matches the Invisible State expected by ImmediatelyTransitionToVisibleState, TransitionToVisibleState, and 
            TransitionBetweenLevelsOfDetail (transitionToCells), some mechanism is required to modify the Asset Chunk properties to match other Invisible Asset Chunks. This method serves that purpose.
            </para>
            <para>
            Outside of Play Mode within the Editor, the method is used by the World Designer tool for Asset Chunks that are stored in the Invisible Visual State. In such instances, the Asset Chunk state 
            needs to be reset from Invisible to Visible and from Visible To Invisible at different points, in order to ensure the Assets can be seen in the editor while also ensuring that they can be 
            saved in the proper state. Note that when the Asset Chunks are stored in the Visible Visual State, this resetting behaviour is not necessary, and as such, we 
            recommended to store assets in the Visible Visual State, especially if notice issues with the loading/saving process in the World Designer tool and narrow down the issue to 
            this method (or ResetToVisibleState).
            </para>
            <para>
            You can differentiate between where the method is being used (while the application is playing or from the World Designer tool) using the isApplicationPlaying argument.
            </para>
            <para>
            The list of cells are guaranteed to come from the same LOD and World Grouping. You can access the number of chunks a cell has via the NumChunks property. Access the chunks directly via 
            the GetChunkBelongingToCell method, which takes a one based index as argument identifying the chunk you wish 
            to retrieve (the first chunk is at index 1, second chunk at index 2, and so on). You should account for missing chunks by checking to 
            make sure the chunks are not null, to allow the transitioner to be used with the World Asset Editor in cases where chunks have 
            been manually deleted by the editor user.
            </para>
            <para>
            If being used by the World Designer tool (isApplicationPlaying == false), it's possible that some of the Asset Chunks in one or more World Cells will be null. This is expected and should be 
            accounted for. Null objects can simply be skipped.
            </para>
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be reset to the invisible state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <param name="isApplicationPlaying" type="bool">
            Whether the Application is currently playing. This will be true if the game is running (i.e., Play Mode or within a normal built game), or false if 
            the method is being called inside the Editor by the World Designer tool. You may need to execute slightly different code depending on whether the 
            application is playing or not.
            <para>
            If false, you should account for the possibility of null Asset Chunks (which can simply be skipped).
            </para>
            </param>
            <displayName id="ResetToInvisibleState">
            ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType, bool)
            </displayName>
            <syntax>
            public abstract void ResetToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells,  ChunkType chunkType, bool isApplicationPlaying)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.ImmediatelyTransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            When overridden by a derived class, transitions one or more cells to the
            visible state in a single frame ("Visible" in this sense means that the visual representation 
            of the objects contained within the cell should be made visible to the player).
            <para>
            This method should perform the same functions and result in the same Visible state for the cells as TransitionToVisibleState, 
            the only difference being that it can only utilize a single frame and as such, it is not capable of creating transitional effects. That's okay, 
            however, because this method is only used in situations where the World is being initialized in single/double frame mode, where the player 
            should not see what is going on and transitional effects are not needed.
            </para>
            <para>
            In addition to transitioning the World Cells' Asset Chunks visually, you can also place code that needs to be tightly coupled to the visibility of the 
            Asset Chunks here. For instance, perhaps some interactive element needs to be enabled when the Asset Chunks are made visible. 
            Such code can be placed here directly after the Asset Chunks are made visible.
            </para>
            <para>
            Generally, it is good practice not to call SetActive(true) on any game 
            objects associated with the cells 
            and leave that responsibility up to SAM, World Asset Editor, or a World Grouping Listener component, 
            however this is entirely up to you. If you decide to call SetActive in the method, ensure 
            the method is the only thing calling SetActive to avoid unexpected behaviour (i.e., disable automatic 
            chunk activation on your World component).
            </para>
            <para>
            The list of cells are guaranteed to come from 
            the same LOD and World Grouping. You can access the number of chunks a cell has via the NumChunks property. Access the chunks directly via 
            the GetChunkBelongingToCell method, which takes a one based index as argument identifying the chunk you wish 
            to retrieve (the first chunk is at index 1, second chunk at index 2, and so on). You should account for missing chunks by checking to 
            make sure the chunks are not null, to allow the transitioner to be used with the World Asset Editor in cases where chunks have 
            been manually deleted by the editor user.
            </para>
            <para>
            Of course, if the LOD of these cells is set not to use chunks, the cell will not have chunks, in which 
            case chunkType will equal ChunkType.None.
            </para>
            <para>
            Note that unlike the other methods, there is no matching ImmediatelyTransitionToInvisibleState method. That is because single/double frame 
            initialization does not have a matching single/double frame de-initialization. Put another way, TransitionToInvisibleState is ALWAYS used when 
            unloading World Cells.
            </para>
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to the "Visible" state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="ImmediatelyTransitionToVisibleState">
            ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public abstract void ImmediatelyTransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.TransitionToVisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            When overridden by a derived class, transitions one or more cells to the
            visible state over one or more frames ("Visible" in this sense means that the visual representation 
            of the objects contained within the cell should be made visible to the player).
            <para>
            This method should perform the same functions and result in the same Visible state for the cells as ImmediatelyTransitionToVisibleState, 
            the only difference being that it can take multiple frames in order to reach the state. This allows you to create transitional effects 
            such as slowly changing the opacity of the Asset Chunks so they gradually become visible.
            </para>
            <para>
            In addition to transitioning the World Cells' Asset Chunks visually, you can also place code that needs to be tightly coupled to the visibility of the 
            Asset Chunks here. For instance, perhaps some interactive element needs to be enabled when the Asset Chunks are made visible. 
            Such code can be placed here directly after the Asset Chunks are made visible.
            </para>
            <para>
            Generally, it is good practice not to call SetActive(true) on any game 
            objects associated with the cells 
            and leave that responsibility up to SAM, World Asset Editor, or a World Grouping Listener component, 
            however this is entirely up to you. If you decide to call SetActive in the method, ensure 
            the method is the only thing calling SetActive to avoid unexpected behaviour (i.e., disable automatic 
            chunk activation on your World component).
            </para>
            <para>
            The list of cells are guaranteed to come from 
            the same LOD and World Grouping. You can access the number of chunks a cell has via the NumChunks property. Access the chunks directly via 
            the GetChunkBelongingToCell method, which takes a one based index as argument identifying the chunk you wish 
            to retrieve (the first chunk is at index 1, second chunk at index 2, and so on). You should account for missing chunks by checking to 
            make sure the chunks are not null, to allow the transitioner to be used with the World Asset Editor in cases where chunks have 
            been manually deleted by the editor user.
            </para>
            <para>
            Of course, if the LOD of these cells is set not to use chunks, the cell will not have chunks, in which 
            case chunkType will equal ChunkType.None.
            </para>
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to the "Visible" state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToVisibleState">
            TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; TransitionToVisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.TransitionToInvisibleState(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            When overridden by a derived class, transitions one or more cells to the
            invisible state over one or more frames ("Invisible" in this sense means that the visual representation 
            of the objects contained within the cell should be made invisible to the player).
            <para>
            In addition to transitioning the World Cells' Asset Chunks visually, you can also place code that needs to be tightly coupled to the visibility of the 
            Asset Chunks here. For instance, perhaps some interactive element needs to be disabled when the Asset Chunks are made invisible. 
            Such code can be placed here directly before the Asset Chunks are made invisible.
            </para>
            <para>
            Generally, it is good practice not to call SetActive(false) on any game 
            objects associated with the cells 
            and leave that responsibility up to SAM, World Asset Editor, or a World Grouping Listener component, 
            however this is entirely up to you. If you decide to call SetActive in the method, ensure 
            the method is the only thing calling SetActive to avoid unexpected behaviour (i.e., disable automatic 
            chunk deactivation on your World component).
            </para>
            <para>
            The list of cells are guaranteed to come from 
            the same LOD and World Grouping. You can access the number of chunks a cell has via the NumChunks property. Access the chunks directly via 
            the GetChunkBelongingToCell method, which takes a one based index as argument identifying the chunk you wish 
            to retrieve (the first chunk is at index 1, second chunk at index 2, and so on). You should account for missing chunks by checking to 
            make sure the chunks are not null, to allow the transitioner to be used with the World Asset Editor in cases where chunks have 
            been manually deleted by the editor user.
            </para>
            <para>
            Of course, if the LOD of these cells is set not to use chunks, the cell will not have chunks, in which 
            case chunkType will equal ChunkType.None.
            </para>
            </summary>
            <param name="cells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells whose chunks need to be transitioned to the "Invisible" state.
            </param>
            <param name="chunkType" type ="ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) that the input cells possess.
            </param>
            <displayName id="TransitionToInvisibleState">
            TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; TransitionToInvisibleState(ReadOnlyList&lt;WorldCell&gt; cells, ChunkType chunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellVisualTransitionController.TransitionBetweenLevelsOfDetail(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType,DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkType)">
            <summary>
            When overridden by a derived class, transitions one or more cells between two levels of detail, 
            so that the transitionTo cells are put into 
            a visible state while the transtitionFrom cells are put into an invisible state. 
            The list of cells are guaranteed to come from 
            the same World Grouping. All transitionTo cells are also gauranteed to come from the same LOD, 
            and all transitionFrom cells are guaranteed to come from the same LOD.
            "Visible/Invisible" in this sense means that the visual representation of the objects 
            associated within the cell should be made visible/invisible to the player.
            <para>
            If you have setup your Chunk Type permissions to disallow some types, and one of the LODs to be transitioned to or 
            from uses a disallowed type, while the other LOD uses an allowed type, this method will not be called. Instead, 
            TransitionToVisibleState or TransitionToInvisibleState will be used, depending on whether the LOD with the allowed type 
            is part of the transitionFrom group or transitionTo group.
            </para>
            <para>
            Generally it is good practice not to call SetActive on any game objects associated with the 
            cells and leave that responsibility up to SAM (by enabling 
            Auto Activate Chunks When Adding Cells) or a World Grouping Listener component, however this is entirely 
            up to you. If you decide to call SetActive in the method, ensure 
            the method is the only thing calling SetActive to avoid unexpected behaviour.
            </para>
            <para>
            You can access the number of chunks a cell has via the NumChunks property. Access the chunks directly via 
            the GetChunkBelongingToCell method, which takes a one based index as argument identifying the chunk you wish 
            to retrieve (the first chunk is at index 1, second chunk at index 2, and so on).
            </para>
            <para>
            Of course, if the LOD of these cells is set not to use cekk objects, the cell will not have chunks.
            </para>
            </summary>
            <param name="transitionFromCells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned from 
            (i.e., they are what is currently visible that we want to make invisible). 
            This list is read only and may contain cells from different LODs.
            </param>
            <param name="transitionFromCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionFromCells.
            </param>
            <param name="transitionToCells" type = "ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The list of cells containing the LOD chunks which are being transitioned to 
            (i.e., they are what is currently invisible that we want to make visible). 
            This list is read only and all cells are from the same World Grouping and LOD.
            </param>
            <param name="transitionToCellsChunkType" type = "ChunkType" link="ChunkType.html">
            The type of chunks (or none if they have none) belonging to the transitionToCells.
            </param>
            <displayName id="TransitionBetweenLevelsOfDetail">
            TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt;, ChunkType, ReadOnlyList&lt;WorldCell&gt;, ChunkType)
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; TransitionBetweenLevelsOfDetail(ReadOnlyList&lt;WorldCell&gt; transitionFrom, ChunkType transitionFromCellsChunkType, ReadOnlyList&lt;WorldCell&gt; transitionTo, ChunkType transitionToCellsChunkType)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PersistentDataController">
            <summary>
            [Deprecated] - Saving state via a Persistent Data Controller is no longer possible. Please use the new IPersistentStateManager 
            interface instead. If you have old data saved with the persistent data controller that you absolutely need to make use of, you can 
            convert the data using the <see cref="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(DeepSpaceLabs.SAM.PersistentDataController,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{System.String},System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})" href="ComponentManager.html#ConvertOldSaveData1">ComponentManager.ConvertOldSaveData</see> method. To do so, you will need to upgrade your Persistent Data Controllers (see Upgrade 
            Chapter in SAM Editor Guide for more information).
            <para>
            Provides a base implementation for Persistent Data Controllers. These components control how data is saved and loaded
            between game sessions.
            </para>
            <para>In order to utilize some of the inspector options (such as the ability to clear persistent data) when creating your own class which derives from PersistentDataController, you will need to create a custom inspector for your
            custom class. Please follow the template in the EditorTemplates.txt file 
            (found in the "TerrainSlicing/OtherScripts/DynamicLoadingScripts/Editor" folder) when creating this editor script.
            </para>
            </summary>
            <title>PersistentDataController Abstract Class</title>
            <category>Deprecated Components</category>
            <navigationName>PersistentDataController</navigationName>
            <fileName>PersistentDataController.html</fileName>
            <syntax>public abstract class PersistentDataController : MonoBehaviour</syntax>
            <inspector name ="Active Grid ID" type="int">The ID of the Active Grid whose data should be cleared when the "Clear Data" button is pressed. This option 
            is hidden with some Clear Methods.</inspector>
            <inspector name ="Clear All Persistent Scene Data" type="Button">Clears all persistent scene data related to
            this Persistent Data Controller. This will effectively "reset" your scene and should be used with caution.</inspector>
            <inspector name ="Clear Data" type="Button">Clears the persistent data in relation to the Current "Clear Method" and ID's.</inspector>
            <inspector name ="Clear Method" type="Dropdown">The clear operation that will take place when the "Clear Data" button is pressed. Select 
            a method and hover over it to see more information about it.</inspector>
            <inspector name ="Component Manager ID" type="int">The ID of the Component Manager whose data should be cleared when the "Clear Data" button is pressed. This option 
            is hidden with some Clear Methods.
            <para>As there should only ever be one Component Manager in your scene at a time, it is unlikely that you will need to change this value.</para></inspector>
            <inspector name ="Scene ID" type="string">A unique string ID that identifies this Persistent Data Controller. The Component Manager, which initiates all
            persistent data saving/loading in SAM, automatically prepends this ID to every key passed to the Persistent Data Controller. This allows
            Component Manager's and Active Grids in different scenes to utilize the same ID.
            <para>Persistent Data Controllers in different scenes MUST HAVE different ID's.</para></inspector>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PersistentDataController.SceneID">
            <summary>
            Gets the Scene ID of this Persistent Data Controller
            </summary>
            <type>string</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PersistentDataController.SaveData(System.String,System.String)">
            <summary>
            When overridden by a derived class, saves the specified data using the specified key.
            </summary>
            <param name="key" type="string">The key used to save the persistent data.</param>
            <param name="data" type="string">The persistent data that will be saved.</param>
            <displayName id="SaveData">SaveData(string, string)</displayName>
            <syntax>public abstract void SaveData(string key, string data)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PersistentDataController.TryGetData(System.String,System.String@)">
            <summary>
            When overridden by a derived class, attempts to get the persistent data associated with the specified key.
            </summary>
            <param name="key" type="string">The key used to try and retrieve the persistent data.</param>
            <param name="data" type="string">A string which will contain the data if successfully retrieved.</param>
            <returns type="bool">A value indicating whether the data was successfully retrieved. If false, "data" will be null.</returns>
            <displayName id="TryGetData">TryGetData(string, out string)</displayName>
            <syntax>public abstract bool TryGetData(string key, out string data)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PersistentDataController.TryDeleteData(System.String)">
            <summary>
            When overridden by a derived class, attempts to delete the persistent data associated with the specified key.
            </summary>
            <param name="key" type="string">The key used to identify the persistent data that should be deleted.</param>
            <returns type ="bool">A value indicating whether the persistent data was successfully deleted.</returns>
            <displayName id="TryDeleteData">TryDeleteData(string)</displayName>
            <syntax>public abstract bool TryDeleteData(string key)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PersistentDataController.DoesDataExist(System.String)">
            <summary>
            When overriden by a derived class, attempts to determine if data exist for the given key. This is used by the static ComponentManager.DoesOldPersistentDataControllerDataExist method 
            to determine if data exist, which is useful for finding out if data needs to be converted to the new Persistent State Manager format using the 
            static ComponentManager.ConvertOldSaveData method.
            </summary>
            <param name="key" type="string">
            The key used to identify the data.
            </param>
            <returns type="bool">
            True if data exist, false otherwise.
            </returns>
            <displayName id="DoesDataExist">
            DoesDataExist(string)
            </displayName>
            <syntax>
            public abstract bool DoesDataExist(string key)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs">
            <summary>
            Event Args for <see href="ActiveGrid.html#CellPlayerIsInChanged">CellPlayerIsInChanged</see> event (an event of the 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see> class).
            </summary>
            <title>CellPlayerIsInChangedEventArgs Class</title>
            <category>Event Args</category>
            <navigationName>CellPlayerIsInChangedEventArgs</navigationName>
            <fileName>CellPlayerIsInChangedEventArgs.html</fileName>
            <syntax>public sealed  class CellPlayerIsInChangedEventArgs : EventArgs</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.PseudoEndlessGridCellPlayerIsIn">
            <summary>
            When worldCellPlayerIsIn is not null, this will be set to the same value as EndlessGridCellPlayerIsInOrClosestTo, since 
            the player is actually within a Cell of the zone.
            <para>
            When worldCellPlayerIsIn is null and the reason is because the player is outside of the Zone's Boundaries, this value will be set to the Endless 
            Grid Cell the player would be in if the Zone were endless and had no gaps, i.e., if another repeated Zone were to start immediately after 
            crossing the Zone's Boundaries.
            </para>
            <para>
            This is mostly useful if you are trying to calculate the numbe rof Cells between some other Endless Grid Cell and the cell the player is in. Otherwise, 
            we do not know how this information would be useful.
            </para>
            </summary>
             <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.PseudoStreamableGridCellPlayerIsIn">
            <summary>
            The PseudoEndlessGridCellPlayerIsIn converted to a Cell on the Streamable Grid.
            </summary>
             <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.World">
            <summary>
            Gets the World associated with the Active Grid this event was triggered on, if one exists.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.WorldCellPlayerIsIn">
            <summary>
            Gets the World Cell the player is Currently in, if one exists. A World Cell exists only 
            when the World has objects loaded for that cell, and when the Player is within a Cell's Boundaries.
            </summary>
            <type link="WorldCell.html">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.EndlessGridCellPlayerIsInOrClosestTo">
            <summary>
            Gets the cell the player is in as projected on an Endless Grid of cells. 
            If WorldCellPlayerIsIn is null and the reason is that the player is outside of the Zone's Boundaries, this cell is the cell in the Zone that is closest to the Player.
            <para>
            In these instances, you can use PseudoEndlessGridCellPlayerIsIn 
            instead to approximate the cell distance between the player's cell and some 
            other cell (on the endless grid).
            </para>
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.StreamableGridCellPlayerIsInOrClosestTo">
            <summary>
            The EndlessGridCellPlayerIsInOrClosestTo converted to a Cell on the Streamable Grid.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.ActiveGridGroupingIndex">
            <summary>
            The index of the Active Grid Grouping that this event is firing for. You can use this to filter out events for groupings you do not 
            care about.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.ZoneIndex">
            <summary>
            The index of the Zone that this event is associated with. You can use this to filter out events for zones you do not 
            care about.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.WorldGroupingIndex">
            <summary>
            The index of the World Grouping that the Active Grid Grouping firing this event is associated with. You can use this to filter out events for groupings you do not 
            care about.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellPlayerIsInChangedEventArgs.ReasonForNullWorldCell">
            <summary>
            When WorldCellPlayerIsIn is null, this property can be used to get the reason for why it is null, 
            which can be useful for debugging purposes.
            </summary>
            <type>string</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PlayerMovedByGridEventArgs">
            <summary>
            Event Args for a <see href="ActiveGrid.html#PlayerMovedByGrid">PlayerMovedByGrid</see> event (an event of the 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see> class).
            </summary>
            <title>PlayerMovedByGridEventArgs Class</title>
            <category>Event Args</category>
            <navigationName>PlayerMovedByGridEventArgs</navigationName>
            <fileName>PlayerMovedByGridEventArgs.html</fileName>
            <syntax>public sealed class PlayerMovedByGridEventArgs : EventArgs</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PlayerMovedByGridEventArgs.Player">
            <summary>
            Gets the player that was moved by the Active Grid.
            </summary>
            <type>Transform</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PlayerMovedByGridEventArgs.#ctor(DeepSpaceLabs.SAM.IPlayer)">
            <summary>
            Initializes a new instance of the PlayerMovedByGridEventArgs class with the passed in player.
            </summary>
            <param name="player" type="IPlayer" link="IPlayer.html">The player that was moved.</param>
            <displayName id="PlayerMovedByGridEventArgs">PlayerMovedByGridEventArgs(IPlayer)</displayName>
            <syntax>public PlayerMovedByGridEventArgs(IPlayer player)</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldSyncedToChangedEventArgs">
            <summary>
            Event Args for a <see href="ActiveGrid.html#WorldSyncedToChanged">WorldSyncedToChanged</see> event (an event of the 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see> class).
            <para>
            This is fired when the Active Grid is 
            first initialized and syncs to a World, or when you manually change the World via the API. In addition to containing references to the 
            old and new World, it also contains the starting world cells for the player, for each layer on the new world. Using this 
            in conjuction with the CellPlayerIsInChanged event will allow you to fully track which cell the player is in for one or all layers.
            </para>
            <para>
            Please note, any reference values stored in this event are immedidately nulled out after all listeners have been notified of the 
            event, therefore, if you wish to reference the objects after your listener method has been called, you will need to save a 
            reference to the object(s) yourself.
            </para>
            </summary>
            <title>WorldSyncedToChangedEventArgs Class</title>
            <category>Event Args</category>
            <navigationName>WorldSyncedToChangedEventArgs</navigationName>
            <fileName>WorldSyncedToChangedEventArgs.html</fileName>
            <syntax>public sealed class WorldSyncedToChangedEventArgs : EventArgs</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldSyncedToChangedEventArgs.OldWorld">
            <summary>
            Gets the old World that the Active Grid was synced to.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldSyncedToChangedEventArgs.NewWorld">
            <summary>
            Gets the new World that the Active Grid is now synced to. If this is null, you should not try to use the 
            GetWorldCellPlayerIsStartingIn and GetEndlessGridCellPlayerIsStartingIn methods, as they will not be set.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldSyncedToChangedEventArgs.SyncedGroupingInfo">
            <summary>
            Provides information about each Active Grid Grouping Synced to the New World. If New World is null (which can happen 
            when the event is fired for a desync operation), this will return null, so you sould check if New World is null before iterating over 
            this collection!
            </summary>
            <type link="SyncedGroupingInfo.html">ReadOnlyList&lt;SyncedGroupingInfo&gt;</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SyncedGroupingInfo">
            <summary>
            Contains information about an Active Grid Grouping that is synced to a World.
            <para>
            </para>
            </summary>
            <title>SyncedGroupingInfo Class</title>
            <category>Secondary Non Components</category>
            <navigationName>SyncedGroupingInfo</navigationName>
            <fileName>SyncedGroupingInfo.html</fileName>
            <syntax>
            public class SyncedGroupingInfo
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SyncedGroupingInfo.ActiveGridIndex">
            <summary>
            The Index of the Active Grid Grouping, as shown in the Active Grid inspector.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SyncedGroupingInfo.WorldGroupingIndex">
            <summary>
            The index of the World Grouping that the the Active Grid Grouping is synced to.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.SyncedGroupingInfo.WorldCellsPlayerIsStartingIn">
            <summary>
            The World Cells, if loaded, that the player is starting in for every World Grouping this Active Grid Grouping is synced to.
            <para>
            If you have multiple overlapping Zones on your World, this list may contain multiples World Cells. If all Zones do not overlap, then the 
            list should only contain a single World Cell.
            </para>
            </summary>
            <type link="WorldCell.html">List&lt;WorldCell&gt;</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TransformShiftEventArgs">
            <summary>
            These Event Args are used with the <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">World Shifter</see> class's 
            <see href="WorldShifter.html#TransformShifting">TransformShifting</see> and 
            <see href="WorldShifter.html#TransformShifted">TransformShifted</see> events.
            <para>
            You can subscribe to these events (via the inspector or scripting) 
            on whatever World Shifter class you are using in order to receive notification before or after 
            a transform has been shifted as a result of a World Shift.
            </para>
            <para>
            If you create a custom World Shifter class, in order to utilize these events, you must use the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.ShiftTransformAndFireEvents(UnityEngine.Transform)" href="WorldShifter.html#ShiftTransformAndFireEvents">ShiftTransformAndFireEvents</see> method of 
            the World Shifter class, or fire the events yourself using the <see cref="M:DeepSpaceLabs.SAM.WorldShifter.FireTransformShiftingEvent(UnityEngine.Transform,System.Int32)" href="WorldShifter.html#FireTransformShiftingEvent">FireTransformShiftingEvent</see> (before shifting each Transform) and 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.FireTransformShiftedEvent(UnityEngine.Transform,System.Int32)" href="WorldShifter.html#FireTransformShiftedEvent">FireTransformShiftedEvent</see> (after 
            shifting each transform) methods. 
            Note, if you use the manual firing method, you <b>MUST NOT</b> use ShiftTransformAndFireEvents as well.
            </para>
            <para>
            The properties contain useful information, however note that they are only valid within the subscriber method that is passed the event args. If you need 
            to utilize the data after your subscriber method runs, you must store the references or data.
            </para>
            </summary>
            <title>
            TransformShiftEventArgs Class
            </title>
            <category>Event Args</category>
            <navigationName>TransformShiftEventArgs</navigationName>
            <fileName>TransformShiftEventArgs.html</fileName>
            <syntax>
            public sealed class TransformShiftEventArgs : EventArgs
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformShiftEventArgs.WorldTransformBelongsTo">
            <summary>
            The World that the transform belongs to. All transforms in a shift cycle belong to the same world.
            </summary>
            <type link = "World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformShiftEventArgs.ShiftAmount">
            <summary>
            The amount of the shift. All transforms in the shift cycle will be shifted by this amount if the event is a PreTransformShift event, 
            or have been shifted by this amount if the event is a PostTransformShift event.
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformShiftEventArgs.TransformNumberInShiftCycle">
            <summary>
            The number of the current transform amongst all transforms in the shift cycle. Will = 1 for the first 
            transform that is shifted, and = TotalTransformsInShiftCycle for the last transform that is shifted. You can use this 
            to trigger logic that should only occur once before or after all transforms have been shifted (also making use of the 
            WasCurrentEventFiredBeforeTransformWasShifted property).
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformShiftEventArgs.TotalTransformsInShiftCycle">
            <summary>
            The total number of the transform that will be or have been shifted in this shift cycle. You can use this 
            to trigger logic that should only occur after all transforms have been shifted (also making use of the 
            WasCurrentEventFiredBeforeTransformWasShifted property), by checking if TransformNumberInShiftCycle is = to 
            TotalTransformsInShiftCycle.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TransformShiftEventArgs.Transform">
            <summary>
            The current transform of the event. It may have been shifted already, or may be set to shift after the current event is done 
            firing. Check WasCurrentEventFiredBeforeTransformWasShifted to find out.
            </summary>
            <type>Transform</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldShiftEventArgs">
            <summary>
            These Event Args are used with the <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">World Shifter</see> class's 
            <see href="WorldShifter.html#WorldShifting">WorldShifting</see> and 
            <see href="WorldShifter.html#WorldShifted">WorldShifted</see> events.
            <para>
            If you create a custom World Shifter class, in order to utilize these events, you must either configure the 
            <see cref="P:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftingEventAutomatically" href="WorldShifter.html#FireWorldShiftingEventAutomatically">FireWorldShiftingEventAutomatically</see> 
            and/or 
            <see cref="P:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftedEventAutomatically" href="WorldShifter.html#FireWorldShiftedEventAutomatically">FireWorldShiftedEventAutomatically</see> 
            properties to return true, or manually call the 
            <see cref="M:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftingEvent" href="WorldShifter.html#FireWorldShiftingEvent">FireWorldShiftingEvent</see> (before shifting the 
            World) and <see cref="M:DeepSpaceLabs.SAM.WorldShifter.FireWorldShiftedEvent" href="WorldShifter.html#FireWorldShiftedEvent">FireWorldShiftedEvent</see> (after 
            shifting the World) methods.
            </para>
            <para>
            Note, you should do one or the other. You <b>MUST NOT</b> call FireWorldShiftingEvent if FireWorldShiftingEventAutomatically is overriden to return true. The 
            same goes for FireWorldShiftedEvent and FireWorldShiftedEventAutomatically.
            </para>
            <para>
            The properties contain useful information, however note that they are only valid within the subscriber method that is passed the event args. If you need 
            to utilize the data after your subscriber method runs, you must store the references or data.
            </para>
            </summary>
            <title>
            WorldShiftEventArgs Class
            </title>
            <category>Event Args</category>
            <navigationName>WorldShiftEventArgs</navigationName>
            <fileName>WorldShiftEventArgs.html</fileName>
            <syntax>
            public sealed class WorldShiftEventArgs : EventArgs
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShiftEventArgs.World">
            <summary>
            The world that is going to be shifted or has been shifted.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldShiftEventArgs.ShiftAmount">
            <summary>
            The amount that will be added or has been added to the object positions of the world.
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PlayerMover">
             <summary>
             Provides a base implementation for Player Movers.
             <para>
            Player Movers are used anytime S.A.M. needs to move the Player, for instance when 
            the Active Grid is moved in response to an Origin Cell Change(and Move Player After Origin Cell Change is enabeld on Active Grid), or when 
            the <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerToLocation(DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Boolean,System.Boolean,System.Double)" href="ActiveGrid.html#TryMovePlayerToLocation">TryMovePlayerToLocation</see> method 
             is called.
             </para>
             <para>
             If no PlayerMover is provided to the Active Grid, the player will be moved by simply 
             calling Player.Position = newPosition, or Player.Position += adjustment (the latter is 
             used when an Origin Cell Change occurs). 
             Depending on your movement system, however, this may not be ideal, as it can de-sync 
             the player from the physics system and cause issues (such as the player falling through the world).
             </para>
             <para>
             For this reason, you can create a custom script or modify an existing script to derive from PlayerMover and implement 
             the required methods in a way that works with your movement scheme.
             </para>
             <para>
             In order to save the player's position correctly, the Active Grid needs to know exactly when the player's position has been changed 
             by your implementation. As such, it is imperative that once you move the player, you break out of or complete the coroutine so that 
             the script using the PlayerMover can continue executing.
             </para>
             <para>
             Also note that for Origin Cell changes, you also have the options of letting your World Shifter (if using one) move the player, which in many instances will be 
             better as you can time the move with the movement of the Asset Chunks surrounding the player, so that they don't notice the move. If you go 
             this route, you should disable <b>Move Player After Origin Cell Change</b> on your Active Grid.
             </para>
             </summary>
             <title>PlayerMover Abstract Class</title>
             <category>Player Movers</category>
             <navigationName>PlayerMover</navigationName>
             <fileName>PlayerMover.html</fileName>
             <syntax>public abstract class PlayerMover : MonoBehaviour</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PlayerMover.MovePlayerByAmount(DeepSpaceLabs.SAM.IPlayer,DeepSpaceLabs.SAM.Vector3Double,System.Boolean)">
            <summary>
            When override in a derived class, moves the player by the Vector3Double amount. That is, the amountToMovePlayer should
            be added to the existing player's position.
            </summary>
            <param name="player" type="IPlayer" link="IPlayer.html">
            The player that will be moved.
            </param>
            <param name="amountToMovePlayer" type="Vector3Double" link="Vector3Double.html">
            The amount the player will be moved (the amount to add to the player's Current position).
            </param>
            <param name="immediateMode">
            A value of true indicates that the method is being run in immediate mode, meaning the code must be able to run fully without 
            yielding. Your code can contain yield statements, however they will be skipped over, thus it is usually better to write 
            alternative code that only runs in immediate mode that works without yielding. If your code depends on yielding it will almost certainly 
            stall (which will stall out the calling method).
            <para>
            Note that currently immediateMode is only used by WorldShifter's when the 'Perform Shift In Single Frame' setting is enabled, so if 
            you truly cannot implement code that works for it, you will need to not use a World Shifter with that setting enabled.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="MovePlayerByAmount">
            MovePlayerByAmount(IPlayer, Vector3Double)
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; MovePlayerByAmount(IPlayer player, Vector3Double amountToMovePlayer, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PlayerMover.MovePlayerToPosition(DeepSpaceLabs.SAM.IPlayer,DeepSpaceLabs.SAM.Vector3Double,System.Boolean)">
            <summary>
            When override in a derived class, moves the player to the specified position in world space.
            </summary>
            <param name="player" type="IPlayer" link="IPlayer.html">
            The player that will be moved.
            </param>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position the player will be moved to.
            </param>
            <param name="immediateMode">
            A value of true indicates that the method is being run in immediate mode, meaning the code must be able to run fully without 
            yielding. Your code can contain yield statements, however they will be skipped over, thus it is usually better to write 
            alternative code that only runs in immediate mode that works without yielding. If your code depends on yielding it will almost certainly 
            stall (which will stall out the calling method).
            <para>
            Note that currently immediateMode is not used by any SAM related code for MovePlayerToPosition (but it is used 
            with MovePlayerByAmount), so you can technically ignore this setting for now.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="MovePlayerToPosition">
            MovePlayerToPosition(IPlayer, Vector3Double, bool)
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; MovePlayerToPosition(IPlayer player, Vector3Double position, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CapacitySortedListPool`1.WithdrawList(System.Int32)">
            <summary>
            Tries to get a list that is equal to the desiredCapacity, or if no such list exist, one that has a larger capacity.
            If that does not exist, a new list is created with desiredCapacity.
            </summary>
            <param name="desiredCapacity">The desired capacity of the list</param>
            <returns>A list with capacity >= the desiredCapacity</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SelfCreatingPool`1">
            <summary>
            A pool which is capable of generating new pooled objects when needed.
            <para>
            </para>
            </summary>
            <title>
            SelfCreatingPool Class
            </title>
            <category>Pools</category>
            <navigationName>
            SelfCreatingPool
            </navigationName>
            <fileName>SelfCreatingPool.html</fileName>
            <syntax>
            public sealed class SelfCreatingPool&lt;T&gt; : ISelfCreatingNewObjectHandler&lt;T&gt; where T : class
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SelfCreatingPool`1.#ctor(System.Func{`0})">
            <summary>
            Creates a new instance of the Self Creating Pool.
            </summary>
            <param name="CreateNewObjectFunction" type="Func&lt;T&gt;">
            The fuction to use to create new objects for the pool when needed.
            </param>
            <displayName id="SelfCreatingPool">
            SelfCreatingPool(Func&lt;T&gt;)
            </displayName>
            <syntax>
            public SelfCreatingPool(Func&lt;T&gt; CreateNewObjectFunction)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SelfCreatingPool`1.WithdrawObject">
            <summary>
            Withdraws an object from the pool.
            </summary>
            <returns type="T">
            The object.
            </returns>
            <displayName id="WithdrawObject">
            WithdrawObject()
            </displayName>
            <syntax>
            public T WithdrawObject()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.SelfCreatingPool`1.DepositObject(`0)">
            <summary>
            Deposits an object back into the pool.
            </summary>
            <param name="obj" type="T">
            The object to deposit.
            </param>
            <displayName id="DespositObject">
            DespositObject(T)
            </displayName>
            <syntax>
            public void DespositObject(T obj)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TransformPool">
            <summary>
            Provides an implementation of the 
            <see cref="T:DeepSpaceLabs.SAM.ISelfCreatingNewObjectHandler`1" href="ISelfCreatingNewObjectHandler.html">ISelfCreatingNewObjectHandler</see> 
            interface that handles Transform components.
            <para>
            This handler works by pooling the Transforms (which are attached to empty game objects) under a deactivated parent in the scene, 
            and also allows you to specify a maximum number of transforms to keep in the pool. Once that limit is reached, the 
            Transforms (and game objects) will be destroyed rather than pooled.
            </para>
            </summary>
            <title>TransformPool Class</title>
            <category>Pools</category>
            <navigationName>TransformPool</navigationName>
            <fileName>TransformPool.html</fileName>
            <syntax>
            public sealed class TransformPool : <see cref="T:DeepSpaceLabs.SAM.ISelfCreatingNewObjectHandler`1" href="ISelfCreatingNewObjectHandler.html">ISelfCreatingNewObjectHandler</see>&lt;Transform&gt;
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformPool.WithdrawObject">
            <summary>
            Gets a transform object from the handler.
            </summary>
            <displayName id = "WithdrawObject">
            WithdrawObject()
            </displayName>
            <syntax>
            public Transform WithdrawObject()
            </syntax>
            <returns type="Transform">A Transform from the pool.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TransformPool.DepositObject(UnityEngine.Transform)">
            <summary>
            Gives a transform object to the handler for pooling or destruction.
            </summary>
            <param name="obj" type="Transform">
            The object to give to the handler.
            </param>
            <displayName id = "DespositObject">
            DespositObject(Transform)
            </displayName>
            <syntax>
            public void DespositObject(Transform obj)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkSetPool">
            <summary>
            A class used with Pooling Chunk Managers to store chunk sets.
            <para>
            If creating a custom pooling manager, please take special care in reading the information about each method, as there is a specific way 
            that the pool needs to be used in order to maximize efficiency.
            </para>
            </summary>
            <title>
            ChunkSetPool Class
            </title>
            <category>Pools</category>
            <navigationName>
            ChunkSetPool
            </navigationName>
            <fileName>ChunkSetPool.html</fileName>
            <syntax>
            public class ChunkSetPool
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.#ctor(System.Int32,System.Collections.Generic.EqualityComparer{DeepSpaceLabs.SAM.Cell})">
            <summary>
            Creates a new instance of the Chunk Set Pool.
            </summary>
            <param name="maxChunkSetsToPool" type="int">
            The max number of chunk sets to store per Streamable Grid Cell
            </param>
            <param name="comparer" type="EqualityComparer&lt;Cell&gt;" link="Cell.html">
            Equality Comparerer to use to compare Streamable Grid Cells.
            </param>
            <displayName id="ChunkSetPool">
            ChunkSetPool(int, EqualityComparer&lt;Cell&gt;)
            </displayName>
            <syntax>
            public ChunkSetPool(int maxChunkSetsToPool, EqualityComparer&lt;Cell&gt; comparer)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.IsEmpty">
            <summary>
            Method that checks whether any chunk sets for any Streamable Grid Cells are being stored in the pool. 
            If you want to know if a specific Streamable Grid Cell has chunk sets, use 
            <see cref="M:DeepSpaceLabs.SAM.ChunkSetPool.DoesCellHavePooledChunks(DeepSpaceLabs.SAM.Cell)" href="ChunkSetPool.html#DoesCellHavePooledChunks">DoesCellHavePooledChunks</see> instead.
            </summary>
            <returns type="bool">
            Returns true if pool is empty (no chunk sets present at all), or false otherwise.
            </returns>
            <displayName id="IsEmpty">
            IsEmpty()
            </displayName>
            <syntax>
            public bool IsEmpty()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.IsAtCapacity(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Checks whether a particular Streamable Grid Cell is at capacity within the pool. That is, whether it already has x set of chunks 
            (where x >= Max Chunk Sets in Pool) in the pool. This is used by the built in pooling logic to determine if a World Cell's chunk set should be 
            pooled.
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The Streamable Grid Cell whose capacity you are inquring about. You can get this value via WorldCell.CellOnStreamableGrid.
            </param>
            <returns type="bool">
            True if storage for the cell is at capacity, false otherwise. If true, you should not deposit more chunk sets into the pool!
            </returns>
            <displayName id="IsAtCapacity">
            IsAtCapacity(Cell)
            </displayName>
            <syntax>
            public bool IsAtCapacity(Cell streamableGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.DoesCellHavePooledChunks(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Queries whether the Streamable Grid Cell has at least one chunk set in the pool.
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The Streamable Grid Cell whose chunks you are inquring about. You can get this value via WorldCell.CellOnStreamableGrid.
            </param>
            <returns type="bool">
            True if chunks are being pooled, false otherwise.
            </returns>
            <displayName id="DoesCellHavePooledChunks">
            DoesCellHavePooledChunks(Cell)
            </displayName>
            <syntax>
            public bool DoesCellHavePooledChunks(Cell streamableGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.NumberOfChunkSetsPooledForCell(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Gets the number of chunk sets in the pool for the Streamable Grid Cell.
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The Streamable Grid Cell whose chunks you are inquring about. You can get this value via WorldCell.CellOnStreamableGrid.
            </param>
            <returns type="int">
            The number of chunk sets currently in the pool for the Streamable Grid Cell.
            </returns>
            <displayName id="NumberOfChunkSetsPooledForCell">
            NumberOfChunkSetsPooledForCell(Cell)
            </displayName>
            <syntax>
            public int NumberOfChunkSetsPooledForCell(Cell streamableGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.WithdrawFromPool(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Withdraws a set of chunk objects associated with a particular Streamable Grid Cell from the pool. The list of chunks is removed from the pool, 
            however you will need to return the list object itself so that it can be reused internally by calling the 
            <see cref="M:DeepSpaceLabs.SAM.ChunkSetPool.ReturnReusableListToPool(System.Collections.Generic.List{System.Object})" href="ChunkSetPool.html#ReturnReusableListToPool">ReturnReusableListToPool</see> method. You should  
            do this onlya after you have attached all of the chunks from the list onto your World Cell.
            <para>
            ReturnReusableListToPool will clear and pool the list object so that it can 
            be reused later by either this ChunkSetPool or another ChunkSetPool.
            </para>
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The Streamable Grid Cell whose chunks you wish to withdraw from the pool. You can get this value via WorldCell.CellOnStreamableGrid.
            </param>
            <returns type="List&lt;object&gt;">
            The withdrawn chunks.
            </returns>
            <displayName id="WithdrawFromPool">
            WithdrawFromPool(Cell)
            </displayName>
            <syntax>
            public List&lt;object&gt; WithdrawFromPool(Cell streamableGridCell)
            </syntax>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            Thrown if there are no chunk sets stored for the Streamable Grid Cell indicated by flattenedStreamableGridCellIndex.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.DepositIntoPool(DeepSpaceLabs.SAM.Cell,System.Collections.Generic.List{System.Object})">
            <summary>
            Deposits the chunks into the pool. You should check IsAtCapacity before calling this method, to ensure that you don't 
            add too many chunk sets to the pool!
            <para>
            In order minimize garbage generation, you can retrieve the list to store the chunks in using the 
            <see cref="M:DeepSpaceLabs.SAM.ChunkSetPool.GetReusableListFromPool(System.Int32)" href="ChunkSetPool.html#GetReusableListFromPool">GetReusableListFromPool</see> method.
            </para>
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The Streamable Grid Cell whose chunk set you wish to pool. You can get this value via WorldCell.CellOnStreamableGrid.
            </param>
            <param name="chunks" type="List&lt;object&gt;">
            The chunks to store for the Streamable Grid Cell.
            </param>
            <displayName id="DepositIntoPool">
            DepositIntoPool(Cell, List&lt;object&gt;)
            </displayName>
            <syntax>
            public void DepositIntoPool(Cell streamableGridCell, List&lt;object&gt; chunks)
            </syntax>
            <exception cref="T:System.InvalidOperationException">
            Thrown if you try to add a chunk set for a Streamable Grid Cell that is already at capacity.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.GetReusableListFromPool(System.Int32)">
            <summary>
            Gets a list with capacity equal to or greater than numChunks. The list comes from an internal static pool that is reused between 
            all classes deriving from PoolingChunkManager. In order for the pooling of these lists to work correctly, you need 
            to call ReturnReusableList whenever the list is no longer needed.
            <para>
            The typical use case for using this method is as follows:
            </para>
            <para>
            1) Before detatching Asset Chunks from a World Cell and returning those chunks to this pool, call this method to get a list that 
            the chunks can be stored in.
            </para>
            <para>
            2) Detatch the Asset Chunks from the World Cell and add them to the list retrieved in step 1.
            </para>
            <para>
            3) Call <see cref="M:DeepSpaceLabs.SAM.ChunkSetPool.DepositIntoPool(DeepSpaceLabs.SAM.Cell,System.Collections.Generic.List{System.Object})" href="ChunkSetPool.html#DepositIntoPool">DepositIntoPool</see> to deposit the list of asset chunks into this pool.
            </para>
            </summary>
            <param name="numChunks" type = "int">
            The number of chunks that will be stored in the list.</param>
            <returns type="List&lt;object&gt;">
            The reusable list.
            </returns>
            <displayName id="GetReusableListFromPool">
            GetReusableListFromPool(int)
            </displayName>
            <syntax>
            public List&lt;object&gt; GetReusableListFromPool(int numChunks)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.ReturnReusableListToPool(System.Collections.Generic.List{System.Object})">
            <summary>
            Returns a reusable list to the internal static pool. The pool is shared between all classes that derive from 
            PoolingChunkManager, which cuts down on the number of new list objects needed. 
            This list should have been retrieved via the 
            <see cref="M:DeepSpaceLabs.SAM.ChunkSetPool.WithdrawFromPool(DeepSpaceLabs.SAM.Cell)" href="ChunkSetPool.html#WithdrawFromPool">WithdrawFromPool</see> method.
            <para>
            The typical use case for using this method is as follows:
            </para>
            <para>
            1) Call <see cref="M:DeepSpaceLabs.SAM.ChunkSetPool.WithdrawFromPool(DeepSpaceLabs.SAM.Cell)" href="ChunkSetPool.html#WithdrawFromPool">WithdrawFromPool</see> 
            to get a list of Asset Chunks from this pool that can be attached to a World Cell.
            </para>
            <para>
            2) Attach the Asset Chunks from the list to the World Cell.
            </para>
            <para>
            3) Call this method to return the list to the internal list pool so that it can be reused.
            </para>
            </summary>
            <param name="list" type="List&lt;object&gt;">
            The list to return to the pool.
            </param>
            <displayName id="ReturnReusableListToPool">
            ReturnReusableListToPool(List&lt;object&gt;)
            </displayName>
            <syntax>
            public void ReturnReusableListToPool(List&lt;object&gt; list)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkSetPool.GetCellsWithChunkSets">
            <summary>
            Can be used to retrieve an enumerable collection of the Streamable Grid Cells that have chunk sets in the pool. Useful for iterating over 
            these cells in a garbage free manner.
            </summary>
            <returns type="KeyEnumerable">
            The enumerable object. Use in a foreach loop or call GetEnumerator.
            </returns>
            <displayName id="GetCellsWithChunkSets">
            GetCellsWithChunkSets()
            </displayName>
            <syntax>
            public KeyEnumerable GetCellsWithChunkSets()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PrefabChunkStreamer">
            <summary>
            A Chunk Streamer which loads prefabs into the scene via the 
            <see href="http://docs.unity3d.com/ScriptReference/Resources.LoadAsync.html">Resources.LoadAsync</see> and 
            <see href="http://docs.unity3d.com/ScriptReference/Object.Instantiate.html">Object.Instantiate</see>
            methods (only when single frame loading is required), and unloads prefab chunks from the scene using an attached 
            <see cref="T:DeepSpaceLabs.SAM.ChunkDestroyer" href="ChunkDestroyer.html">Chunk Destroyer</see> or GameObject.Destroy if a destroyer 
            is not present.
            <para>
            When using this component, the prefabs can be stored directly in a folder called Resources, or within a subfolder within the 
            Resources folder. If stored in a sub folder, you will need to enable Prepend Extra User Data and provide a valid key in the Prepend 
            Data Key field, that can be used to retrieve the sub folder path for each user of the loader (A user is a specific LOD from a specific 
            Streamable Grid asset). More information can be found by hovering over the Prepend Extra User Data and Prepend Data Key fields in the inspector, 
            or by consulting the in Editor Guide.
            </para>
            <para>
            You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Streamable Assets Manager.
            </para>
            </summary>
            <title>PrefabChunkStreamer Class</title>
            <category>Chunk Streamers</category>
            <navigationName>PrefabChunkStreamer</navigationName>
            <fileName>PrefabChunkStreamer.html</fileName>
            <syntax>public sealed class PrefabChunkStreamer : <see cref = "T:DeepSpaceLabs.SAM.ChunkStreamer" href = "ChunkStreamer.html">ChunkStreamer</see></syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PrefabChunkStreamer.ExtraDataToPrependKey">
            <summary>
            See <see cref="P:DeepSpaceLabs.SAM.ChunkStreamer.ExtraDataToPrependKey" href="ChunkStreamer.html#ExtraDataToPrependKey">ChunkStreamer.ExtraDataToPrependKey</see> 
            for more information on this property. This implemention simply returns the value 
            of 'Prepend Data Key' set in the inspector if 'Prepend Extra User Data' is true, or null if 'Prepend Extra User Data' is false.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PrefabChunkStreamer.ChunkDestroyer">
            <summary>
            Gets the Chunk Destroyer associated with this component.
            </summary>
            <type link="ChunkDestroyer.html">ChunkDestroyer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PrefabChunkStreamer.MemoryFreeingStrategy">
            <summary>
            The strategy for freeing memory, which basically determines if/when Resources.UnloadUnusedAssets() is called.
            </summary>
            <type link="MemoryFreeingStrategy.html">MemoryFreeingStrategy</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PrefabChunkStreamer.AsyncLoadStrategy">
            <summary>
            Gets or sets the Async Load Strategy. 
            </summary>
            <type link="AsyncLoadStrategy.html">AsyncLoadStrategy</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PrefabChunkStreamer.AwakeExtended">
            <summary>
            Awake related code for the Prefab Chunk Streamer.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected sealed override void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PrefabChunkStreamer.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Creates a new PrefabInstantiatorUser, which is a custom type which derives from ChunkStreamerUser. This user object
            contains a <see cref="T:DeepSpaceLabs.SAM.CellString" href = "CellString.html">CellString</see> and some other data 
            used specifically by this class.
            </summary>
            <param name="zoneGrouping" type="IZoneGrouping" link="IZoneGrouping.html">
            The Zone Grouping being registered.
            </param>
            <displayName id = "CreateNewUser">CreateNewUser(IZoneGrouping)</displayName>
            <syntax>protected override ChunkStreamerUser CreateNewUser(IZoneGrouping zoneGrouping)</syntax>
            <returns type = "ChunkStreamerUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PrefabChunkStreamer.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            Because instantiated prefabs do not need a frame to "process", pre-loading is not required, and so this
            property is overridden to return false.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PrefabChunkStreamer.LoadAndAttachChunksToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Instantiates and attaches all cell chunks to the input cells in a single frame. This is not very performant and so should only
            be used in Awake or Start.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose objects need to be attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the attached.</param>
            <displayName id = "LoadAndAttachChunksToCellsInSingleFrame">LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public sealed override void LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PrefabChunkStreamer.LoadAndAttachChunksToCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Loads and attaches the chunks associated with the input cells to the cells over a period of frames.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose chunks need to be loaded and attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "LoadAndAttachChunksToCellsInSingleFrame">LoadAndAttachChunksToCells(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PrefabChunkStreamer.DetachAndUnloadChunksFromCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Detaches and unloads the chunks associated with the input world cells over a period of frames using the associated 
            ChunkDestroyer, or GameObject.Destroy if no destroyer is present.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The World Cells whose chunks need to be detached and unloaded.
            </param>
            <param name="userID" type = "int">
            The ID of the user requesting the unload and detachment.
            </param>
            <displayName id = "DetachAndUnloadChunksFromCells">
            DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt; deactivatedCells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PrefabChunkStreamer.PrefabChunkStreamerUser.MaxInstantiateOpsInSingleFrame">
            <summary>
            The Max Instantiate Ops In A Single Frame. If the LOD Group has Extra Data available corresponding to this, that data will have been 
            used to set this value. If not, this will be set to Default Max Instantiate Ops In Single Frame
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.RegistrationHandler`1">
            <summary>
            Handles the registration of multiple users of any reference type. 
            </summary>
            <title>RegistrationHandler&lt;T&gt; Class</title>
            <category>Secondary Non Components</category>
            <navigationName>RegistrationHandler</navigationName>
            <fileName>RegistrationHandler.html</fileName>
            <syntax>public sealed class RegistrationHandler&lt;T&gt; where T : class</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.#ctor">
            <summary>
            Initializes a new instance of the RegistrationHandler class, with a default capacity of 4.
            </summary>
            <displayName id = "RegistrationHandler1">RegistrationHandler()</displayName>
            <syntax>public RegistrationHandler()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the RegistrationHandler class, with a capacity of intitialCapacity.
            </summary>
            <param name="intitialCapacity" type = "int">The initial capacity of the registration handler. If a user is registered
            when there is no more room, the capacity will be doubled.</param>
            <displayName id ="RegistrationHandler2">RegistrationHandler(int)</displayName>
            <syntax>public RegistrationHandler(int intitialCapacity)</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegistrationHandler`1.LastValidID">
            <type>int</type>
            <summary>
            Gets a value reflecting the last valid ID in the Current registrar. Valid ID's range from 0 to LastValidID.
            Note that this is a reflection of the Current possible registrants, not the max allowed registrants.
            The main use of this is for validating ID's you are not sure are valid, since trying to access a registrant 
            with an invalid ID will cause all sorts of trouble.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegistrationHandler`1.Item(System.Int32)">
            <type>T</type>
            <summary>
            Gets the user T associated with the specified registrationID.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegistrationHandler`1.RegistrantsExists">
            <summary>
            Gets a value indicating whether any users are registered.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.RegistrationHandler`1.RegistrantsRegistered">
            <summary>
            Gets a value indicating how many users are registered.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.AddRegistrant(`0,System.Int32@)">
            <summary>
            Add a new registrant.
            </summary>
            <param name="newRegistrant" type = "T">The registrant to add.</param>
            <param name="registrationID" type = "int">The ID assigned to the new registrant. Use this value when
            you wish to retrieve the registrant.</param>
            <displayName id = "AddRegistrant">AddRegistrant(T, out int)</displayName>
            <syntax>public void AddRegistrant(T newRegistrant, out int registrationID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.RemoveRegistrant(System.Int32)">
            <summary>
            Remove the registrant registered under registrationID.
            </summary>
            <param name="registrationID" type ="int">The ID of the registrant to remove.</param>
            <displayName id = "RemoveRegistrant">RemoveRegistrant(int)</displayName>
            <syntax>public void RemoveRegistrant(int registrationID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.RemoveAllRegistrants">
            <summary>
            Removes all registrants.
            </summary>
            <displayName id="RemoveAllRegistrants">
            RemoveAllRegistrants()
            </displayName>
            <syntax>
            public void RemoveAllRegistrants()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.GetAllRegistrants(System.Collections.Generic.List{`0})">
            <summary>
            Gets all the users Currently registered.
            </summary>
            <displayName id="GetAllRegistrants">GetAllRegistrants(List&lt;T&gt;)</displayName>
            <syntax>public void GetAllRegistrants(List&lt;T&gt; registrants)</syntax>
            <param name="registrants" type="List&lt;T&gt;">The list the registrants will be added to.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.GetAllRegistrantsOfType``1(System.Collections.Generic.List{``0})">
            <summary>
            Gets all the users Currently registered of the type U specified.
            </summary>
            <typeparam name="U">The specific type of the registrant to get. Must be or derive from T</typeparam>
            <param name="registrants" type="List&lt;U&gt;">The list to add the registrants to.</param>
            <displayName id="GetAllRegistrantsOfType">GetAllRegistrantsOfType&lt;U&gt;(List&lt;U&gt;)</displayName>
            <syntax>public void GetAllRegistrantsOfType&lt;U&gt;(List&lt;U&gt; registrants) where U : T</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.RegistrationHandler`1.RegistrantEntries">
            <summary>
            Gets an enumerable collection of registered users. This can be used in a foreach and does not generate garbage.
            </summary>
            <returns type="IEnumerable&lt;T&gt;">An enumerable collection of the registered users.</returns>
            <example>
            <code>
            class IterateOverRegistrantsExample
            {
                RegistrationHandler&lt;ActiveGrid&gt; activeGridUsers;
                
                public void Iterate()
                {
                    foreach(ActiveGrid activeGrid in activeGridUsers.RegistrantEntries())
                        activeGrid.DoSomething();
                }
            }
            </code>
            </example>
            <displayName id="RegistrantEntries">RegistrantEntries()</displayName>
            <syntax>public IEnumerable&lt;T&gt; RegistrantEntries()</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.BoundsDouble">
            <summary>
            A Bounds struct that can be used with double values. Exactly the same as the normal Bounds class, therefore refer to Unity documentation 
            for help with it!
            <para>
            It is missing the IntersectRay methods. Cast to Bounds if you need to use these!
            </para>
            <para>
            An implicit cast is implemented from Bounds to BoundsDouble. An explicit cast is implemented for BoundsDouble to Bounds.
            </para>
            </summary>
            <title>
            BoundsDouble Structure
            </title>
            <category>Structs</category>
            <navigationName>
            BoundsDouble
            </navigationName>
            <fileName>BoundsDouble.html</fileName>
            <syntax>
            public struct BoundsDouble
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BoundsDouble.ToString">
            *listonly*
        </member>
        <member name="T:DeepSpaceLabs.SAM.Cell">
            <summary>
            Represents a 2D or 3D cell. Set the layer to 1 if the cell is meant to be 2D
            </summary>
            <title>Cell Structure</title>
            <category>Structs</category>
            <navigationName>Cell</navigationName>
            <fileName>Cell.html</fileName>
            <syntax>public struct Cell : IEquatable&lt;Cell&gt;, IComparable&lt;Cell&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.Cell.Zero">
            <summary>
            A cell set to row/column/layer = 0. Provided for ease of use.
            </summary>
            <type>Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.Cell.One">
            <summary>
            A cell set to row/column/layer = 1. Provided for ease of use.
            </summary>
            <type>Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.Cell.NegativeOne">
            <summary>
            A cell set to row/column/layer = -1. Provided for ease of use.
            </summary>
            <type>Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.Cell.Item(System.Int32)">
            <summary>
            Indexer which Gets the row, column, or layer component of the cell by using an index (0 = row, 1 = columns, 2 = layer).
            <para>
            Use it like you'd use an array, i.e., int row = cell[0];
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the Cell structure.
            </summary>
            <param name="row" type="int">The row index of the cell.</param>
            <param name="column" type="int">The column index of the cell.</param>
            <param name="layer" type="int">The layer index of the cell. Only needed when the cell is associated with a three dimensional entity, otherwise just pass in 1.</param>
            <displayName id="Cell">Cell(int, int, int)</displayName>
            <syntax>public Cell(int row, int column, int layer)</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.Cell.Column">
            <summary>
            Gets the column index of the cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.Cell.Layer">
            <summary>
            Gets the layer index of the cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.Cell.Row">
            <summary>
            Gets the row index of the cell.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.WithNewRow(System.Int32)">
            <summary>
            Returns a copy of the Cell structure with all values the same except for the Row, which is replaced by the input newRow value.
            </summary>
            <param name="newRow" type="int">
            The new row value to use.
            </param>
            <returns type="Cell">
            The copy of this Cell structure with the new row value.
            </returns>
            <displayName id="WithNewRow">
            WithNewRow(int)
            </displayName>
            <syntax>
            public Cell WithNewRow(int newRow)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.WithNewColumn(System.Int32)">
            <summary>
            Returns a copy of the Cell structure with all values the same except for the Column, which is replaced by the input newColumn value.
            </summary>
            <param name="newColumn" type="int">
            The new column value to use.
            </param>
            <returns type="Cell">
            The copy of this Cell structure with the new column value.
            </returns>
            <displayName id="WithNewColumn">
            WithNewColumn(int)
            </displayName>
            <syntax>
            public Cell WithNewColumn(int newColumn)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.WithNewLayer(System.Int32)">
            <summary>
            Returns a copy of the Cell structure with all values the same except for the Layer, which is replaced by the input newLayer value.
            </summary>
            <param name="newLayer" type="int">
            The new layer value to use.
            </param>
            <returns type="Cell">
            The copy of this Cell structure with the new layer value.
            </returns>
            <displayName id="WithNewLayer">
            WithNewLayer(int)
            </displayName>
            <syntax>
            public Cell WithNewLayer(int newLayer)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.WithLayerAdjusted(System.Int32)">
            <summary>
            Returns a copy of the Cell structure with all values the same except for the Layer. The new layer value is equal to old layer value + layerAdjustment
            </summary>
            <param name="layerAdjustment" type="int">
            The adjustment to the layer (added to current layer value)
            </param>
            <returns type="Cell">
            The copy of this Cell structure with the new adjusted layer value
            </returns>
            <displayName id="WithLayerAdjusted">
            WithLayerAdjusted(int)
            </displayName>
            <syntax>
            public Cell WithLayerAdjusted(int layerAdjustment)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.WithRowAdjusted(System.Int32)">
            <summary>
            Returns a copy of the Cell structure with all values the same except for the Row. The new row value is equal to old row value + rowAdjustment
            </summary>
            <param name="rowAdjustment" type="int">
            The adjustment to the row (added to current row value)
            </param>
            <returns type="Cell">
            The copy of this Cell structure with the new adjusted row value
            </returns>
            <displayName id="WithRowAdjusted">
            WithRowAdjusted(int)
            </displayName>
            <syntax>
            public Cell WithRowAdjusted(int rowAdjustment)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.WithColumnAdjusted(System.Int32)">
            <summary>
            Returns a copy of the Cell structure with all values the same except for the Column. The new column value is equal to old column value + columnAdjustment
            </summary>
            <param name="columnAdjustment" type="int">
            The adjustment to the column (added to current column value)
            </param>
            <returns type="Cell">
            The copy of this Cell structure with the new adjusted column value
            </returns>
            <displayName id="WithColumnAdjusted">
            WithColumnAdjusted(int)
            </displayName>
            <syntax>
            public Cell WithColumnAdjusted(int layerAdjustment)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.ToString">
            <summary>
            Returns a nicely formatted string representation of the Cell's Indexes in the form of 
            Layer layer# | Row row# | Column column#
            </summary>
            <displayName id="ToString">ToString()</displayName>
            <syntax>public override string ToString()</syntax>
            <returns>A string representation of the Cell's Indexes.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.ToShortenedString">
            <summary>
            Returns a shortened formated string in the format of L layer# | R row# | C column#
            </summary>
            <displayName id="ToShortenedString">ToShortenedString()</displayName>
            <syntax>public string ToShortenedString()</syntax>
            <returns>A string representation of the Cell's Indexes.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_Addition(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            + operater implementation that allows you to add two cells together. Row is added to row, column to column, and 
            layer to layer from each cell.
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The first cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The second cell.
            </param>
            <returns type="Cell" link="Cell.html">
            The cell representing the addition of the two input cells.
            </returns>
            <displayName id="+ Operator">
            operator +(Cell, Cell)
            </displayName>
            <syntax>
            public static Cell operator +(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_Subtraction(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            - operater implementation that allows you to subtract one cell from another.
            <para>
            The row from the second cell is subtracted from the row of the first. The column from the column. The layer from the layer.
            </para>
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The first cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The second cell.
            </param>
            <returns type="Cell" link="Cell.html">
            The cell representing the subtraction of the second cell from the first
            </returns>
            <displayName id="- Operator">
            operator -(Cell, Cell)
            </displayName>
            <syntax>
            public static Cell operator -(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_Multiply(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            * operater implementation that allows you to multiple one cell by another.
            <para>
            The row from the second cell is multiplied by the row from the first. The column by the column. The layer by the layer.
            </para>
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The first cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The second cell.
            </param>
            <returns type="Cell" link="Cell.html">
            The cell representing the multiplication of the second cell by the first
            </returns>
            <displayName id="* Operator">
            operator *(Cell, Cell)
            </displayName>
            <syntax>
            public static Cell operator *(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_Division(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            / operater implementation that allows you to divide one cell by another.
            <para>
            The row from the numerator cell is divided by the row from the denominator cell (numerator/denominator). The column by the column. The layer by the layer.
            </para>
            </summary>
            <param name="numerator" type="Cell" link="Cell.html">
            The numerator cell.
            </param>
            <param name="denominator" type="Cell" link="Cell.html">
            The denominator cell.
            </param>
            <returns type="Cell" link="Cell.html">
            The cell representing the division of the numerator cell by the denominator cell. Uses integer division for each component of the Cell.
            </returns>
            <displayName id="/ Operator">
            operator /(Cell, Cell)
            </displayName>
            <syntax>
            public static Cell operator /(Cell numerator, Cell denominator)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_Equality(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            != operater implementation that allows you check if two cells are equal
            <para>
            The two cells will be equal if the rows, columns, or layers all match each other from one cell to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The first cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The second cell.
            </param>
            <returns type="bool">
            Returns true if the cells are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(Cell, Cell)
            </displayName>
            <syntax>
            public static bool operator ==(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_Inequality(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            != operater implementation that allows you check if two cells are not equal
            <para>
            The two cells will not be equal if the rows, columns, or layers do not match each other from one cell to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The first cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The second cell.
            </param>
            <returns type="bool">
            Returns true if the cells are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(Cell, Cell)
            </displayName>
            <syntax>
            public static bool operator !=(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_LessThan(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            &lt; operater implementation that allows you check if the left cell is less than the right cell.
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The left cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The right cell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.Cell.CompareTo(DeepSpaceLabs.SAM.Cell)" href="Cell.html#CompareTo">CompareTo</see> method documentation to understand 
            how cell comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(Cell, Cell)
            </displayName>
            <syntax>
            public static bool operator &lt;(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_LessThanOrEqual(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            &lt;= operater implementation that allows you check if the left cell is less than or equal to the right cell.
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The left cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The right cell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.Cell.CompareTo(DeepSpaceLabs.SAM.Cell)" href="Cell.html#CompareTo">CompareTo</see> method documentation to understand 
            how cell comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(Cell, Cell)
            </displayName>
            <syntax>
            public static bool operator &lt;=(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_GreaterThan(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            &gt; operater implementation that allows you check if the left cell is greater than the right cell.
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The left cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The right cell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.Cell.CompareTo(DeepSpaceLabs.SAM.Cell)" href="Cell.html#CompareTo">CompareTo</see> method documentation to understand 
            how cell comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(Cell, Cell)
            </displayName>
            <syntax>
            public static bool operator &gt;(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell)">
            <summary>
            &gt;= operater implementation that allows you check if the left cell is greater than or equal to the right cell.
            </summary>
            <param name="left" type="Cell" link="Cell.html">
            The left cell.
            </param>
            <param name="right" type="Cell" link="Cell.html">
            The right cell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.Cell.CompareTo(DeepSpaceLabs.SAM.Cell)" href="Cell.html#CompareTo">CompareTo</see> method documentation to understand 
            how cell comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(Cell, Cell)
            </displayName>
            <syntax>
            public static bool operator &gt;=(Cell left, Cell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input Cell to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this cell against.
            </param>
            <returns type="bool">
            false if the object is not a Cell or it is but the row, column, and/or layer value on 
            the obj is not equal to this cell's row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.GetHashCode">
            <summary>
            Returns a hash code for this cell. Uses all three indexes (row, column and layer) to compute it, 
            so the cell is treated as a 3D cell. Generally, it is better to use one of the 
            Cell Equality Comparers 
            (<see cref="T:DeepSpaceLabs.SAM.TwoDimensionalCellComparer" href="TwoDimensionalCellComparer.html">TwoDimensionalCellComparer</see> or 
            <see cref="T:DeepSpaceLabs.SAM.ThreeDimensionalCellComparer" href="ThreeDimensionalCellComparer.html">ThreeDimensionalCellComparer</see>), 
            as you determine if the cells are 2D or 3D at runtime and configure the correct type of comparer.
            </summary>
            <returns type="int">
            The hash code of the cell, calculated using all three fields (row, column, and layer).
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.Equals(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Implementation of IEquatable&lt;Cell&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a 
            <see cref="T:DeepSpaceLabs.SAM.TwoDimensionalCellComparer" href="TwoDimensionalCellComparer.html">TwoDimensionalCellComparer</see> 
            for comparison, which will ignore the layer for comparison and hash code generation.
            </para>
            </summary>
            <param name="other" type="object">
            The other cell to compare this cell against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other Cell is not equal to this cell's row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(Cell)
            </displayName>
            <syntax>
            public bool Equals(Cell other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Cell.CompareTo(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Compares the input cell against this cell to determine whether this cell procedes, follows, or is at the same 
            position of the input cell. This can be used to order a collection of cells in the same manner as they 
            would appear in the scene (if they were associated with World Cells, that is). 
            The method utilizes the row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other cell to compare this cell against.
            </param>
            <returns type="int">
            -1 if this cell precedes (is less than) the input "other" cell, +1 if this cell follows (is greater than) 
            the input "other" cell, and 0 if the cells are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the layer of the two cells is compared. If this cell's 
            layer is less than the input cell's layer, -1 is returned. If this cell's layer is greater than the input cell's layer, 
            +1 is returned. If the two have the same layer value, the row is compared in the same manner. If the rows are the same, 
            the columns are compared. If the columns are compared, 0 is returned as the two cell's are equal and have the same placement 
            in the order.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(Cell)
            </displayName>
            <syntax>
            public int CompareTo(Cell other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.CellLong">
            <summary>
            Represents a 2D or 3D cell. Similar to 
            <see cref="T:DeepSpaceLabs.SAM.Cell" href="Cell.html">Cell</see> but it uses longs to store the indices. Set the layer to 1 if the cell is meant to be 2D.
            <para>
            This struct is mainly used by editor code and is not really intended to be used by users, however you can use it if you wish. In most cases, 
            however, you will need to cast the CellLong to a Cell in order to interact with the SAM API, so using the CellLong structure just results 
            in more memory being used without any gain.
            </para>
            </summary>
            <title>CellLong Structure</title>
            <category>Structs</category>
            <navigationName>CellLong</navigationName>
            <fileName>CellLong.html</fileName>
            <syntax>public struct CellLong : IEquatable&lt;CellLong&gt;, IComparable&lt;CellLong&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.CellLong.Zero">
            <summary>
            A CellLong set to row/column/layer = 0. Provided for ease of use.
            </summary>
            <type>CellLong</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.CellLong.One">
            <summary>
            A CellLong set to row/column/layer = 1. Provided for ease of use.
            </summary>
            <type>CellLong</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellLong.Item(System.Int32)">
            <summary>
            Indexer which Gets the row, column, or layer component of the CellLong by using an index (0 = row, 1 = columns, 2 = layer).
            <para>
            Use it like you'd use an array, i.e., long row = CellLong[0];
            </para>
            </summary>
            <type>long</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.#ctor(System.Int64,System.Int64,System.Int64)">
            <summary>
            Initializes a new instance of the CellLong structure.
            </summary>
            <param name="row" type="long">The row index of the CellLong.</param>
            <param name="column" type="long">The column index of the CellLong.</param>
            <param name="layer" type="long">The layer index of the CellLong. Only needed when the CellLong is associated with a three dimensional entity, otherwise just pass in 1.</param>
            <displayName id="CellLong">CellLong(long, long, long)</displayName>
            <syntax>public CellLong(long row, long column, long layer)</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellLong.Column">
            <summary>
            Gets the column index of the CellLong.
            </summary>
            <type>long</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellLong.Layer">
            <summary>
            Gets the layer index of the CellLong.
            </summary>
            <type>long</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellLong.Row">
            <summary>
            Gets the row index of the CellLong.
            </summary>
            <type>long</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.WithNewRow(System.Int64)">
            <summary>
            Returns a copy of the CellLong structure with all values the same except for the Row, which is replaced by the input newRow value.
            </summary>
            <param name="newRow" type="long">
            The new row value to use.
            </param>
            <returns type="CellLong">
            The copy of this CellLong structure with the new row value.
            </returns>
            <displayName id="WithNewRow">
            WithNewRow(long)
            </displayName>
            <syntax>
            public CellLong WithNewRow(long newRow)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.WithNewColumn(System.Int64)">
            <summary>
            Returns a copy of the CellLong structure with all values the same except for the Column, which is replaced by the input newColumn value.
            </summary>
            <param name="newColumn" type="long">
            The new column value to use.
            </param>
            <returns type="CellLong">
            The copy of this CellLong structure with the new column value.
            </returns>
            <displayName id="WithNewColumn">
            WithNewColumn(long)
            </displayName>
            <syntax>
            public CellLong WithNewColumn(long newColumn)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.WithNewLayer(System.Int64)">
            <summary>
            Returns a copy of the CellLong structure with all values the same except for the Layer, which is replaced by the input newLayer value.
            </summary>
            <param name="newLayer" type="long">
            The new layer value to use.
            </param>
            <returns type="CellLong">
            The copy of this CellLong structure with the new layer value.
            </returns>
            <displayName id="WithNewLayer">
            WithNewLayer(long)
            </displayName>
            <syntax>
            public CellLong WithNewLayer(long newLayer)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.WithLayerAdjusted(System.Int64)">
            <summary>
            Returns a copy of the CellLong structure with all values the same except for the Layer. The new layer value is equal to old layer value + layerAdjustment
            </summary>
            <param name="layerAdjustment" type="long">
            The adjustment to the layer (added to current layer value)
            </param>
            <returns type="CellLong">
            The copy of this CellLong structure with the new adjusted layer value
            </returns>
            <displayName id="WithLayerAdjusted">
            WithLayerAdjusted(long)
            </displayName>
            <syntax>
            public CellLong WithLayerAdjusted(long layerAdjustment)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.WithRowAdjusted(System.Int64)">
            <summary>
            Returns a copy of the CellLong structure with all values the same except for the Row. The new row value is equal to old row value + rowAdjustment
            </summary>
            <param name="rowAdjustment" type="long">
            The adjustment to the row (added to current row value)
            </param>
            <returns type="CellLong">
            The copy of this CellLong structure with the new adjusted row value
            </returns>
            <displayName id="WithRowAdjusted">
            WithRowAdjusted(long)
            </displayName>
            <syntax>
            public CellLong WithRowAdjusted(long rowAdjustment)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.WithColumnAdjusted(System.Int64)">
            <summary>
            Returns a copy of the CellLong structure with all values the same except for the Column. The new column value is equal to old column value + columnAdjustment
            </summary>
            <param name="columnAdjustment" type="long">
            The adjustment to the column (added to current column value)
            </param>
            <returns type="CellLong">
            The copy of this CellLong structure with the new adjusted column value
            </returns>
            <displayName id="WithColumnAdjusted">
            WithColumnAdjusted(long)
            </displayName>
            <syntax>
            public CellLong WithColumnAdjusted(long layerAdjustment)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.ToString">
            <summary>
            Returns a nicely formatted string representation of the CellLong's Indexes.
            </summary>
            <displayName id="ToString">ToString()</displayName>
            <syntax>public override string ToString()</syntax>
            <returns>A string representation of the CellLong's Indexes.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Addition(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            + operater implementation that allows you to add two CellLongs together. Row is added to row, column to column, and 
            layer to layer from each CellLong.
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The first CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The second CellLong.
            </param>
            <returns type="CellLong" link="CellLong.html">
            The CellLong representing the addition of the two input CellLongs.
            </returns>
            <displayName id="+ Operator">
            operator +(CellLong, CellLong)
            </displayName>
            <syntax>
            public static CellLong operator +(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Subtraction(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            - operater implementation that allows you to subtract one CellLong from another.
            <para>
            The row from the second CellLong is subtracted from the row of the first. The column from the column. The layer from the layer.
            </para>
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The first CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The second CellLong.
            </param>
            <returns type="CellLong" link="CellLong.html">
            The CellLong representing the subtraction of the second CellLong from the first
            </returns>
            <displayName id="- Operator">
            operator -(CellLong, CellLong)
            </displayName>
            <syntax>
            public static CellLong operator -(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Multiply(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            * operater implementation that allows you to multiple one CellLong by another.
            <para>
            The row from the second CellLong is multiplied by the row from the first. The column by the column. The layer by the layer.
            </para>
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The first CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The second CellLong.
            </param>
            <returns type="CellLong" link="CellLong.html">
            The CellLong representing the multiplication of the second CellLong by the first
            </returns>
            <displayName id="* Operator">
            operator *(CellLong, CellLong)
            </displayName>
            <syntax>
            public static CellLong operator *(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Division(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            / operater implementation that allows you to divide one CellLong by another.
            <para>
            The row from the numerator CellLong is divided by the row from the denominator CellLong (numerator/denominator). The column by the column. The layer by the layer.
            </para>
            </summary>
            <param name="numerator" type="CellLong" link="CellLong.html">
            The numerator CellLong.
            </param>
            <param name="denominator" type="CellLong" link="CellLong.html">
            The denominator CellLong.
            </param>
            <returns type="CellLong" link="CellLong.html">
            The CellLong representing the division of the numerator CellLong by the denominator CellLong. Uses longeger division for each component of the CellLong.
            </returns>
            <displayName id="/ Operator">
            operator /(CellLong, CellLong)
            </displayName>
            <syntax>
            public static CellLong operator /(CellLong numerator, CellLong denominator)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Equality(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            != operater implementation that allows you check if two CellLongs are equal
            <para>
            The two CellLongs will be equal if the rows, columns, or layers all match each other from one CellLong to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The first CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The second CellLong.
            </param>
            <returns type="bool">
            Returns true if the CellLongs are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(CellLong, CellLong)
            </displayName>
            <syntax>
            public static bool operator ==(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Inequality(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            != operater implementation that allows you check if two CellLongs are not equal
            <para>
            The two CellLongs will not be equal if the rows, columns, or layers do not match each other from one CellLong to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The first CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The second CellLong.
            </param>
            <returns type="bool">
            Returns true if the CellLongs are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(CellLong, CellLong)
            </displayName>
            <syntax>
            public static bool operator !=(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_LessThan(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            &lt; operater implementation that allows you check if the left CellLong is less than the right CellLong.
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The left CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The right CellLong.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellLong.CompareTo(DeepSpaceLabs.SAM.CellLong)" href="CellLong.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellLong comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(CellLong, CellLong)
            </displayName>
            <syntax>
            public static bool operator &lt;(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_LessThanOrEqual(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            &lt;= operater implementation that allows you check if the left CellLong is less than or equal to the right CellLong.
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The left CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The right CellLong.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellLong.CompareTo(DeepSpaceLabs.SAM.CellLong)" href="CellLong.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellLong comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(CellLong, CellLong)
            </displayName>
            <syntax>
            public static bool operator &lt;=(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_GreaterThan(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            &gt; operater implementation that allows you check if the left CellLong is greater than the right CellLong.
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The left CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The right CellLong.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellLong.CompareTo(DeepSpaceLabs.SAM.CellLong)" href="CellLong.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellLong comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(CellLong, CellLong)
            </displayName>
            <syntax>
            public static bool operator &gt;(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.CellLong,DeepSpaceLabs.SAM.CellLong)">
            <summary>
            &gt;= operater implementation that allows you check if the left CellLong is greater than or equal to the right CellLong.
            </summary>
            <param name="left" type="CellLong" link="CellLong.html">
            The left CellLong.
            </param>
            <param name="right" type="CellLong" link="CellLong.html">
            The right CellLong.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellLong.CompareTo(DeepSpaceLabs.SAM.CellLong)" href="CellLong.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellLong comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(CellLong, CellLong)
            </displayName>
            <syntax>
            public static bool operator &gt;=(CellLong left, CellLong right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input CellLong to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this CellLong against.
            </param>
            <returns type="bool">
            false if the object is not a CellLong or it is but the row, column, and/or layer value on 
            the obj is not equal to this CellLong's row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.GetHashCode">
            <summary>
            Returns a hash code for this CellLong. Uses all three indexes (row, column and layer) to compute it.
            </summary>
            <returns type="int">
            The hash code of the CellLong, calculated using all three fields (row, column, and layer).
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.Equals(DeepSpaceLabs.SAM.CellLong)">
            <summary>
            Implementation of IEquatable&lt;CellLong&gt;.Equals method. Use this, as it does not box input struct.
            </summary>
            <param name="other" type="object">
            The other CellLong to compare this CellLong against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other CellLong is not equal to this CellLong's row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(CellLong)
            </displayName>
            <syntax>
            public bool Equals(CellLong other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.CompareTo(DeepSpaceLabs.SAM.CellLong)">
            <summary>
            Compares the input CellLong against this CellLong to determine whether this CellLong procedes, follows, or is at the same 
            position of the input CellLong. This can be used to order a collection of CellLongs in the same manner as they 
            would appear in the scene (if they were associated with World CellLongs, that is). 
            The method utilizes the row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other CellLong to compare this CellLong against.
            </param>
            <returns type="int">
            -1 if this CellLong precedes (is less than) the input "other" CellLong, +1 if this CellLong follows (is greater than) 
            the input "other" CellLong, and 0 if the CellLongs are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the layer of the two CellLongs is compared. If this CellLong's 
            layer is less than the input CellLong's layer, -1 is returned. If this CellLong's layer is greater than the input CellLong's layer, 
            +1 is returned. If the two have the same layer value, the row is compared in the same manner. If the rows are the same, 
            the columns are compared. If the columns are compared, 0 is returned as the two CellLong's are equal and have the same placement 
            in the order.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(CellLong)
            </displayName>
            <syntax>
            public int CompareTo(CellLong other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Explicit(DeepSpaceLabs.SAM.CellLong)~DeepSpaceLabs.SAM.Cell">
            <summary>
            Exlicit conversion from CellLong to Cell.
            </summary>
            <param name="cellLong">The cell long to convert.</param>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellLong.op_Implicit(DeepSpaceLabs.SAM.Cell)~DeepSpaceLabs.SAM.CellLong">
            <summary>
            Implict conversion from Cell to CellLong
            </summary>
            <param name="cell">The cell to convert.</param>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkCell">
            <summary>
            Represents a cell with an additional chunk index. Useful for dictionaries and other such collections that need to store something per chunk rather than 
            per cell.
            </summary>
            <title>ChunkCell Structure</title>
            <category>Structs</category>
            <navigationName>ChunkCell</navigationName>
            <fileName>ChunkCell.html</fileName>
            <syntax>public struct ChunkCell : IEquatable&lt;ChunkCell&gt;, IComparable&lt;ChunkCell&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkCell.Cell">
            <summary>
            The actual Cell this struct details.
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkCell.ChunkIndex">
            <summary>
            The chunk index of the ChunkCell.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.#ctor(DeepSpaceLabs.SAM.Cell,System.Int32)">
            <summary>
            Initializes a new instance of the ChunkCell structure.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">The cell of the ChunkCell.</param>
            <param name="chunkIndex" type="int">The chunk index of the ChunkCell.</param>
            <displayName id="ChunkCell">ChunkCell(Cell, int)</displayName>
            <syntax>public ChunkCell(Cell cell, int chunkIndex)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.op_Equality(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            != operater implementation that allows you check if two ChunkCells are equal
            <para>
            The two ChunkCells will be equal if the ChunkIndex, rows, columns, or layers all match each other from one ChunkCell to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="ChunkCell" link="ChunkCell.html">
            The first ChunkCell.
            </param>
            <param name="right" type="ChunkCell" link="ChunkCell.html">
            The second ChunkCell.
            </param>
            <returns type="bool">
            Returns true if the ChunkCells are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public static bool operator ==(ChunkCell left, ChunkCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.op_Inequality(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            != operater implementation that allows you check if two ChunkCells are not equal
            <para>
            The two ChunkCells will not be equal if the ChunkIndex, rows, columns, or layers do not match each other from one ChunkCell to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="ChunkCell" link="ChunkCell.html">
            The first ChunkCell.
            </param>
            <param name="right" type="ChunkCell" link="ChunkCell.html">
            The second ChunkCell.
            </param>
            <returns type="bool">
            Returns true if the ChunkCells are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public static bool operator !=(ChunkCell left, ChunkCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.op_LessThan(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            &lt; operater implementation that allows you check if the left ChunkCell is less than the right ChunkCell.
            to determine 
            </summary>
            <param name="left" type="ChunkCell" link="ChunkCell.html">
            The left ChunkCell.
            </param>
            <param name="right" type="ChunkCell" link="ChunkCell.html">
            The right ChunkCell.
            </param>
            <returns type="bool">
            The Cell value takes priority, that is 
            if the Cell value of left is less than the Cell value of right, true is returned. If the cell value of left is 
            greater than the Cell value of right, false is returned. If the Cell values are equal, ChunkIndex is used. If ChunkIndex of left is less than 
            ChunkIndex of right, true is returned. Otherwise false is returned.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public static bool operator &lt;(ChunkCell left, ChunkCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.op_LessThanOrEqual(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            &lt;= operater implementation that allows you check if the left ChunkCell is less than or equal to the right ChunkCell.
            </summary>
            <param name="left" type="ChunkCell" link="ChunkCell.html">
            The left ChunkCell.
            </param>
            <param name="right" type="ChunkCell" link="ChunkCell.html">
            The right ChunkCell.
            </param>
            <returns type="bool">
            The Cell value takes priority, that is 
            if the Cell value of left is less than the Cell value of right, true is returned. If the cell value of left is 
            greater than the Cell value of right, false is returned. If the Cell values are equal, ChunkIndex is used. If ChunkIndex of left is less than or 
            equal to ChunkIndex of right, true is returned. Otherwise false is returned.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public static bool operator &lt;=(ChunkCell left, ChunkCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.op_GreaterThan(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            &gt; operater implementation that allows you check if the left ChunkCell is greater than the right ChunkCell.
            </summary>
            <param name="left" type="ChunkCell" link="ChunkCell.html">
            The left ChunkCell.
            </param>
            <param name="right" type="ChunkCell" link="ChunkCell.html">
            The right ChunkCell.
            </param>
            <returns type="bool">
            The Cell value takes priority, that is 
            if the Cell value of left is greater than the Cell value of right, true is returned. If the cell value of left is 
            less than the Cell value of right, false is returned. If the Cell values are equal, ChunkIndex is used. If ChunkIndex of left is greater than 
            ChunkIndex of right, true is returned. Otherwise false is returned.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public static bool operator &gt;(ChunkCell left, ChunkCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.ChunkCell,DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            &gt;= operater implementation that allows you check if the left ChunkCell is greater than or equal to the right ChunkCell.
            </summary>
            <param name="left" type="ChunkCell" link="ChunkCell.html">
            The left ChunkCell.
            </param>
            <param name="right" type="ChunkCell" link="ChunkCell.html">
            The right ChunkCell.
            </param>
            <returns type="bool">
            The Cell value takes priority, that is 
            if the Cell value of left is greater than the Cell value of right, true is returned. If the cell value of left is 
            less than the Cell value of right, false is returned. If the Cell values are equal, ChunkIndex is used. If ChunkIndex of left is greater than or 
            equal to ChunkIndex of right, true is returned. Otherwise false is returned.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(ChunkCell, ChunkCell)
            </displayName>
            <syntax>
            public static bool operator &gt;=(ChunkCell left, ChunkCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input ChunkCell to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this ChunkCell against.
            </param>
            <returns type="bool">
            false if the object is not a ChunkCell or it is but the ChunkIndex, row, column, and/or layer value on 
            the obj is not equal to this ChunkCell's ChunkIndex, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.GetHashCode">
            <summary>
            Returns a hash code for this ChunkCell. Uses all three indexes (row, column and layer) + the ChunkIndex to compute it, 
            so the ChunkCell is treated as a 3D ChunkCell. You could also create a custom EqualityComparer that only utilizes 
            the row, column, and ChunkIndex, if you know that you do not need the layer value.
            </summary>
            <returns type="int">
            The hash code of the ChunkCell, calculated using all four fields (ChunkIndex, row, column, and layer).
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.Equals(DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            Implementation of IEquatable&lt;ChunkCell&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the ChunkIndex, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom ChunkCell EqualityComparer 
            that ignores the layer.
            </para>
            </summary>
            <param name="other" type="object">
            The other ChunkCell to compare this ChunkCell against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other ChunkCell is not equal to this ChunkCell's ChunkIndex, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(ChunkCell)
            </displayName>
            <syntax>
            public bool Equals(ChunkCell other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkCell.CompareTo(DeepSpaceLabs.SAM.ChunkCell)">
            <summary>
            Compares the input ChunkCell against this ChunkCell to determine whether this ChunkCell procedes, follows, or is at the same 
            position of the input ChunkCell. This can be used to order a collection of ChunkCells.
            The method utilizes the ChunkIndex, row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other ChunkCell to compare this ChunkCell against.
            </param>
            <returns type="int">
            -1 if this ChunkCell precedes (is less than) the input "other" ChunkCell, +1 if this ChunkCell follows (is greater than) 
            the input "other" ChunkCell, and 0 if the ChunkCells are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the Cell value of the two ChunkCell's is compared. If this cell's Cell value is 
            less than the Cell value of the input cell, -1 is returned. If it is greater, +1 is returned. If they are the same, then the 
            ChunkIndex value is copared in the same manner. If this ChunkCell's 
            ChunkIndex is less than the input ChunkCell's ChunkIndex, -1 is returned. If this ChunkCell's ChunkIndex is greater than the input ChunkCell's ChunkIndex, 
            +1 is returned. If the two have the same ChunkIndex value, 0 is returned.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(ChunkCell)
            </displayName>
            <syntax>
            public int CompareTo(ChunkCell other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InRangeZone">
            <summary>
            Represents an In Range Zone. Contains the index of the Zone, as well as the repeated World 
            indicies of the Zone.
            </summary>
            <title>InRangeZone Structure</title>
            <category>Structs</category>
            <navigationName>InRangeZone</navigationName>
            <fileName>InRangeZone.html</fileName>
            <syntax>public struct InRangeZone : IEquatable&lt;InRangeZone&gt;, IComparable&lt;InRangeZone&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZone.WorldRepetitionIndices">
            <summary>
            Index of the Zone Grouping in relation to the Repeated World. This is needed when working with Endless/Repeating Worlds. A value of 0 for an index 
            indicates that that index is within the confines of the original (non repeated) World. A value of 1 would indicate that index falls into the 
            next greatest repetition of the World on that indices axis, 2 would be the next one after that, and so on. Negative values are also possible.
            <para>
            Each index (Row, Column, Layer) might have a different value, since the player can traverse each axis idependently and may have travelled 
            further on one axis than another.
            </para>
            <para>
            When retrieving Zone Groupings In Range of a position, if using a repeating/endless World, it's possible for the same Zone Grouping to be 
            included multiple times. In these cases, the WorldIndex value will be different for each Zone Grouping. When this occurs, it indicates 
            that a Zone Grouping is in range in multiple iterations of the repeated World (generally, this should not happen, but it is theoretically possible).
            </para>
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZone.ZoneIndex">
            <summary>
            The index of the Zone.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZone.AllZoneGroupingsGauranteedToBeInRange">
            <summary>
            The zone's bounding volume encompasses all Zone Groupings that a zone contains. The min position of this bounding volume will always be 
            equal to the min position of each Zone Grouping, as all Zone Groupings have the same min position. However, each Zone Grouping can have a variable 
            size, which means they can end at different positions in the game world. The Zone's bounding volme max position is thus equal to the position of the 
            largest Zone Grouping, however this means the max position of the bounding volume does not accurately reflect the max position of all Zone Groupings.
            <para>
            When the reference position's components (x, y, and z) are all smaller than the zone's bounding volume min position, we can provide a gaurantee that 
            all Zone Groupings in the zone are within range of the reference position. And that case, this value will be true. In all other cases, this value 
            will be false, and you will need to perform a more precise distance check for the individual Zone Grouping to make sure it is actually in range 
            of the reference position.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZone.DistanceOfZoneFromPosition">
            <summary>
            The distance between the Zoen and the position it was tested against.
            </summary>
            <type>double</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZone.ZonePosition">
            <summary>
            The position of the Zone in the scene, defined as the min point of the zone.
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.#ctor(DeepSpaceLabs.SAM.Cell,System.Int32,System.Boolean,System.Double,DeepSpaceLabs.SAM.Vector3Double)">
            <summary>
            Initializes a new instance of the InRangeZone structure.
            </summary>
            <param name="repeatedWorldIndices" type="Cell" link="Cell.html">Tells you which repeated World this Zone Grouping is a part of on each axis (if using 
            and endless/repeating World).</param>
            <param name="zoneIndex" type="int">The index of the Zone.</param>
            <param name="allZoneGroupingsGauranteedToBeInRange" type="bool">
            The zone's bounding volume encompasses all Zone Groupings that a zone contains. The min position of this bounding volume will always be 
            equal to the min position of each Zone Grouping, as all Zone Groupings have the same min position. However, each Zone Grouping can have a variable 
            size, which means they can end at different positions in the game world. The Zone's bounding volme max position is thus equal to the position of the 
            largest Zone Grouping, however this means the max position of the bounding volume does not accurately reflect the max position of all Zone Groupings.
            <para>
            When the reference position's components (x, y, and z) are all smaller than the zone's bounding volume min position, we can provide a gaurantee that 
            all Zone Groupings in the zone are within range of the reference position. And that case, this value will be true. In all other cases, this value 
            will be false, and you will need to perform a more precise distance check for the individual Zone Grouping to make sure it is actually in range 
            of the reference position.
            </para>
            </param>
            <param name="distanceOfZoneFromPosition" type="double">
            The distance between the Zoen and the position it was tested against.
            </param>
            <param name="zonePosition" type="Vector3Double" link="Vector3Double.html">
            The position of the Zone in the scene, defined as the min point of the zone.
            </param>
            <displayName id="InRangeZone">InRangeZone(Cell, int)</displayName>
            <syntax>public InRangeZone(Cell repeatedWorldIndices, int zoneIndex, int groupingIndex)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.op_Equality(DeepSpaceLabs.SAM.InRangeZone,DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            != operater implementation that allows you check if two InRangeZones are equal
            <para>
            The two InRangeZones will be equal if the ZoneIndex, WorldGroupingIndex, rows, columns, or layers all match each other from one InRangeZone to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="InRangeZone" link="InRangeZone.html">
            The first InRangeZone.
            </param>
            <param name="right" type="InRangeZone" link="InRangeZone.html">
            The second InRangeZone.
            </param>
            <returns type="bool">
            Returns true if the InRangeZones are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(InRangeZone, InRangeZone)
            </displayName>
            <syntax>
            public static bool operator ==(InRangeZone left, InRangeZone right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.op_Inequality(DeepSpaceLabs.SAM.InRangeZone,DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            != operater implementation that allows you check if two InRangeZones are not equal
            <para>
            The two InRangeZones will not be equal if the ZoneIndex, WorldGroupingIndex, rows, columns, or 
            layers do not match each other from one InRangeZone to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="InRangeZone" link="InRangeZone.html">
            The first InRangeZone.
            </param>
            <param name="right" type="InRangeZone" link="InRangeZone.html">
            The second InRangeZone.
            </param>
            <returns type="bool">
            Returns true if the InRangeZones are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(InRangeZone, InRangeZone)
            </displayName>
            <syntax>
            public static bool operator !=(InRangeZone left, InRangeZone right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.op_LessThan(DeepSpaceLabs.SAM.InRangeZone,DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            &lt; operater implementation that allows you check if the left InRangeZone is less than the right InRangeZone.
            </summary>
            <param name="left" type="InRangeZone" link="InRangeZone.html">
            The left InRangeZone.
            </param>
            <param name="right" type="InRangeZone" link="InRangeZone.html">
            The right InRangeZone.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZone.CompareTo(DeepSpaceLabs.SAM.InRangeZone)" href="InRangeZone.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZone comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(InRangeZone, InRangeZone)
            </displayName>
            <syntax>
            public static bool operator &lt;(InRangeZone left, InRangeZone right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.op_LessThanOrEqual(DeepSpaceLabs.SAM.InRangeZone,DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            &lt;= operater implementation that allows you check if the left InRangeZone is less than or equal to the right InRangeZone.
            </summary>
            <param name="left" type="InRangeZone" link="InRangeZone.html">
            The left InRangeZone.
            </param>
            <param name="right" type="InRangeZone" link="InRangeZone.html">
            The right InRangeZone.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZone.CompareTo(DeepSpaceLabs.SAM.InRangeZone)" href="InRangeZone.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZone comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(InRangeZone, InRangeZone)
            </displayName>
            <syntax>
            public static bool operator &lt;=(InRangeZone left, InRangeZone right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.op_GreaterThan(DeepSpaceLabs.SAM.InRangeZone,DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            &gt; operater implementation that allows you check if the left InRangeZone is greater than the right InRangeZone.
            </summary>
            <param name="left" type="InRangeZone" link="InRangeZone.html">
            The left InRangeZone.
            </param>
            <param name="right" type="InRangeZone" link="InRangeZone.html">
            The right InRangeZone.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZone.CompareTo(DeepSpaceLabs.SAM.InRangeZone)" href="InRangeZone.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZone comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(InRangeZone, InRangeZone)
            </displayName>
            <syntax>
            public static bool operator &gt;(InRangeZone left, InRangeZone right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.InRangeZone,DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            &gt;= operater implementation that allows you check if the left InRangeZone is greater than or equal to the right InRangeZone.
            </summary>
            <param name="left" type="InRangeZone" link="InRangeZone.html">
            The left InRangeZone.
            </param>
            <param name="right" type="InRangeZone" link="InRangeZone.html">
            The right InRangeZone.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZone.CompareTo(DeepSpaceLabs.SAM.InRangeZone)" href="InRangeZone.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZone comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(InRangeZone, InRangeZone)
            </displayName>
            <syntax>
            public static bool operator &gt;=(InRangeZone left, InRangeZone right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input InRangeZone to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this InRangeZone against.
            </param>
            <returns type="bool">
            false if the object is not a InRangeZone or it is but the ZoneIndex, WorldGroupingIndex, row, column, and/or layer value on 
            the obj is not equal to this InRangeZone's ZoneIndex, WorldGroupingIndex, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.GetHashCode">
            <summary>
            Returns a hash code for this InRangeZone. Uses all six indexes (WorldGroupingIndex, Row, Column and Layer) to compute it, 
            so the InRangeZone is treated as a 3D InRangeZone.
            </summary>
            <returns type="int">
            The hash code of the InRangeZone.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.Equals(DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            Implementation of IEquatable&lt;InRangeZone&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the ZoneIndex, WorldGroupingIndex, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom InRangeZone EqualityComparer 
            that ignores the layer
            </para>
            </summary>
            <param name="other" type="object">
            The other InRangeZone to compare this InRangeZone against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other InRangeZone is not equal to this InRangeZone's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(InRangeZone)
            </displayName>
            <syntax>
            public bool Equals(InRangeZone other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZone.CompareTo(DeepSpaceLabs.SAM.InRangeZone)">
            <summary>
            Compares the input InRangeZone against this InRangeZone to determine whether this InRangeZone procedes, follows, or is at the same 
            position of the input InRangeZone. This can be used to order a collection of InRangeZones in the same manner as they 
            would appear in the scene (if they were associated with World InRangeZones, that is). 
            The method utilizes the row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other InRangeZone to compare this InRangeZone against.
            </param>
            <returns type="int">
            -1 if this InRangeZone precedes (is less than) the input "other" InRangeZone, +1 if this InRangeZone follows (is greater than) 
            the input "other" InRangeZone, and 0 if the InRangeZones are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the ZoneIndex of the two cell's is compared. If this cell's 
            ZoneIndex is less than the input cell's ZoneIndex, -1 is returned. If it is greater than the input cell's 
            ZoneIndex, +1 is returned. If they are equal, the WorldGroupingIndex is compared in the same way. Then the Cell Layer, 
            Cell Row, and finally Cell Column. 0 is returned if all values are the same.
            </para>
            <para>
            An important thing to note is lower World Groupings (which are actually probably more important) will be before higher World Groupings. 
            As such, they are considered less than the higher World Grouping cells.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(InRangeZone)
            </displayName>
            <syntax>
            public int CompareTo(InRangeZone other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InRangeZoneGrouping">
            <summary>
            Represents an In Range Zone Grouping. Contains the index of the Zone/World Grouping that the ZoneGrouping belongs to, as well as the repeated World 
            indicies of the Zone Grouping.
            </summary>
            <title>InRangeZoneGrouping Structure</title>
            <category>Structs</category>
            <navigationName>InRangeZoneGrouping</navigationName>
            <fileName>InRangeZoneGrouping.html</fileName>
            <syntax>public struct InRangeZoneGrouping : IEquatable&lt;InRangeZoneGrouping&gt;, IComparable&lt;InRangeZoneGrouping&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZoneGrouping.RepeatedWorldIndices">
            <summary>
            Index of the Zone Grouping in relation to the Repeated World. This is needed when working with Endless/Repeating Worlds. A value of 0 for an index 
            indicates that that index is within the confines of the original (non repeated) World. A value of 1 would indicate that index falls into the 
            next greatest repetition of the World on that indices axis, 2 would be the next one after that, and so on. Negative values are also possible.
            <para>
            Each index (Row, Column, Layer) might have a different value, since the player can traverse each axis idependently and may have travelled 
            further on one axis than another.
            </para>
            <para>
            When retrieving Zone Groupings In Range of a position, if using a repeating/endless World, it's possible for the same Zone Grouping to be 
            included multiple times. In these cases, the WorldIndex value will be different for each Zone Grouping. When this occurs, it indicates 
            that a Zone Grouping is in range in multiple iterations of the repeated World (generally, this should not happen, but it is theoretically possible).
            </para>
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZoneGrouping.ZoneIndex">
            <summary>
            The index of the Zone that the Zone Grouping is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InRangeZoneGrouping.WorldGroupingIndex">
            <summary>
            The index of the World Grouping that the Zone Grouping is associated with.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.#ctor(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the InRangeZoneGrouping structure.
            </summary>
            <param name="repeatedWorldIndices" type="Cell" link="Cell.html">Tells you which repeated World this Zone Grouping is a part of on each axis (if using 
            and endless/repeating World).</param>
            <param name="zoneIndex" type="int">The index of the Zone that the Zone Grouping is associated with.</param>
            <param name="groupingIndex" type="int">The index of the World Grouping that the Zone Grouping is associated with.</param>
            <displayName id="InRangeZoneGrouping">InRangeZoneGrouping(Cell, int, int)</displayName>
            <syntax>public InRangeZoneGrouping(Cell repeatedWorldIndices, int zoneIndex, int groupingIndex)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.op_Equality(DeepSpaceLabs.SAM.InRangeZoneGrouping,DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            != operater implementation that allows you check if two InRangeZoneGroupings are equal
            <para>
            The two InRangeZoneGroupings will be equal if the ZoneIndex, WorldGroupingIndex, rows, columns, or layers all match each other from one InRangeZoneGrouping to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The first InRangeZoneGrouping.
            </param>
            <param name="right" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The second InRangeZoneGrouping.
            </param>
            <returns type="bool">
            Returns true if the InRangeZoneGroupings are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(InRangeZoneGrouping, InRangeZoneGrouping)
            </displayName>
            <syntax>
            public static bool operator ==(InRangeZoneGrouping left, InRangeZoneGrouping right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.op_Inequality(DeepSpaceLabs.SAM.InRangeZoneGrouping,DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            != operater implementation that allows you check if two InRangeZoneGroupings are not equal
            <para>
            The two InRangeZoneGroupings will not be equal if the ZoneIndex, WorldGroupingIndex, rows, columns, or 
            layers do not match each other from one InRangeZoneGrouping to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The first InRangeZoneGrouping.
            </param>
            <param name="right" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The second InRangeZoneGrouping.
            </param>
            <returns type="bool">
            Returns true if the InRangeZoneGroupings are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(InRangeZoneGrouping, InRangeZoneGrouping)
            </displayName>
            <syntax>
            public static bool operator !=(InRangeZoneGrouping left, InRangeZoneGrouping right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.op_LessThan(DeepSpaceLabs.SAM.InRangeZoneGrouping,DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            &lt; operater implementation that allows you check if the left InRangeZoneGrouping is less than the right InRangeZoneGrouping.
            </summary>
            <param name="left" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The left InRangeZoneGrouping.
            </param>
            <param name="right" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The right InRangeZoneGrouping.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.CompareTo(DeepSpaceLabs.SAM.InRangeZoneGrouping)" href="InRangeZoneGrouping.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZoneGrouping comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(InRangeZoneGrouping, InRangeZoneGrouping)
            </displayName>
            <syntax>
            public static bool operator &lt;(InRangeZoneGrouping left, InRangeZoneGrouping right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.op_LessThanOrEqual(DeepSpaceLabs.SAM.InRangeZoneGrouping,DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            &lt;= operater implementation that allows you check if the left InRangeZoneGrouping is less than or equal to the right InRangeZoneGrouping.
            </summary>
            <param name="left" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The left InRangeZoneGrouping.
            </param>
            <param name="right" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The right InRangeZoneGrouping.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.CompareTo(DeepSpaceLabs.SAM.InRangeZoneGrouping)" href="InRangeZoneGrouping.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZoneGrouping comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(InRangeZoneGrouping, InRangeZoneGrouping)
            </displayName>
            <syntax>
            public static bool operator &lt;=(InRangeZoneGrouping left, InRangeZoneGrouping right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.op_GreaterThan(DeepSpaceLabs.SAM.InRangeZoneGrouping,DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            &gt; operater implementation that allows you check if the left InRangeZoneGrouping is greater than the right InRangeZoneGrouping.
            </summary>
            <param name="left" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The left InRangeZoneGrouping.
            </param>
            <param name="right" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The right InRangeZoneGrouping.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.CompareTo(DeepSpaceLabs.SAM.InRangeZoneGrouping)" href="InRangeZoneGrouping.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZoneGrouping comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(InRangeZoneGrouping, InRangeZoneGrouping)
            </displayName>
            <syntax>
            public static bool operator &gt;(InRangeZoneGrouping left, InRangeZoneGrouping right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.InRangeZoneGrouping,DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            &gt;= operater implementation that allows you check if the left InRangeZoneGrouping is greater than or equal to the right InRangeZoneGrouping.
            </summary>
            <param name="left" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The left InRangeZoneGrouping.
            </param>
            <param name="right" type="InRangeZoneGrouping" link="InRangeZoneGrouping.html">
            The right InRangeZoneGrouping.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.CompareTo(DeepSpaceLabs.SAM.InRangeZoneGrouping)" href="InRangeZoneGrouping.html#CompareTo">CompareTo</see> method documentation to understand 
            how InRangeZoneGrouping comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(InRangeZoneGrouping, InRangeZoneGrouping)
            </displayName>
            <syntax>
            public static bool operator &gt;=(InRangeZoneGrouping left, InRangeZoneGrouping right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input InRangeZoneGrouping to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this InRangeZoneGrouping against.
            </param>
            <returns type="bool">
            false if the object is not a InRangeZoneGrouping or it is but the ZoneIndex, WorldGroupingIndex, row, column, and/or layer value on 
            the obj is not equal to this InRangeZoneGrouping's ZoneIndex, WorldGroupingIndex, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.GetHashCode">
            <summary>
            Returns a hash code for this InRangeZoneGrouping. Uses all six indexes (WorldGroupingIndex, Row, Column and Layer) to compute it, 
            so the InRangeZoneGrouping is treated as a 3D InRangeZoneGrouping.
            </summary>
            <returns type="int">
            The hash code of the InRangeZoneGrouping.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.Equals(DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            Implementation of IEquatable&lt;InRangeZoneGrouping&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the ZoneIndex, WorldGroupingIndex, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom InRangeZoneGrouping EqualityComparer 
            that ignores the layer
            </para>
            </summary>
            <param name="other" type="object">
            The other InRangeZoneGrouping to compare this InRangeZoneGrouping against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other InRangeZoneGrouping is not equal to this InRangeZoneGrouping's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(InRangeZoneGrouping)
            </displayName>
            <syntax>
            public bool Equals(InRangeZoneGrouping other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.InRangeZoneGrouping.CompareTo(DeepSpaceLabs.SAM.InRangeZoneGrouping)">
            <summary>
            Compares the input InRangeZoneGrouping against this InRangeZoneGrouping to determine whether this InRangeZoneGrouping procedes, follows, or is at the same 
            position of the input InRangeZoneGrouping. This can be used to order a collection of InRangeZoneGroupings in the same manner as they 
            would appear in the scene (if they were associated with World InRangeZoneGroupings, that is). 
            The method utilizes the row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other InRangeZoneGrouping to compare this InRangeZoneGrouping against.
            </param>
            <returns type="int">
            -1 if this InRangeZoneGrouping precedes (is less than) the input "other" InRangeZoneGrouping, +1 if this InRangeZoneGrouping follows (is greater than) 
            the input "other" InRangeZoneGrouping, and 0 if the InRangeZoneGroupings are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the ZoneIndex of the two cell's is compared. If this cell's 
            ZoneIndex is less than the input cell's ZoneIndex, -1 is returned. If it is greater than the input cell's 
            ZoneIndex, +1 is returned. If they are equal, the WorldGroupingIndex is compared in the same way. Then the Cell Layer, 
            Cell Row, and finally Cell Column. 0 is returned if all values are the same.
            </para>
            <para>
            An important thing to note is lower World Groupings (which are actually probably more important) will be before higher World Groupings. 
            As such, they are considered less than the higher World Grouping cells.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(InRangeZoneGrouping)
            </displayName>
            <syntax>
            public int CompareTo(InRangeZoneGrouping other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LODCell">
            <summary>
            Represents a cell with an LOD.
            </summary>
            <title>LODCell Structure</title>
            <category>Structs</category>
            <navigationName>LODCell</navigationName>
            <fileName>LODCell.html</fileName>
            <syntax>public struct LODCell : IEquatable&lt;LODCell&gt;, IComparable&lt;LODCell&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LODCell.Cell">
            <summary>
            The actual Cell this struct details.
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LODCell.LOD">
            <summary>
            The LOD of the LODCell.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.#ctor(DeepSpaceLabs.SAM.Cell,System.Int32)">
            <summary>
            Initializes a new instance of the LODCell structure.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">The cell of the LODCell.</param>
            <param name="lod" type="int">The LOD of the LODCell.</param>
            <displayName id="LODCell">LODCell(Cell, int)</displayName>
            <syntax>public LODCell(Cell cell, int lod)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.op_Equality(DeepSpaceLabs.SAM.LODCell,DeepSpaceLabs.SAM.LODCell)">
            <summary>
            != operater implementation that allows you check if two LODCells are equal
            <para>
            The two LODCells will be equal if the LOD, rows, columns, or layers all match each other from one LODCell to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="LODCell" link="LODCell.html">
            The first LODCell.
            </param>
            <param name="right" type="LODCell" link="LODCell.html">
            The second LODCell.
            </param>
            <returns type="bool">
            Returns true if the LODCells are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(LODCell, LODCell)
            </displayName>
            <syntax>
            public static bool operator ==(LODCell left, LODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.op_Inequality(DeepSpaceLabs.SAM.LODCell,DeepSpaceLabs.SAM.LODCell)">
            <summary>
            != operater implementation that allows you check if two LODCells are not equal
            <para>
            The two LODCells will not be equal if the LOD, rows, columns, or layers do not match each other from one LODCell to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="LODCell" link="LODCell.html">
            The first LODCell.
            </param>
            <param name="right" type="LODCell" link="LODCell.html">
            The second LODCell.
            </param>
            <returns type="bool">
            Returns true if the LODCells are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(LODCell, LODCell)
            </displayName>
            <syntax>
            public static bool operator !=(LODCell left, LODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.op_LessThan(DeepSpaceLabs.SAM.LODCell,DeepSpaceLabs.SAM.LODCell)">
            <summary>
            &lt; operater implementation that allows you check if the left LODCell is less than the right LODCell.
            </summary>
            <param name="left" type="LODCell" link="LODCell.html">
            The left LODCell.
            </param>
            <param name="right" type="LODCell" link="LODCell.html">
            The right LODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.LODCell.CompareTo(DeepSpaceLabs.SAM.LODCell)" href="LODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how LODCell comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(LODCell, LODCell)
            </displayName>
            <syntax>
            public static bool operator &lt;(LODCell left, LODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.op_LessThanOrEqual(DeepSpaceLabs.SAM.LODCell,DeepSpaceLabs.SAM.LODCell)">
            <summary>
            &lt;= operater implementation that allows you check if the left LODCell is less than or equal to the right LODCell.
            </summary>
            <param name="left" type="LODCell" link="LODCell.html">
            The left LODCell.
            </param>
            <param name="right" type="LODCell" link="LODCell.html">
            The right LODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.LODCell.CompareTo(DeepSpaceLabs.SAM.LODCell)" href="LODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how LODCell comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(LODCell, LODCell)
            </displayName>
            <syntax>
            public static bool operator &lt;=(LODCell left, LODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.op_GreaterThan(DeepSpaceLabs.SAM.LODCell,DeepSpaceLabs.SAM.LODCell)">
            <summary>
            &gt; operater implementation that allows you check if the left LODCell is greater than the right LODCell.
            </summary>
            <param name="left" type="LODCell" link="LODCell.html">
            The left LODCell.
            </param>
            <param name="right" type="LODCell" link="LODCell.html">
            The right LODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.LODCell.CompareTo(DeepSpaceLabs.SAM.LODCell)" href="LODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how LODCell comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(LODCell, LODCell)
            </displayName>
            <syntax>
            public static bool operator &gt;(LODCell left, LODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.LODCell,DeepSpaceLabs.SAM.LODCell)">
            <summary>
            &gt;= operater implementation that allows you check if the left LODCell is greater than or equal to the right LODCell.
            </summary>
            <param name="left" type="LODCell" link="LODCell.html">
            The left LODCell.
            </param>
            <param name="right" type="LODCell" link="LODCell.html">
            The right LODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.LODCell.CompareTo(DeepSpaceLabs.SAM.LODCell)" href="LODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how LODCell comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(LODCell, LODCell)
            </displayName>
            <syntax>
            public static bool operator &gt;=(LODCell left, LODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input LODCell to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this LODCell against.
            </param>
            <returns type="bool">
            false if the object is not a LODCell or it is but the LOD, row, column, and/or layer value on 
            the obj is not equal to this LODCell's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.GetHashCode">
            <summary>
            Returns a hash code for this LODCell. Uses all three indexes (row, column and layer) + the LOD to compute it, 
            so the LODCell is treated as a 3D LODCell. You could also create a custom EqualityComparer that only utilizes 
            the row, column, and LOD, if you know that you do not need the layer value.
            </summary>
            <returns type="int">
            The hash code of the LODCell, calculated using all four fields (LOD, row, column, and layer).
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.Equals(DeepSpaceLabs.SAM.LODCell)">
            <summary>
            Implementation of IEquatable&lt;LODCell&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the LOD, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom LODCell EqualityComparer 
            that ignores the layer
            </para>
            </summary>
            <param name="other" type="object">
            The other LODCell to compare this LODCell against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other LODCell is not equal to this LODCell's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(LODCell)
            </displayName>
            <syntax>
            public bool Equals(LODCell other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.LODCell.CompareTo(DeepSpaceLabs.SAM.LODCell)">
            <summary>
            Compares the input LODCell against this LODCell to determine whether this LODCell procedes, follows, or is at the same 
            position of the input LODCell. This can be used to order a collection of LODCells in the same manner as they 
            would appear in the scene (if they were associated with World LODCells, that is). 
            The method utilizes the LOD, row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other LODCell to compare this LODCell against.
            </param>
            <returns type="int">
            -1 if this LODCell precedes (is less than) the input "other" LODCell, +1 if this LODCell follows (is greater than) 
            the input "other" LODCell, and 0 if the LODCells are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the LOD of the two LODCell's is compared. If this cell's LOD value is 
            less than the LOD value of the input cell, -1 is returned. If it is greater, +1 is returned. If they are the same, then the 
            Layer value is copared in the same manner. If this LODCell's 
            layer is less than the input LODCell's layer, -1 is returned. If this LODCell's layer is greater than the input LODCell's layer, 
            +1 is returned. If the two have the same layer value, the row is compared in the same manner. If the rows are the same, 
            the columns are compared. If the columns are compared, 0 is returned as the two LODCell's are equal and have the same placement 
            in the order.
            </para>
            <para>
            An important thing to note is that higher quality LODs (which have a smaller value) will precede lower quality LODs. However, this 
            also means that according to SAM, LODCell's with higher quality LODs are less than LODCell's with lower quality LODs.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(LODCell)
            </displayName>
            <syntax>
            public int CompareTo(LODCell other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TimingData">
            <summary>
            A class that holds timing info (in milliseconds). The timing info is an average of 1 or more timing samples, and can be retrieved 
            using the <see cref="M:DeepSpaceLabs.SAM.TimingData.GetAvgTime" href="TimingData.html#GetAvgTime">GetAvgTime</see> method.
            <para>
            Timing Info is calculated and managed by Chunk Streamers (all of the built in Chunk Streamers 
            make use of this info) and the ConditionalMembers class, however only within the editor and Development Builds (for performance 
            reasons).
            </para>
            </summary>
            <title>TimingData Structure</title>
            <category>Structs</category>
            <navigationName>TimingData</navigationName>
            <fileName>TimingData.html</fileName>
            <syntax>
            public struct TimingData
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TimingData.Samples">
            <summary>
            The number of samples in the data. More samples means the data is more accurate.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimingData.GetAvgTime">
            <summary>
            Gets the average sample time of the data, in milliseconds.
            </summary>
            <displayName id="GetAvgTime">
            GetAvgTime()
            </displayName>
            <syntax>
            public double GetAvgTime()
            </syntax>
            <returns type="double">
            The average sample time, in milliseconds.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TimingData.AddSample(System.Double)">
            <summary>
            Adds a sample to the timing data and returns a new TimingData instance that holds the data. Necessary because the TimingData is a 
            struct, and this way you can be assured to have accurate data.
            </summary>
            <param name="newSampleTime" type="double">The new sample time.</param>
            <returns type="TimingData" link="TimingData.html">The new TimingData instance.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ZoneGroupingCell">
            <summary>
            Represents a cell on a Zone Grouping. In addition to regular cell indexes, contains the index of the Zone/World Grouping that the cell belongs to.
            </summary>
            <title>ZoneGroupingCell Structure</title>
            <category>Structs</category>
            <navigationName>ZoneGroupingCell</navigationName>
            <fileName>ZoneGroupingCell.html</fileName>
            <syntax>public struct ZoneGroupingCell : IEquatable&lt;ZoneGroupingLODCell&gt;, IComparable&lt;ZoneGroupingLODCell&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingCell.Cell">
            <summary>
            The actual Cell this struct details.
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingCell.ZoneIndex">
            <summary>
            The index of the Zone that this cell is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingCell.WorldGroupingIndex">
            <summary>
            The index of the World Grouping that this cell is associated with.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.#ctor(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the ZoneGroupingCell structure.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">The cell of the ZoneGroupingCell.</param>
            <param name="zoneIndex" type="int">The index of the Zone that this cell is associated with.</param>
            <param name="groupingIndex" type="int">The index of the World Grouping that this cell is associated with.</param>
            <displayName id="ZoneGroupingCell">ZoneGroupingCell(Cell, int, int)</displayName>
            <syntax>public ZoneGroupingCell(Cell cell, int zoneIndex, int groupingIndex)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.op_Equality(DeepSpaceLabs.SAM.ZoneGroupingCell,DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            != operater implementation that allows you check if two ZoneGroupingCells are equal
            <para>
            The two ZoneGroupingCells will be equal if the ZoneIndex, WorldGroupingIndex, rows, columns, or layers all match each other from one ZoneGroupingCell to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The first ZoneGroupingCell.
            </param>
            <param name="right" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The second ZoneGroupingCell.
            </param>
            <returns type="bool">
            Returns true if the ZoneGroupingCells are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(ZoneGroupingCell, ZoneGroupingCell)
            </displayName>
            <syntax>
            public static bool operator ==(ZoneGroupingCell left, ZoneGroupingCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.op_Inequality(DeepSpaceLabs.SAM.ZoneGroupingCell,DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            != operater implementation that allows you check if two ZoneGroupingCells are not equal
            <para>
            The two ZoneGroupingCells will not be equal if the ZoneIndex, WorldGroupingIndex, rows, columns, or 
            layers do not match each other from one ZoneGroupingCell to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The first ZoneGroupingCell.
            </param>
            <param name="right" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The second ZoneGroupingCell.
            </param>
            <returns type="bool">
            Returns true if the ZoneGroupingCells are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(ZoneGroupingCell, ZoneGroupingCell)
            </displayName>
            <syntax>
            public static bool operator !=(ZoneGroupingCell left, ZoneGroupingCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.op_LessThan(DeepSpaceLabs.SAM.ZoneGroupingCell,DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            &lt; operater implementation that allows you check if the left ZoneGroupingCell is less than the right ZoneGroupingCell.
            </summary>
            <param name="left" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The left ZoneGroupingCell.
            </param>
            <param name="right" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The right ZoneGroupingCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingCell)" href="ZoneGroupingCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingCell comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(ZoneGroupingCell, ZoneGroupingCell)
            </displayName>
            <syntax>
            public static bool operator &lt;(ZoneGroupingCell left, ZoneGroupingCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.op_LessThanOrEqual(DeepSpaceLabs.SAM.ZoneGroupingCell,DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            &lt;= operater implementation that allows you check if the left ZoneGroupingCell is less than or equal to the right ZoneGroupingCell.
            </summary>
            <param name="left" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The left ZoneGroupingCell.
            </param>
            <param name="right" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The right ZoneGroupingCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingCell)" href="ZoneGroupingCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingCell comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(ZoneGroupingCell, ZoneGroupingCell)
            </displayName>
            <syntax>
            public static bool operator &lt;=(ZoneGroupingCell left, ZoneGroupingCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.op_GreaterThan(DeepSpaceLabs.SAM.ZoneGroupingCell,DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            &gt; operater implementation that allows you check if the left ZoneGroupingCell is greater than the right ZoneGroupingCell.
            </summary>
            <param name="left" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The left ZoneGroupingCell.
            </param>
            <param name="right" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The right ZoneGroupingCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingCell)" href="ZoneGroupingCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingCell comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(ZoneGroupingCell, ZoneGroupingCell)
            </displayName>
            <syntax>
            public static bool operator &gt;(ZoneGroupingCell left, ZoneGroupingCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.ZoneGroupingCell,DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            &gt;= operater implementation that allows you check if the left ZoneGroupingCell is greater than or equal to the right ZoneGroupingCell.
            </summary>
            <param name="left" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The left ZoneGroupingCell.
            </param>
            <param name="right" type="ZoneGroupingCell" link="ZoneGroupingCell.html">
            The right ZoneGroupingCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingCell)" href="ZoneGroupingCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingCell comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(ZoneGroupingCell, ZoneGroupingCell)
            </displayName>
            <syntax>
            public static bool operator &gt;=(ZoneGroupingCell left, ZoneGroupingCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input ZoneGroupingCell to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this ZoneGroupingCell against.
            </param>
            <returns type="bool">
            false if the object is not a ZoneGroupingCell or it is but the ZoneIndex, WorldGroupingIndex, row, column, and/or layer value on 
            the obj is not equal to this ZoneGroupingCell's ZoneIndex, WorldGroupingIndex, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.GetHashCode">
            <summary>
            Returns a hash code for this ZoneGroupingCell. Uses all six indexes (WorldGroupingIndex, Row, Column and Layer) to compute it, 
            so the ZoneGroupingCell is treated as a 3D ZoneGroupingCell.
            </summary>
            <returns type="int">
            The hash code of the ZoneGroupingCell.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.Equals(DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            Implementation of IEquatable&lt;ZoneGroupingCell&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the ZoneIndex, WorldGroupingIndex, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom ZoneGroupingCell EqualityComparer 
            that ignores the layer
            </para>
            </summary>
            <param name="other" type="object">
            The other ZoneGroupingCell to compare this ZoneGroupingCell against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other ZoneGroupingCell is not equal to this ZoneGroupingCell's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(ZoneGroupingCell)
            </displayName>
            <syntax>
            public bool Equals(ZoneGroupingCell other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingCell)">
            <summary>
            Compares the input ZoneGroupingCell against this ZoneGroupingCell to determine whether this ZoneGroupingCell procedes, follows, or is at the same 
            position of the input ZoneGroupingCell. This can be used to order a collection of ZoneGroupingCells in the same manner as they 
            would appear in the scene (if they were associated with World ZoneGroupingCells, that is). 
            The method utilizes the row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other ZoneGroupingCell to compare this ZoneGroupingCell against.
            </param>
            <returns type="int">
            -1 if this ZoneGroupingCell precedes (is less than) the input "other" ZoneGroupingCell, +1 if this ZoneGroupingCell follows (is greater than) 
            the input "other" ZoneGroupingCell, and 0 if the ZoneGroupingCells are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the ZoneIndex of the two cell's is compared. If this cell's 
            ZoneIndex is less than the input cell's ZoneIndex, -1 is returned. If it is greater than the input cell's 
            ZoneIndex, +1 is returned. If they are equal, the WorldGroupingIndex is compared in the same way. Then the Cell Layer, 
            Cell Row, and finally Cell Column. 0 is returned if all values are the same.
            </para>
            <para>
            An important thing to note is lower World Groupings (which are actually probably more important) will be before higher World Groupings. 
            As such, they are considered less than the higher World Grouping cells.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(ZoneGroupingCell)
            </displayName>
            <syntax>
            public int CompareTo(ZoneGroupingCell other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ZoneGroupingLODCell">
            <summary>
            Represents a LOD cell on a Zone Grouping. In addition to regular cell indexes, contains the LOD and index of the Zone/World Grouping that the cell belongs to.
            </summary>
            <title>ZoneGroupingLODCell Structure</title>
            <category>Structs</category>
            <navigationName>ZoneGroupingLODCell</navigationName>
            <fileName>ZoneGroupingLODCell.html</fileName>
            <syntax>public struct ZoneGroupingLODCell : IEquatable&lt;ZoneGroupingLODCell&gt;, IComparable&lt;ZoneGroupingLODCell&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingLODCell.LODCell">
            <summary>
            The LOD Cell of the ZoneGroupingLODCell. Contains the LOD and Cell values.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingLODCell.ZoneIndex">
            <summary>
            The index of the Zone that this cell is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingLODCell.WorldGroupingIndex">
            <summary>
            The index of the World Grouping that this cell is associated with.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.#ctor(DeepSpaceLabs.SAM.LODCell,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the ZoneGroupingLODCell structure.
            </summary>
            <param name="lodCell" type="LODCell" link="LODCell.html">The LOD Cell of the ZoneGroupingLODCell. Contains the LOD and Cell values.</param>
            <param name="zoneIndex" type="int">The index of the Zone that this cell is associated with.</param>
            <param name="groupingIndex" type="int">The index of the World Grouping that this cell is associated with.</param>
            <displayName id="ZoneGroupingLODCell">ZoneGroupingLODCell(LODCell, int, int)</displayName>
            <syntax>public ZoneGroupingLODCell(LODCell lodCell, int zoneIndex, int groupingIndex)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.op_Equality(DeepSpaceLabs.SAM.ZoneGroupingLODCell,DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            != operater implementation that allows you check if two ZoneGroupingLODCells are equal
            <para>
            The two ZoneGroupingLODCells will be equal if the ZoneIndex, WorldGroupingIndex, LOD, rows, columns, or layers all match each other from one ZoneGroupingLODCell to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The first ZoneGroupingLODCell.
            </param>
            <param name="right" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The second ZoneGroupingLODCell.
            </param>
            <returns type="bool">
            Returns true if the ZoneGroupingLODCells are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(ZoneGroupingLODCell, ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public static bool operator ==(ZoneGroupingLODCell left, ZoneGroupingLODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.op_Inequality(DeepSpaceLabs.SAM.ZoneGroupingLODCell,DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            != operater implementation that allows you check if two ZoneGroupingLODCells are not equal
            <para>
            The two ZoneGroupingLODCells will not be equal if the ZoneIndex, WorldGroupingIndex, LOD, rows, columns, or 
            layers do not match each other from one ZoneGroupingLODCell to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The first ZoneGroupingLODCell.
            </param>
            <param name="right" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The second ZoneGroupingLODCell.
            </param>
            <returns type="bool">
            Returns true if the ZoneGroupingLODCells are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(ZoneGroupingLODCell, ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public static bool operator !=(ZoneGroupingLODCell left, ZoneGroupingLODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.op_LessThan(DeepSpaceLabs.SAM.ZoneGroupingLODCell,DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            &lt; operater implementation that allows you check if the left ZoneGroupingLODCell is less than the right ZoneGroupingLODCell.
            </summary>
            <param name="left" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The left ZoneGroupingLODCell.
            </param>
            <param name="right" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The right ZoneGroupingLODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingLODCell)" href="ZoneGroupingLODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingLODCell comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(ZoneGroupingLODCell, ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public static bool operator &lt;(ZoneGroupingLODCell left, ZoneGroupingLODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.op_LessThanOrEqual(DeepSpaceLabs.SAM.ZoneGroupingLODCell,DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            &lt;= operater implementation that allows you check if the left ZoneGroupingLODCell is less than or equal to the right ZoneGroupingLODCell.
            </summary>
            <param name="left" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The left ZoneGroupingLODCell.
            </param>
            <param name="right" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The right ZoneGroupingLODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingLODCell)" href="ZoneGroupingLODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingLODCell comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(ZoneGroupingLODCell, ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public static bool operator &lt;=(ZoneGroupingLODCell left, ZoneGroupingLODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.op_GreaterThan(DeepSpaceLabs.SAM.ZoneGroupingLODCell,DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            &gt; operater implementation that allows you check if the left ZoneGroupingLODCell is greater than the right ZoneGroupingLODCell.
            </summary>
            <param name="left" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The left ZoneGroupingLODCell.
            </param>
            <param name="right" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The right ZoneGroupingLODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingLODCell)" href="ZoneGroupingLODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingLODCell comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(ZoneGroupingLODCell, ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public static bool operator &gt;(ZoneGroupingLODCell left, ZoneGroupingLODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.ZoneGroupingLODCell,DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            &gt;= operater implementation that allows you check if the left ZoneGroupingLODCell is greater than or equal to the right ZoneGroupingLODCell.
            </summary>
            <param name="left" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The left ZoneGroupingLODCell.
            </param>
            <param name="right" type="ZoneGroupingLODCell" link="ZoneGroupingLODCell.html">
            The right ZoneGroupingLODCell.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingLODCell)" href="ZoneGroupingLODCell.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingLODCell comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(ZoneGroupingLODCell, ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public static bool operator &gt;=(ZoneGroupingLODCell left, ZoneGroupingLODCell right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input ZoneGroupingLODCell to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this ZoneGroupingLODCell against.
            </param>
            <returns type="bool">
            false if the object is not a ZoneGroupingLODCell or it is but the ZoneIndex, WorldGroupingIndex, LOD, row, column, and/or layer value on 
            the obj is not equal to this ZoneGroupingLODCell's ZoneIndex, WorldGroupingIndex, LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.GetHashCode">
            <summary>
            Returns a hash code for this ZoneGroupingLODCell. Uses all six indexes (WorldGroupingIndex, LOD, Row, Column and Layer) to compute it, 
            so the ZoneGroupingLODCell is treated as a 3D ZoneGroupingLODCell.
            </summary>
            <returns type="int">
            The hash code of the ZoneGroupingLODCell.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.Equals(DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            Implementation of IEquatable&lt;ZoneGroupingLODCell&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the ZoneIndex, WorldGroupingIndex, LOD, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom ZoneGroupingLODCell EqualityComparer 
            that ignores the layer
            </para>
            </summary>
            <param name="other" type="object">
            The other ZoneGroupingLODCell to compare this ZoneGroupingLODCell against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other ZoneGroupingLODCell is not equal to this ZoneGroupingLODCell's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public bool Equals(ZoneGroupingLODCell other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingLODCell.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingLODCell)">
            <summary>
            Compares the input ZoneGroupingLODCell against this ZoneGroupingLODCell to determine whether this ZoneGroupingLODCell procedes, follows, or is at the same 
            position of the input ZoneGroupingLODCell. This can be used to order a collection of ZoneGroupingLODCells in the same manner as they 
            would appear in the scene (if they were associated with World ZoneGroupingLODCells, that is). 
            The method utilizes the LOD, row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other ZoneGroupingLODCell to compare this ZoneGroupingLODCell against.
            </param>
            <returns type="int">
            -1 if this ZoneGroupingLODCell precedes (is less than) the input "other" ZoneGroupingLODCell, +1 if this ZoneGroupingLODCell follows (is greater than) 
            the input "other" ZoneGroupingLODCell, and 0 if the ZoneGroupingLODCells are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the ZoneIndex of the two cell's is compared. If this cell's 
            ZoneIndex is less than the input cell's ZoneIndex, -1 is returned. If it is greater than the input cell's 
            ZoneIndex, +1 is returned. If they are equal, the WorldGroupingIndex is compared in the same way. Then the LOD values, following be the Cell Layer, 
            Cell Row, and finally Cell Column. 0 is returned if all values are the same.
            </para>
            <para>
            An important thing to note is that higher quality LODs (which have a smaller value) will precede lower quality LODs. However, this 
            also means that according to SAM, ZoneGroupingLODCell's with higher quality LODs are less than ZoneGroupingLODCell's with lower quality LODs. In addition, 
            lower World Groupings (which are actually probably more important) will be before higher World Groupings. As such, they are considered less 
            than the higher World Grouping cells.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(ZoneGroupingLODCell)
            </displayName>
            <syntax>
            public int CompareTo(ZoneGroupingLODCell other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ZoneGroupingChunk">
            <summary>
            Represents an asset chunk that is part of a Zone Grouping. In addition to regular cell indexes, contains the LOD and index of the Zone/World Grouping that the cell belongs to, as well as the assetChunkIndex of the asset chunk.
            </summary>
            <title>ZoneGroupingChunk Structure</title>
            <category>Structs</category>
            <navigationName>ZoneGroupingChunk</navigationName>
            <fileName>ZoneGroupingChunk.html</fileName>
            <syntax>public struct ZoneGroupingChunk : IEquatable&lt;ZoneGroupingChunk&gt;, IComparable&lt;ZoneGroupingChunk&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingChunk.Cell">
            <summary>
            The actual Cell this struct details.
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingChunk.ZoneIndex">
            <summary>
            The index of the Zone that this chunk is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingChunk.WorldGroupingIndex">
            <summary>
            The index of the World Grouping that this chunk is associated with.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingChunk.LOD">
            <summary>
            The LOD of the ZoneGroupingChunk.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ZoneGroupingChunk.AssetChunkIndex">
            <summary>
            The index of the asset chunk in relation to other asset chunks associated with the World Cell.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.#ctor(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the ZoneGroupingChunk structure.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">The cell of the ZoneGroupingChunk.</param>
            <param name="zoneIndex" type="int">The index of the Zone that this cell is associated with.</param>
            <param name="groupingIndex" type="int">The index of the World Grouping that this cell is associated with.</param>
            <param name="lod" type="int">The LOD of the ZoneGroupingChunk.</param>
            <param name="assetChunkIndex" type="int">The index of the asset chunk in relation to other asset chunks associated with the World Cell.</param>
            <displayName id="ZoneGroupingChunk">ZoneGroupingChunk(Cell, int, int, int)</displayName>
            <syntax>public ZoneGroupingChunk(Cell cell, int zoneIndex, int groupingIndex, int lod)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.op_Equality(DeepSpaceLabs.SAM.ZoneGroupingChunk,DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            != operater implementation that allows you check if two ZoneGroupingChunks are equal
            <para>
            The two ZoneGroupingChunks will be equal if the ZoneIndex, WorldGroupingIndex, LOD, rows, columns, or layers all match each other from one ZoneGroupingChunk to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The first ZoneGroupingChunk.
            </param>
            <param name="right" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The second ZoneGroupingChunk.
            </param>
            <returns type="bool">
            Returns true if the ZoneGroupingChunks are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(ZoneGroupingChunk, ZoneGroupingChunk)
            </displayName>
            <syntax>
            public static bool operator ==(ZoneGroupingChunk left, ZoneGroupingChunk right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.op_Inequality(DeepSpaceLabs.SAM.ZoneGroupingChunk,DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            != operater implementation that allows you check if two ZoneGroupingChunks are not equal
            <para>
            The two ZoneGroupingChunks will not be equal if the ZoneIndex, WorldGroupingIndex, LOD, rows, columns, or 
            layers do not match each other from one ZoneGroupingChunk to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The first ZoneGroupingChunk.
            </param>
            <param name="right" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The second ZoneGroupingChunk.
            </param>
            <returns type="bool">
            Returns true if the ZoneGroupingChunks are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(ZoneGroupingChunk, ZoneGroupingChunk)
            </displayName>
            <syntax>
            public static bool operator !=(ZoneGroupingChunk left, ZoneGroupingChunk right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.op_LessThan(DeepSpaceLabs.SAM.ZoneGroupingChunk,DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            &lt; operater implementation that allows you check if the left ZoneGroupingChunk is less than the right ZoneGroupingChunk.
            </summary>
            <param name="left" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The left ZoneGroupingChunk.
            </param>
            <param name="right" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The right ZoneGroupingChunk.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingChunk)" href="ZoneGroupingChunk.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingChunk comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(ZoneGroupingChunk, ZoneGroupingChunk)
            </displayName>
            <syntax>
            public static bool operator &lt;(ZoneGroupingChunk left, ZoneGroupingChunk right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.op_LessThanOrEqual(DeepSpaceLabs.SAM.ZoneGroupingChunk,DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            &lt;= operater implementation that allows you check if the left ZoneGroupingChunk is less than or equal to the right ZoneGroupingChunk.
            </summary>
            <param name="left" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The left ZoneGroupingChunk.
            </param>
            <param name="right" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The right ZoneGroupingChunk.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingChunk)" href="ZoneGroupingChunk.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingChunk comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(ZoneGroupingChunk, ZoneGroupingChunk)
            </displayName>
            <syntax>
            public static bool operator &lt;=(ZoneGroupingChunk left, ZoneGroupingChunk right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.op_GreaterThan(DeepSpaceLabs.SAM.ZoneGroupingChunk,DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            &gt; operater implementation that allows you check if the left ZoneGroupingChunk is greater than the right ZoneGroupingChunk.
            </summary>
            <param name="left" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The left ZoneGroupingChunk.
            </param>
            <param name="right" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The right ZoneGroupingChunk.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingChunk)" href="ZoneGroupingChunk.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingChunk comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(ZoneGroupingChunk, ZoneGroupingChunk)
            </displayName>
            <syntax>
            public static bool operator &gt;(ZoneGroupingChunk left, ZoneGroupingChunk right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.ZoneGroupingChunk,DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            &gt;= operater implementation that allows you check if the left ZoneGroupingChunk is greater than or equal to the right ZoneGroupingChunk.
            </summary>
            <param name="left" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The left ZoneGroupingChunk.
            </param>
            <param name="right" type="ZoneGroupingChunk" link="ZoneGroupingChunk.html">
            The right ZoneGroupingChunk.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingChunk)" href="ZoneGroupingChunk.html#CompareTo">CompareTo</see> method documentation to understand 
            how ZoneGroupingChunk comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(ZoneGroupingChunk, ZoneGroupingChunk)
            </displayName>
            <syntax>
            public static bool operator &gt;=(ZoneGroupingChunk left, ZoneGroupingChunk right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input ZoneGroupingChunk to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this ZoneGroupingChunk against.
            </param>
            <returns type="bool">
            false if the object is not a ZoneGroupingChunk or it is but the ZoneIndex, WorldGroupingIndex, LOD, AssetChunkIndex, row, column, and/or layer value on 
            the obj is not equal to this ZoneGroupingChunk's ZoneIndex, WorldGroupingIndex, LOD, AssetChunkIndex, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.GetHashCode">
            <summary>
            Returns a hash code for this ZoneGroupingChunk. Uses all seven indexes (ZoneIndex, WorldGroupingIndex, LOD, Row, Column, Layer, and AsseChunkIndex) to compute it, 
            so the ZoneGroupingChunk is treated as a 3D ZoneGroupingChunk.
            </summary>
            <returns type="int">
            The hash code of the ZoneGroupingChunk.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.Equals(DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            Implementation of IEquatable&lt;ZoneGroupingChunk&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the ZoneIndex, WorldGroupingIndex, AssetChunkIndex, LOD, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom ZoneGroupingChunk EqualityComparer 
            that ignores the layer.
            </para>
            </summary>
            <param name="other" type="object">
            The other ZoneGroupingChunk to compare this ZoneGroupingChunk against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other ZoneGroupingChunk is not equal to this ZoneGroupingChunk's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(ZoneGroupingChunk)
            </displayName>
            <syntax>
            public bool Equals(ZoneGroupingChunk other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGroupingChunk.CompareTo(DeepSpaceLabs.SAM.ZoneGroupingChunk)">
            <summary>
            Compares the input ZoneGroupingChunk against this ZoneGroupingChunk to determine whether this ZoneGroupingChunk procedes, follows, or is at the same 
            position of the input ZoneGroupingChunk. This can be used to order a collection of ZoneGroupingChunks in the same manner as they 
            would appear in the scene (if they were associated with World ZoneGroupingChunks, that is). 
            The method utilizes the ZoneIndex, WorldGroupingIndex, LOD, row, column, and layer values, as well as the AssetChunkIndex.
            </summary>
            <param name="other" type="object">
            The other ZoneGroupingChunk to compare this ZoneGroupingChunk against.
            </param>
            <returns type="int">
            -1 if this ZoneGroupingChunk precedes (is less than) the input "other" ZoneGroupingChunk, +1 if this ZoneGroupingChunk follows (is greater than) 
            the input "other" ZoneGroupingChunk, and 0 if the ZoneGroupingChunks are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the ZoneIndex of the two cell's is compared. If this cell's 
            ZoneIndex is less than the input cell's ZoneIndex, -1 is returned. If it is greater than the input cell's 
            ZoneIndex, +1 is returned. If they are equal, the WorldGroupingIndex values are compared in the same way, followed 
            by the LOD values, then the Cell Indices, and finally the Asset Chunk Indexes.
            </para>
            <para>
            An important thing to note is that higher quality LODs (which have a smaller value) will precede lower quality LODs. However, this 
            also means that according to SAM, ZoneGroupingChunk's with higher quality LODs are less than ZoneGroupingChunk's with lower quality LODs. In addition, 
            lower World Groupings (which are actually probably more important) will be before higher World Groupings. As such, they are considered less 
            than the higher World Grouping cells. The same goes for Zone Groupings.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(ZoneGroupingChunk)
            </displayName>
            <syntax>
            public int CompareTo(ZoneGroupingChunk other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldUserChange">
            <summary>
            Represents a change in users on a World. In addition to regular cell indexes, contains the LOD and World Grouping that the cell belongs to, as well 
            as the zone.
            </summary>
            <title>WorldUserChange Structure</title>
            <category>Structs</category>
            <navigationName>WorldUserChange</navigationName>
            <fileName>WorldUserChange.html</fileName>
            <syntax>public struct WorldUserChange : IEquatable&lt;WorldUserChange&gt;, IComparable&lt;WorldUserChange&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldUserChange.ZoneIndex">
            <summary>
            The index fo the Zone on the World this WorldUserChange is associated with.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldUserChange.WorldGroupingIndex">
            <summary>
            The index of the World Grouping on the World this WorldUserChange is associated with.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldUserChange.Cell">
            <summary>
            The actual Cell this struct details.
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldUserChange.LOD">
            <summary>
            The LOD of the WorldUserChange.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldUserChange.ChangeInUsers">
            <summary>
            The change in users.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.#ctor(System.Int32,System.Int32,System.Int32,DeepSpaceLabs.SAM.Cell,System.Int32)">
            <summary>
            Initializes a new instance of the WorldUserChange structure.
            </summary>
            <param name="zoneIndex" type="int">The index of the Zone of the world the WorldUserChange is associated with.</param>
            <param name="groupingIndex" type="int">The index of the World Grouping of the world the WorldUserChange is associated with.</param>
            <param name="lod" type="int">The LOD of the WorldUserChange.</param>
            <param name="cell" type="Cell" link="Cell.html">The cell of the WorldUserChange.</param>
            <param name="changeInUsers" type="int">The change in users.</param>
            <displayName id="WorldUserChange">WorldUserChange(int, int, int, Cell, int)</displayName>
            <syntax>public WorldUserChange(int zoneIndex, int groupingIndex, int lod, Cell cell, int changeInUsers)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.AdjustUserChange(System.Int32)">
            <summary>
            Returns a new instance of the WorldUserChange structure that is effectively the same as the current object, but with 
            a new value for user change.
            </summary>
            <param name="newChangeInUsers" type="int">
            The new change in users.
            </param>
            <returns type="WorldUserChange">
            The new structure.
            </returns>
            <displayName id="AdjustUserChange">
            AdjustUserChange(int)
            </displayName>
            <syntax>
            public WorldUserChange AdjustUserChange(int newChangeInUsers)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.op_Equality(DeepSpaceLabs.SAM.WorldUserChange,DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            != operater implementation that allows you check if two WorldUserChanges are equal
            <para>
            The two WorldUserChanges will be equal if the ZoneIndex, WorldGroupingIndex, LOD, rows, columns, or layers all match each other from one WorldUserChange to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="WorldUserChange" link="WorldUserChange.html">
            The first WorldUserChange.
            </param>
            <param name="right" type="WorldUserChange" link="WorldUserChange.html">
            The second WorldUserChange.
            </param>
            <returns type="bool">
            Returns true if the WorldUserChanges are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(WorldUserChange, WorldUserChange)
            </displayName>
            <syntax>
            public static bool operator ==(WorldUserChange left, WorldUserChange right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.op_Inequality(DeepSpaceLabs.SAM.WorldUserChange,DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            != operater implementation that allows you check if two WorldUserChanges are not equal
            <para>
            The two WorldUserChanges will not be equal if the ZoneIndex, WorldGroupingIndex, LOD, rows, columns, or 
            layers do not match each other from one WorldUserChange to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="WorldUserChange" link="WorldUserChange.html">
            The first WorldUserChange.
            </param>
            <param name="right" type="WorldUserChange" link="WorldUserChange.html">
            The second WorldUserChange.
            </param>
            <returns type="bool">
            Returns true if the WorldUserChanges are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(WorldUserChange, WorldUserChange)
            </displayName>
            <syntax>
            public static bool operator !=(WorldUserChange left, WorldUserChange right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.op_LessThan(DeepSpaceLabs.SAM.WorldUserChange,DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            &lt; operater implementation that allows you check if the left WorldUserChange is less than the right WorldUserChange.
            </summary>
            <param name="left" type="WorldUserChange" link="WorldUserChange.html">
            The left WorldUserChange.
            </param>
            <param name="right" type="WorldUserChange" link="WorldUserChange.html">
            The right WorldUserChange.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.WorldUserChange.CompareTo(DeepSpaceLabs.SAM.WorldUserChange)" href="WorldUserChange.html#CompareTo">CompareTo</see> method documentation to understand 
            how WorldUserChange comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(WorldUserChange, WorldUserChange)
            </displayName>
            <syntax>
            public static bool operator &lt;(WorldUserChange left, WorldUserChange right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.op_LessThanOrEqual(DeepSpaceLabs.SAM.WorldUserChange,DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            &lt;= operater implementation that allows you check if the left WorldUserChange is less than or equal to the right WorldUserChange.
            </summary>
            <param name="left" type="WorldUserChange" link="WorldUserChange.html">
            The left WorldUserChange.
            </param>
            <param name="right" type="WorldUserChange" link="WorldUserChange.html">
            The right WorldUserChange.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.WorldUserChange.CompareTo(DeepSpaceLabs.SAM.WorldUserChange)" href="WorldUserChange.html#CompareTo">CompareTo</see> method documentation to understand 
            how WorldUserChange comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(WorldUserChange, WorldUserChange)
            </displayName>
            <syntax>
            public static bool operator &lt;=(WorldUserChange left, WorldUserChange right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.op_GreaterThan(DeepSpaceLabs.SAM.WorldUserChange,DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            &gt; operater implementation that allows you check if the left WorldUserChange is greater than the right WorldUserChange.
            </summary>
            <param name="left" type="WorldUserChange" link="WorldUserChange.html">
            The left WorldUserChange.
            </param>
            <param name="right" type="WorldUserChange" link="WorldUserChange.html">
            The right WorldUserChange.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.WorldUserChange.CompareTo(DeepSpaceLabs.SAM.WorldUserChange)" href="WorldUserChange.html#CompareTo">CompareTo</see> method documentation to understand 
            how WorldUserChange comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(WorldUserChange, WorldUserChange)
            </displayName>
            <syntax>
            public static bool operator &gt;(WorldUserChange left, WorldUserChange right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.WorldUserChange,DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            &gt;= operater implementation that allows you check if the left WorldUserChange is greater than or equal to the right WorldUserChange.
            </summary>
            <param name="left" type="WorldUserChange" link="WorldUserChange.html">
            The left WorldUserChange.
            </param>
            <param name="right" type="WorldUserChange" link="WorldUserChange.html">
            The right WorldUserChange.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.WorldUserChange.CompareTo(DeepSpaceLabs.SAM.WorldUserChange)" href="WorldUserChange.html#CompareTo">CompareTo</see> method documentation to understand 
            how WorldUserChange comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(WorldUserChange, WorldUserChange)
            </displayName>
            <syntax>
            public static bool operator &gt;=(WorldUserChange left, WorldUserChange right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input WorldUserChange to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this WorldUserChange against.
            </param>
            <returns type="bool">
            false if the object is not a WorldUserChange or it is but the LOD, row, column, and/or layer value on 
            the obj is not equal to this WorldUserChange's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.GetHashCode">
            <summary>
            Returns a hash code for this WorldUserChange. Uses all six indexes (ZoneIndex, WorldGroupingIndex, LOD, Row, Column and Layer) to compute it, 
            so the WorldUserChange is treated as a 3D WorldUserChange.
            </summary>
            <returns type="int">
            The hash code of the WorldUserChange.
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.Equals(DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            Implementation of IEquatable&lt;WorldUserChange&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the WorldGroupingIndex, LOD, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom WorldUserChange EqualityComparer 
            that ignores the layer
            </para>
            </summary>
            <param name="other" type="object">
            The other WorldUserChange to compare this WorldUserChange against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other WorldUserChange is not equal to this WorldUserChange's LOD, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(WorldUserChange)
            </displayName>
            <syntax>
            public bool Equals(WorldUserChange other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldUserChange.CompareTo(DeepSpaceLabs.SAM.WorldUserChange)">
            <summary>
            Compares the input WorldUserChange against this WorldUserChange to determine whether this WorldUserChange procedes, follows, or is at the same 
            position of the input WorldUserChange.
            </summary>
            <param name="other" type="object">
            The other WorldUserChange to compare this WorldUserChange against.
            </param>
            <returns type="int">
            -1 if this WorldUserChange precedes (is less than) the input "other" WorldUserChange, +1 if this WorldUserChange follows (is greater than) 
            the input "other" WorldUserChange, and 0 if the WorldUserChanges are at the same position (are equal).
            </returns>
            <displayName id="CompareTo">
            CompareTo(WorldUserChange)
            </displayName>
            <syntax>
            public int CompareTo(WorldUserChange other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.CellAndIndex">
            <summary>
            Represents a cell with an additional index field that can be used to store other data such as the LOD of the cell or World Grouping of the cell. You can 
            use this, for example, in per World dictionary where you need to store values for multiple World Groupings. Since each World Grouping will contain World Cell's
            the same Endless Grid Cell indexes, it's not possible to save the values using just the Endless Grid Cell index as key. With this struct, you can 
            store the World Grouping of where the value is coming from as well. This is just one example, you can really use it any time you need to store 
            something using the Endless Grid Cell index + 1 other int value as key.
            </summary>
            <title>CellAndIndex Structure</title>
            <category>Structs</category>
            <navigationName>CellAndIndex</navigationName>
            <fileName>CellAndIndex.html</fileName>
            <syntax>public struct CellAndIndex : IEquatable&lt;CellAndIndex&gt;, IComparable&lt;CellAndIndex&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.CellAndIndex.Cell">
            <summary>
            The actual Cell this struct details.
            </summary>
            <type link="Cell.html">readonly Cell</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.CellAndIndex.Index">
            <summary>
            The index of the CellAndIndex.
            </summary>
            <type>readonly int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.#ctor(DeepSpaceLabs.SAM.Cell,System.Int32)">
            <summary>
            Initializes a new instance of the CellAndIndex structure.
            </summary>
            <param name="cell" type="Cell" link="Cell.html">The cell of the CellAndIndex.</param>
            <param name="index" type="int">The index of the CellAndIndex.</param>
            <displayName id="CellAndIndex">CellAndIndex(Cell, int)</displayName>
            <syntax>public CellAndIndex(Cell cell, int index)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.op_Equality(DeepSpaceLabs.SAM.CellAndIndex,DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            != operater implementation that allows you check if two CellAndIndex are equal
            <para>
            The two CellAndIndexs will be equal if the Index, rows, columns, or layers all match each other from one CellAndIndex to 
            the other (row == row, etc.)
            </para>
            </summary>
            <param name="left" type="CellAndIndex" link="CellAndIndex.html">
            The first CellAndIndex.
            </param>
            <param name="right" type="CellAndIndex" link="CellAndIndex.html">
            The second CellAndIndex.
            </param>
            <returns type="bool">
            Returns true if the CellAndIndex are equal, false if they are not equal.
            </returns>
            <displayName id="== Operator">
            operator ==(CellAndIndex, CellAndIndex)
            </displayName>
            <syntax>
            public static bool operator ==(CellAndIndex left, CellAndIndex right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.op_Inequality(DeepSpaceLabs.SAM.CellAndIndex,DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            != operater implementation that allows you check if two CellAndIndexs are not equal
            <para>
            The two CellAndIndexs will not be equal if the Index, rows, columns, or layers do not match each other from one CellAndIndex to 
            the other (row != row, etc.)
            </para>
            </summary>
            <param name="left" type="CellAndIndex" link="CellAndIndex.html">
            The first CellAndIndex.
            </param>
            <param name="right" type="CellAndIndex" link="CellAndIndex.html">
            The second CellAndIndex.
            </param>
            <returns type="bool">
            Returns true if the CellAndIndexs are not equal, false if they are equal.
            </returns>
            <displayName id="- Operator">
            operator !=(CellAndIndex, CellAndIndex)
            </displayName>
            <syntax>
            public static bool operator !=(CellAndIndex left, CellAndIndex right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.op_LessThan(DeepSpaceLabs.SAM.CellAndIndex,DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            &lt; operater implementation that allows you check if the left CellAndIndex is less than the right CellAndIndex.
            </summary>
            <param name="left" type="CellAndIndex" link="CellAndIndex.html">
            The left CellAndIndex.
            </param>
            <param name="right" type="CellAndIndex" link="CellAndIndex.html">
            The right CellAndIndex.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellAndIndex.CompareTo(DeepSpaceLabs.SAM.CellAndIndex)" href="CellAndIndex.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellAndIndex comparison works.
            </returns>
            <displayName id="&lt; Operator">
            operator &lt;(CellAndIndex, CellAndIndex)
            </displayName>
            <syntax>
            public static bool operator &lt;(CellAndIndex left, CellAndIndex right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.op_LessThanOrEqual(DeepSpaceLabs.SAM.CellAndIndex,DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            &lt;= operater implementation that allows you check if the left CellAndIndex is less than or equal to the right CellAndIndex.
            </summary>
            <param name="left" type="CellAndIndex" link="CellAndIndex.html">
            The left CellAndIndex.
            </param>
            <param name="right" type="CellAndIndex" link="CellAndIndex.html">
            The right CellAndIndex.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellAndIndex.CompareTo(DeepSpaceLabs.SAM.CellAndIndex)" href="CellAndIndex.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellAndIndex comparison works.
            </returns>
            <displayName id="&lt;= Operator">
            operator &lt;=(CellAndIndex, CellAndIndex)
            </displayName>
            <syntax>
            public static bool operator &lt;=(CellAndIndex left, CellAndIndex right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.op_GreaterThan(DeepSpaceLabs.SAM.CellAndIndex,DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            &gt; operater implementation that allows you check if the left CellAndIndex is greater than the right CellAndIndex.
            </summary>
            <param name="left" type="CellAndIndex" link="CellAndIndex.html">
            The left CellAndIndex.
            </param>
            <param name="right" type="CellAndIndex" link="CellAndIndex.html">
            The right CellAndIndex.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellAndIndex.CompareTo(DeepSpaceLabs.SAM.CellAndIndex)" href="CellAndIndex.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellAndIndex comparison works.
            </returns>
            <displayName id="&gt; Operator">
            operator &gt;(CellAndIndex, CellAndIndex)
            </displayName>
            <syntax>
            public static bool operator &gt;(CellAndIndex left, CellAndIndex right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.op_GreaterThanOrEqual(DeepSpaceLabs.SAM.CellAndIndex,DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            &gt;= operater implementation that allows you check if the left CellAndIndex is greater than or equal to the right CellAndIndex.
            </summary>
            <param name="left" type="CellAndIndex" link="CellAndIndex.html">
            The left CellAndIndex.
            </param>
            <param name="right" type="CellAndIndex" link="CellAndIndex.html">
            The right CellAndIndex.
            </param>
            <returns type="bool">
            Please refer to the <see cref="M:DeepSpaceLabs.SAM.CellAndIndex.CompareTo(DeepSpaceLabs.SAM.CellAndIndex)" href="CellAndIndex.html#CompareTo">CompareTo</see> method documentation to understand 
            how CellAndIndex comparison works.
            </returns>
            <displayName id="&gt;= Operator">
            operator &gt;=(CellAndIndex, CellAndIndex)
            </displayName>
            <syntax>
            public static bool operator &gt;=(CellAndIndex left, CellAndIndex right)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input CellAndIndex to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this CellAndIndex against.
            </param>
            <returns type="bool">
            false if the object is not a CellAndIndex or it is but the Index, row, column, and/or layer value on 
            the obj is not equal to this CellAndIndex's Index, row, column, and/or layer value.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.GetHashCode">
            <summary>
            Returns a hash code for this CellAndIndex. Uses all three Cell indices (row, column and layer) + the Index to compute it, 
            so the CellAndIndex is treated as a 3D CellAndIndex. You could also create a custom EqualityComparer that only utilizes 
            the row, column, and Index, if you know that you do not need the layer value.
            </summary>
            <returns type="int">
            The hash code of the CellAndIndex, calculated using all four fields (Index, row, column, and layer).
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.Equals(DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            Implementation of IEquatable&lt;CellAndIndex&gt;.Equals method. Use this, as it does not box input struct.
            <para>
            This method compares the Index, row, column, and layer. In some instances where you know the layer does not 
            matter (on 2D worlds for instance), it may be slightly more performant to use a custom CellAndIndex EqualityComparer 
            that ignores the layer
            </para>
            </summary>
            <param name="other" type="object">
            The other CellAndIndex to compare this CellAndIndex against.
            </param>
            <returns type="bool">
            false if the row, column, and/or layer value on 
            the other CellAndIndex is not equal to this CellAndIndex's Index, row, column, and/or layer value.
            </returns>
            <displayName id="Equals1">
            Equals(CellAndIndex)
            </displayName>
            <syntax>
            public bool Equals(CellAndIndex other)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellAndIndex.CompareTo(DeepSpaceLabs.SAM.CellAndIndex)">
            <summary>
            Compares the input CellAndIndex against this CellAndIndex to determine whether this CellAndIndex procedes, follows, or is at the same 
            position of the input CellAndIndex. Please take a look at the return value summar to understand how the ordering is determined. 
            The method utilizes the Index, row, column, and layer values. If you know the 
            layer value is not used (such as in a 2D world), you may choose to use a different method rather than this one.
            </summary>
            <param name="other" type="object">
            The other CellAndIndex to compare this CellAndIndex against.
            </param>
            <returns type="int">
            -1 if this CellAndIndex precedes (is less than) the input "other" CellAndIndex, +1 if this CellAndIndex follows (is greater than) 
            the input "other" CellAndIndex, and 0 if the CellAndIndexs are at the same position (are equal). 
            <para>
            The following logic is used to determine the order. First, the Index of the two CellAndIndex's is compared. If this cell's Index value is 
            less than the Index value of the input cell, -1 is returned. If it is greater, +1 is returned. If they are the same, then the 
            Layer value is compared in the same manner. If this CellAndIndex's 
            layer is less than the input CellAndIndex's layer, -1 is returned. If this CellAndIndex's layer is greater than the input CellAndIndex's layer, 
            +1 is returned. If the two have the same layer value, the row is compared in the same manner. If the rows are the same, 
            the columns are compared. If the columns are compared, 0 is returned as the two CellAndIndex's are equal and have the same placement 
            in the order.
            </para>
            </returns>
            <displayName id="CompareTo">
            CompareTo(CellAndIndex)
            </displayName>
            <syntax>
            public int CompareTo(CellAndIndex other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.CellDimensions">
            <summary>
            Represents the dimensions of a <see cref="T:DeepSpaceLabs.SAM.Cell" href="Cell.html">Cell</see>.
            </summary>
            <title>CellDimensions Structure</title>
            <category>Structs</category>
            <navigationName>CellDimensions</navigationName>
            <fileName>CellDimensions.html</fileName>
            <syntax>public struct CellDimensions</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.CellDimensions.height">
            <summary>
            The height of the cell. This is only relevant when the cell in question is associated with a three dimensional entity.
            </summary>
            <type>readonly double</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DeepSpaceLabs.SAM.CellDimensions.length">
            <summary>
            The length of the cell.
            </summary>
            <type>readonly double</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DeepSpaceLabs.SAM.CellDimensions.width">
            <summary>
            The width of the cell.
            </summary>
            <type>readonly double</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellDimensions.#ctor(System.Double,System.Double)">
            <summary>
            Initializes a new instance of the CellDimension structure with height set to 0.
            </summary>
            <param name="length" type="double">The length of the cell.</param>
            <param name="width" type="double">The width of the cell.</param>
            <displayName id="">CellDimensions(double, double)</displayName>
            <syntax>public CellDimensions(double length, double width)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellDimensions.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the CellDimension structure.
            </summary>
            <param name="height" type="double">The height of the cell. This is only relevant when the cell in question is associated with a three dimensional entity.</param>
            <param name="length" type="double">The length of the cell.</param>
            <param name="width" type="double">The width of the cell.</param>
            <displayName id="">CellDimensions(double, double, double)</displayName>
            <syntax>public CellDimensions(double height, double length, double width)</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.GridValues`1">
            <summary>
            Represents a generic collection of values for a row, column, and layer. This class is used internally in several areas, but you will 
            probably never need to use it yourself, unless you are writing some custom code and want the convenience it offers.
            </summary>
            <title>GridValues&lt;T&gt; Structure</title>
            <category>Structs</category>
            <navigationName>GridValues</navigationName>
            <fileName>GridValues.html</fileName>
            <syntax>public struct GridValues&lt;T&gt;</syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.GridValues`1.columnValue">
            <summary>
            The column value.
            </summary>
            <type>readonly T</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DeepSpaceLabs.SAM.GridValues`1.layerValue">
            <summary>
            The layer value.
            </summary>
            <type>readonly T</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="F:DeepSpaceLabs.SAM.GridValues`1.rowValue">
            <summary>
            The row value.
            </summary>
            <type>readonly T</type>
            <defaultValue>Does Not Apply</defaultValue>
        </member>
        <member name="M:DeepSpaceLabs.SAM.GridValues`1.#ctor(`0,`0,`0)">
            <summary>
            Initializes a new instance of the GridValues structure.
            </summary>
            <param name="rowValue" type = "T">The row value that the structure should hold.</param>
            <param name="columnValue" type = "T">The column value that the structure should hold.</param>
            <param name="layerValue" type = "T">The layer value that the structure should hold.</param>
            <displayName id="">GridValues(T, T, T)</displayName>
            <syntax>public GridValues(T rowValue, T columnValue, T layerValue)</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.Vector3Double">
            <summary>
            This is a version of Vector3Double that uses doubles instead of doubles. Please refer to Unity's 
            <see cref="T:UnityEngine.Vector3" href="https://docs.unity3d.com/ScriptReference/Vector3.html">Vector3</see> documentation for member information, as all members 
            supported with Vector3's are supported with this struct and are used in the exact same way.
            <para>
            The struct also has an implicit implementation for converting from Vector3 to Vector3Double, which you can use like this:
            </para>
            <para>
            Vector3 exampleV3 = new Vector3(.5f, 10f, 5f);
            Vector3Double vDouble = exampleV3;
            </para>
            <para>
            and an explicit implementation for converting from Vector3Double to Vector3, which you can use like this:
            </para>
            <para>
            Vector3Double exampleVD3 = new Vector3Double(.5d, 10d, 5d);
            Vector3 v = (Vector3)exampleV3;//note the explicit cast
            </para>
            <para>
            The latter explicit cast results in a down-cast, which may result in a loss/change of data if the Vector3 cannot represent the Vector3Double accurately. However, 
            in almost all use cases with the Streamable Assets Manager, when these explicit cast are required, the Vector3Double value should represent 
            data that can be successfully converted to a Vector3, with at most a loss of precision.
            </para>
            </summary>
            <title>
            Vector3Double Structure
            </title>
            <category>Structs</category>
            <navigationName>Vector3Double</navigationName>
            <fileName>Vector3Double.html</fileName>
            <syntax>
            public struct Vector3Double : IEquatable&lt;Vector3Double&gt;, IFormattable
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Vector3Double.Equals(DeepSpaceLabs.SAM.Vector3Double)">
            <summary>
            Uses an approximation/epsilon to compare the equality of each component.
            </summary>
            <param name="other"></param>
            <returns>True if the two Vector3Doubles are approximately equal, false otherwise</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.Vector3Double.ToGridValues(DeepSpaceLabs.SAM.Axes)">
            <summary>
            Converts this Vector3Double to a GridValues&lt;double&gt; struct.
            </summary>
            <param name="axes">The axes type. This determines whether the y 
            component is used for layer and z for row, or vice versa. The x component is 
            always used for the column value.</param>
            <returns>A GridValues struct.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.OldActiveGridData">
            <summary>
            A structure for holding some Active Grid Data that was previously saved in persistent data but 
            is no longer used. Even though it is not used natively, you may wish to make us of this data to 
            choose a proper Loading Pattern for the Active Grid. This data is automatically created and 
            added when using the ComponentManager.ConvertComponentSpecificData method with a non null oldActiveGridData argument.
            </summary>
            <title>
            OldActiveGridData Structure
            </title>
            <category>Structs</category>
            <navigationName>
            OldActiveGridData
            </navigationName>
            <fileName>OldActiveGridData.html</fileName>
            <syntax>
            public struct OldActiveGridData
            </syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.OldActiveGridData.ActiveGridID">
            <summary>
            The ID of the Active Grid the data is associated with.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.OldActiveGridData.InnerAreaRows">
            <summary>
            The inner area rows value stored in the old data.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.OldActiveGridData.InnerAreaColumns">
            <summary>
            The inner area columns value stored in the old data.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.OldActiveGridData.InnerAreaLayers">
            <summary>
            The inner area layers value stored in the old data.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.OldActiveGridData.OuterRingWidth">
            <summary>
            The outer ring width value stored in the old data.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.OldActiveGridData.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new instance of the OldActiveGridData struct.
            </summary>
            <param name="activeGridID" type="int">
            The ID of the Active Grid this data is associated with.
            </param>
            <param name="innerAreaRows" type="int">
            The inner area rows value stored in the old data.
            </param>
            <param name="innerAreaColumns" type="int">
            The inner area columns value stored in the old data.
            </param>
            <param name="innerAreaLayers" type="int">
            The inner area layers value stored in the old data.
            </param>
            <param name="outerRingWidth" type="int">
            The outer ring width value stored in the old data.
            </param>
            <displayName id="OldActiveGridData">
            OldActiveGridData(int, int, int, int, int)
            </displayName>
            <syntax>
            public OldActiveGridData(int activeGridID, int innerAreaRows, int innerAreaColumns, int innerAreaLayers, int outerRingWidth)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.DoubleIndex">
            <summary>
            A structure for storing two integer values.
            </summary>
            <title>DoubleIndex Class</title>
            <category>Structs</category>
            <navigationName>DoubleIndex</navigationName>
            <fileName>DoubleIndex.html</fileName>
            <syntax>
            public struct DoubleIndex : IEquatable&lt;DoubleIndex&gt;
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DoubleIndex.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the DoubleIndex structure.
            </summary>
            <param name="primaryIndex" type="int">The primary index of the DoubleIndex.</param>
            <param name="secondaryIndex" type="int">The secondary index of the DoubleIndex.</param>
            <displayName id="DoubleIndex">DoubleIndex(int, int)</displayName>
            <syntax>public DoubleIndex(int primaryIndex, int secondaryIndex)</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.DoubleIndex.PrimaryIndex">
            <summary>
            Gets the primary index of the DoubleIndex.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.DoubleIndex.SecondaryIndex">
            <summary>
            Gets the secondary index of the DoubleIndex.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DoubleIndex.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input DoubleIndex to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this DoubleIndex against.
            </param>
            <returns type="bool">
            false if the object is not a DoubleIndex or it is but the PrimaryIndex or SecondaryIndex of the obj is not the same as this one.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DoubleIndex.GetHashCode">
            <summary>
            Returns a hash code for this DoubleIndex.
            </summary>
            <returns type="int">
            The hash code of the DoubleIndex, calculated using both fields (primaryIndex and secondaryIndex).
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.DoubleIndex.Equals(DeepSpaceLabs.SAM.DoubleIndex)">
            <summary>
            Implementation of IEquatable&lt;DoubleIndex&gt;.Equals method. Use this, as it does not box input struct.
            </summary>
            <param name="other" type="object">
            The other DoubleIndex to compare this DoubleIndex against.
            </param>
            <returns type="bool">
            false if the PrimaryIndex or SecondaryIndex are not equal. True otherwise.
            </returns>
            <displayName id="Equals1">
            Equals(DoubleIndex)
            </displayName>
            <syntax>
            public bool Equals(DoubleIndex other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.TripleIndex">
            <summary>
            Can be used to store three int values
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TripleIndex.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the TripleIndex structure.
            </summary>
            <param name="primaryIndex" type="int">The primary index of the TripleIndex.</param>
            <param name="secondaryIndex" type="int">The secondar index of the TripleIndex.</param>
            <param name="tertiaryIndex" type="int">The third index of the TripleIndex.</param>
            <displayName id="TripleIndex">TripleIndex(int, int, int)</displayName>
            <syntax>public TripleIndex(int primaryIndex, int secondaryIndex, int tertiaryIndex)</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TripleIndex.PrimaryIndex">
            <summary>
            Gets the primary index of the TripleIndex.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TripleIndex.SecondaryIndex">
            <summary>
            Gets the secondary index of the TripleIndex.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.TripleIndex.TertiaryIndex">
            <summary>
            Gets the third index of the TripleIndex.
            <type>int</type>
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TripleIndex.Equals(System.Object)">
            <summary>
            Override of Equals method. You shouldn't need to use this, and you should not use it since it will cause the 
            input TripleIndex to be boxed.
            </summary>
            <param name="obj" type="object">
            The object to check this TripleIndex against.
            </param>
            <returns type="bool">
            false if the object is not a TripleIndex or it is but the PrimaryIndex, SecondaryIndex, or 
            TertiaryIndex of the obj are not equal to this one.
            </returns>
            <displayName id="Equals2">
            Equals(object)
            </displayName>
            <syntax>
            public override bool Equals(object obj)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TripleIndex.GetHashCode">
            <summary>
            Returns a hash code for this TripleIndex.
            </summary>
            <returns type="int">
            The hash code of the TripleIndex, calculated using all three fields (PrimaryIndex, SecondaryIndex, and TertiaryIndex).
            </returns>
            <displayName id="GetHashCode">
            GetHashCode()
            </displayName>
            <syntax>
            public override int GetHashCode()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.TripleIndex.Equals(DeepSpaceLabs.SAM.TripleIndex)">
            <summary>
            Implementation of IEquatable&lt;TripleIndex&gt;.Equals method. Use this, as it does not box input struct.
            </summary>
            <param name="other" type="object">
            The other TripleIndex to compare this TripleIndex against.
            </param>
            <returns type="bool">
            false if the PrimaryIndex, SecondaryIndex, or TertiaryIndex are not equal. True otherwise
            </returns>
            <displayName id="Equals1">
            Equals(TripleIndex)
            </displayName>
            <syntax>
            public bool Equals(TripleIndex other)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.AsyncLoadStrategy">
            <summary>
            Specifies how async load and unload calls are handled. This controls both how async load and unload calls 
            are queued up as well as how the async resources are activated and deactivated by Unity.
            <para>
            This enum is primarily used by <see cref="T:DeepSpaceLabs.SAM.ChunkStreamer" href="ChunkStreamer.html">Chunk Streamers</see>.
            </para>
            </summary>
            <title>AsyncLoadStrategy Enumeration</title>
            <category>Enums</category>
            <navigationName>AsyncLoadStrategy</navigationName>
            <fileName>AsyncLoadStrategy.html</fileName>
            <syntax>public enum AsyncLoadStrategy</syntax>
            <enumMember name="OneChunkAtATime" value="0">
            At most, a single chunk (scene, asset bundle, prefab, etc.) will be asynchronously queued up, loaded/unloaded, 
            and activated/deactivated (integrated into/out of the scene).
            </enumMember>
            <enumMember name="OneCellAtATime" value="1">
            All chunks for a single cell will be queued up and loaded/unloaded at the same time. Those same chunks may be 
            activated/deactivated (integrated into/out of the scene) in the same frame or in different frames.
            </enumMember>
            <enumMember name="AllTogether" value="2">
            All chunks for every cell in a given load/unload operation will be queued up and loaded/unloaded at the same time. 
            Those same chunks may be activated/deactivated (integrated into/out of the scene) in the same frame or in different frames.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.AsyncLoadStrategy.OneChunkAtATime">
            <summary>
            At most, a single chunk (scene, asset bundle, prefab, etc.) will be asynchronously queued up, loaded/unloaded, 
            and activated/deactivated (integrated into/out of the scene).
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.AsyncLoadStrategy.OneCellAtATime">
            <summary>
            All chunks for a single cell will be queued up and loaded/unloaded at the same time. Those same chunks may be 
            activated/deactivated (integrated into/out of the scene) in the same frame or in different frames.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.AsyncLoadStrategy.AllTogether">
            <summary>
            All chunks for every cell in a given load/unload operation will be queued up and loaded/unloaded at the same time. 
            Those same chunks may be activated/deactivated (integrated into/out of the scene) in the same frame or in different frames.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.Axes">
            <summary>
            Specifies the axes that a 
            <see cref="T:DeepSpaceLabs.SAM.StreamableGrid" href="StreamableGrid.html">Streamable Grid</see> functions on. This determines whether Layers are factored into calculations 
            involving the Grid as well as which components from the 
            Player's position are tracked in order to determine their Cell location and trigger dynamic streaming functionality 
            (when an Active Grid is used).
            </summary>
            <title>Axes Enumeration</title>
            <category>Enums</category>
            <navigationName>Axes</navigationName>
            <fileName>Axes.html</fileName>
            <syntax>public enum Axes</syntax>
            <enumMember name ="Three_Dimensional" value="0">More than 1 Layer IS possible on the Grid and Layers ARE factored into calculations. When using an Active Grid, 
            the player's Z position is used to determine the Row of the Cell they are in, the X position determines the Column, and the Y position determines the Layer.</enumMember>
            <enumMember name ="Two_Dimensional_On_XY_Axes" value="1">More than 1 Layer IS NOT possible on the Grid and Layers ARE NOT factored into calculations. When using an Active Grid, 
            the player's Y position is used to determine the Row of the Cell they are in while the X position determines the Column. The Layer is always 1.</enumMember>
            <enumMember name ="Two_Dimensional_On_XZ_Axes" value="2">More than 1 Layer IS NOT possible on the Grid and Layers ARE NOT factored into calculations. When using an Active Grid, 
            the player's Z position is used to determine the Row of the Cell they are in while the X position determines the Column. The Layer is always 1.</enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.Axes.Three_Dimensional">
            <summary>
            More than 1 Layer IS possible on the Grid and Layers ARE factored into calculations. When using an Active Grid, 
            the player's Z position is used to determine the Row of the Cell they are in, the X position determines the Column, and the Y position determines the Layer.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.Axes.Two_Dimensional_On_XZ_Axes">
            <summary>
            More than 1 Layer IS NOT possible on the Grid and Layers ARE NOT factored into calculations. When using an Active Grid, 
            the player's Y position is used to determine the Row of the Cell they are in while the X position determines the Column. The Layer is always 1.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.Axes.Two_Dimensional_On_XY_Axes">
            <summary>
            More than 1 Layer IS NOT possible on the Grid and Layers ARE NOT factored into calculations. When using an Active Grid, 
            the player's Z position is used to determine the Row of the Cell they are in while the X position determines the Column. The Layer is always 1.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.BoundaryCrossed">
            <summary>
            Used by <see cref="T:DeepSpaceLabs.SAM.BoundaryMonitor" href="BoundaryMonitor.html">Boundary Monitors</see> to identify which boundary was crossed by a tracked player.
            <para>
            For 2D worlds, there are four boundaries (West, East, North, and South). Together these boundaries form a rectangle.
            For XZ worlds, this rectangle lies on the XZ plane, with the West boundary having the lowest X value and South boundary having
            the lowest Z value.</para>
            <para>For XY worlds, the West boundary still has the lowest X value, but the South boundary instead has the lowest Y value.</para>
            <para>For 3D worlds, the Top and Bottom boundaries are also used, forming a cube rather than a rectangle. The West and East are the
            boundaries with the lowest and highest X values respectively, the South and North are the boundaries with the lowest and highest
            Z values respectively, and the Bottom and Top are the boundaries with the lowest and highest Y values respectively.
            </para>
            </summary>
            <title>BoundaryCrossed Enumeration</title>
            <category>Enums</category>
            <navigationName>BoundaryCrossed</navigationName>
            <fileName>BoundaryCrossed.html</fileName>
            <syntax>public enum BoundaryCrossed</syntax>
            <enumMember name ="None" value="0">No boundary was crossed.</enumMember>
            <enumMember name ="West" value="1">West boundary was crossed.</enumMember>
            <enumMember name ="East" value="2">East boundary was crossed.</enumMember>
            <enumMember name ="North" value="3">North boundary was crossed.</enumMember>
            <enumMember name ="South" value="4">South boundary was crossed.</enumMember>
            <enumMember name ="Top" value="5">Top boundary was crossed (Only relevant when using 3D world).</enumMember>
            <enumMember name ="Bottom" value="6">Bottom boundary was crossed (Only relevant when using 3D world).</enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.BoundaryCrossed.None">
            <summary>
            No boundary was crossed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.BoundaryCrossed.West">
            <summary>
            West boundary was crossed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.BoundaryCrossed.East">
            <summary>
            East boundary was crossed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.BoundaryCrossed.North">
            <summary>
            North boundary was crossed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.BoundaryCrossed.South">
            <summary>
            South boundary was crossed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.BoundaryCrossed.Top">
            <summary>
            Top boundary was crossed (Only relevant when using 3D world).
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.BoundaryCrossed.Bottom">
            <summary>
            Bottom boundary was crossed (Only relevant when using 3D world).
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkType">
            <summary>
            Specifies the type of Asset Chunks used in the Streamable Assets Manager system. There is a tremendous amount of flexibility in the 
            types of Asset Chunks you can use and how different types are combined, with each LOD Group able to use a different type.
            <para>
            This type is set on <see cref="T:DeepSpaceLabs.SAM.StreamableGrid" href="StreamableGrid.html">Streamable Grid</see> assets for each LOD Group on the Grid.
            </para>
            </summary>
            <title>ChunkType Enumeration</title>
            <category>Enums</category>
            <navigationName>ChunkType</navigationName>
            <fileName>ChunkType.html</fileName>
            <syntax>public enum ChunkType</syntax>
            <enumMember name ="Unity_Terrain" value="0">The chunks are Game Objects with Unity Terrain components attached.</enumMember>
            <enumMember name ="Non_Terrain_Game_Object" value="1">The chunks are Game Objects without Unity Terrain components attached.</enumMember>
            <enumMember name ="Custom_Object" value="2">The chunks are non Game Objects but instead derive from some sort of normal C# class.</enumMember>
            <enumMember name ="None" value="3">
            Traditional class based objects are not being used. You may have objects associated with the cells, but you'll have to set them up manually 
            and store the relationship between those objects and the cells yourself (rather than on the World Cell). 
            The best way to do this is via a custom <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see> component.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkType.Unity_Terrain">
            <summary>
            The chunks are Game Objects with Unity Terrain components attached.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkType.Non_Terrain_Game_Object">
            <summary>
            The chunks are Game Objects with Unity Terrain components attached.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkType.Custom_Object">
            <summary>
            The chunks are non Game Objects but instead derive from some sort of normal C# class.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunkType.None">
            <summary>
            Traditional class based objects are not being used. You may have objects associated with the cells, but you'll have to set them up manually 
            and store the relationship between those objects and the cells yourself (rather than on the World Cell). 
            The best way to do this is via a custom <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see> component.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunksPositioned">
            <summary>
            An enumeration defining whether the Chunks of a 
            <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> have been positioned already. 
            This is used during chunk attachment (which usually occur in 
            <see cref="T:DeepSpaceLabs.SAM.ChunkStreamer" href="ChunkStreamer.html">Chunk Streamers</see> 
            or <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">Chunk Managers</see>) 
            to give 
            the World a hint on whether the chunks attached to a World Cell need to be positioned.
            <para>
            When 'Yes' is set, the chunks will not be moved. If 'No', the chunks 
            will be positioned even if some of them are already at the correct position. The 'Maybe' 
            option forces the World to check the position of each chunk on the World Cell to 
            see if it's correct (i.e., equal to WorldCell.PositionOfChunks). Chunks are only positioned if 
            their position is not correct.
            </para>
            <para>
            This is only used with LODs whose make use of chunks and whose chunks 
            make use of positional data!
            </para>
            </summary>
            <title>
            ChunksPositioned Enumeration
            </title>
            <category>Enums</category>
            <navigationName>ChunksPositioned</navigationName>
            <fileName>ChunksPositioned.html</fileName>
            <syntax>
            public enum ChunkPositioned
            </syntax>
            <enumMember name="No" value="0">
            Denotes chunks which have not been positioned correctly already.
            </enumMember>
            <enumMember name="Maybe" value="1">
            Denotes chunks where their positional status is not known. Or alternatively, could denote a mix of chunks when the World Cell has 
            multiple chunks, where some of the chunks have been positioned and some have not.
            </enumMember>
            <enumMember name="Yes" value="2">
            Denotes chunks which have already been positioned correctly.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunksPositioned.No">
            <summary>
            Denotes a chunk which has not been positioned correctly already.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunksPositioned.Maybe">
            <summary>
            Denotes a chunk which may have been positioned, but you're not 100% sure. When attaching a chunk to a World Cell with this value, 
            the World Cell will run an extra comparison to see if the chunk position matches the position the World Cell expects, and if not, 
            it will be moved to the correct position.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ChunksPositioned.Yes">
            <summary>
            Denotes a chunk which has already been positioned correctly.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.DistanceCheckMethod">
            <summary>
            Specifies the method to use to calculate distance between cells when using a 
            <see cref="T:DeepSpaceLabs.SAM.DistancePoolingChunkManager" href="DistancePoolingChunkManager.html">Distance Pooling Chunk Manager</see>.
            </summary>
            <title>DistanceCheckMethod Enumeration</title>
            <category>Enums</category>
            <navigationName>DistanceCheckMethod</navigationName>
            <fileName>DistanceCheckMethod.html</fileName>
            <syntax>public enum DistanceCheckMethod</syntax>
            <enumMember name="Chebyshev" value="0">
            The distance between each cell's coordinates (Row, Column, Layer) are calculated and the greatest of the three values is used as the distance. 
            This is good for games where the Player can move from one cell to a neighboring diagonal cell very easily (i.e., in a short time span).
            </enumMember>
            <enumMember name="Manhattan" value="1">
            The distances between each cell's coordinates (Row, Column, Layer) are calculated and added together to compute the distance. 
            This is good for games where the Player cannot easily move from one cell to a neighboring diaganol cell easily (i.e., in a short time span).
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.DistanceCheckMethod.Chebyshev">
            <summary>
             The distance between each cell's coordinates (Row, Column, Layer) are calculated and the greatest of the three values is used as the distance. 
            This is good for games where the Player can move from one cell to a neighboring diagonal cell very easily (i.e., in a short time span).
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.DistanceCheckMethod.Manhattan">
            <summary>
            The distances between each cell's coordinates (Row, Column, Layer) are calculated and added together to compute the distance. 
            This is good for games where the Player cannot easily move from one cell to a neighboring diaganol cell easily (i.e., in a short time span).
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InvalidSceneFormatMessageLevel">
            <summary>
            An enumeration defining how invalid scene formats are logged when discovered by 
            <see cref="T:DeepSpaceLabs.SAM.ChunkStreamer" href="ChunkStreamer.html">Chunk Streamers</see> that utilize scenes. An invalid scene format is 
            one where the scene contains more or less than 1 root game object, or one with a single root game object that is not in an inactive state.
            </summary>
            <title>
            InvalidSceneFormatMessageLevel Enumeration
            </title>
            <category>Enums</category>
            <navigationName>InvalidSceneFormatMessageLevel</navigationName>
            <fileName>InvalidSceneFormatMessageLevel.html</fileName>
            <syntax>
            public enum InvalidSceneFormatMessageLevel
            </syntax>
            <enumMember name="NoMessage" value="0">
            No message is logged when a scene is found in an invalid format.
            </enumMember>
            <enumMember name="Warning" value="1">
            A warning is logged when a scene is found in an invalid format.
            </enumMember>
            <enumMember name="Error" value="2">
            An error is logged when a scene is found in an invalid format.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InvalidSceneFormatMessageLevel.NoMessage">
            <summary>
            No message is logged when a scene is found in an invalid format.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InvalidSceneFormatMessageLevel.Warning">
            <summary>
            A warning is logged when a scene is found in an invalid format.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.InvalidSceneFormatMessageLevel.Error">
            <summary>
            An error is logged when a scene is found in an invalid format.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ListenerYieldBehavior">
            <summary>
            Specifies the yield behavior of a 
            <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">World Grouping Listener</see>, which tells the 
            World how it should proceed after one of the listeners multi-frame methods has finished running.
            </summary>
            <title>ListenerYieldBehavior Enumeration</title>
            <category>Enums</category>
            <navigationName>ListenerYieldBehavior</navigationName>
            <fileName>ListenerYieldBehavior.html</fileName>
            <syntax>public enum ListenerYieldBehavior</syntax>
            <enumMember name="NeverYield" value="0">
            Indicates that after executing one of the Listener's methods, the World should continue running (in the given frame), 
            which usually means beginning execution the same method of the next listener.
            <para>
            You would typically use this type of behaviour if you need to ensure that one listener runs immediately after another.
            </para>
            </enumMember>
            <enumMember name="YieldOrContinue" value="1">
            Indicates that after executing one of the Listener's methods, the World should query its Execution Controller to determine if 
            it should continue running (in the given frame).
            <para>
            This behaviour is useful if you don't care one way or another whether the World yields control, as it allows you to leave the decision 
            up to the Execution Controller.
            </para>
            </enumMember>
            <enumMember name="AlwaysYield" value="2">
            Indicates that after executing one of the Listener's methods, the World should yield for at least a frame, allowing other components to run.
            <para>
            You would typically use this type of behaviour if you need to ensure that the World yields control for at least a frame after the Listener's 
            method executes, perhaps because whatever action the Listener performed needs a frame to "process".
            </para>
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ListenerYieldBehavior.NeverYield">
            <summary>
            Indicates that after executing one of the Listener's methods, the World should continue running (in the given frame), 
            which usually means beginning execution the same method of the next listener.
            <para>
            You would typically use this type of behaviour if you need to ensure that one listener runs immediately after another.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ListenerYieldBehavior.YieldOrContinue">
            <summary>
            Indicates that after executing one of the Listener's methods, the World should query its Execution Controller to determine if 
            it should continue running (in the given frame).
            <para>
            This behaviour is useful if you don't care one way or another whether the World yields control, as it allows you to leave the decision 
            up to the Execution Controller.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.ListenerYieldBehavior.AlwaysYield">
            <summary>
            Indicates that after executing one of the Listener's methods, the World should yield for at least a frame, allowing other components to run.
            <para>
            You would typically use this type of behaviour if you need to ensure that the World yields control for at least a frame after the Listener's 
            method executes, perhaps because whatever action the Listener performed needs a frame to "process".
            </para>
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LoadingBlueprintType">
            <summary>
            Specifies the type of a <see cref="T:DeepSpaceLabs.SAM.LoadingBlueprint" href="LoadingBlueprint.html">Loading Blueprint</see>.
            </summary>
            <title>LoadingBlueprintType Enumeration</title>
            <category>Enums</category>
            <navigationName>LoadingBlueprintType</navigationName>
            <fileName>LoadingBlueprintType.html</fileName>
            <syntax>public enum LoadingBlueprintType</syntax>
            <enumMember name="UniformRing" value="0">
            A uniform ring based blueprint, with a definable inner area and set of rings around it that make up 
            the outer area.
            <para>
            The ring pattern is shifted as the player crosses the Inner Area Boundary of the 
            pattern, which causes World Cells to be loaded and unloaded. However, the pattern itself retains the same 
            shape no matter where the player is within the World.
            </para>
            </enumMember>
            <enumMember name="UniformCustomShape" value="1">
            A uniform custom shape based blueprint, with a definable connected inner area and an outer area that 
            can be made up of one or more (connected or unconnected) non inner area cells.
            <para>
            The custom shaped pattern is shifted as the player crosses the Inner Area Boundary of the 
            pattern, which causes World Cells to be loaded and unloaded. However, the pattern itself retains the same 
            shape no matter where the player is within the World.
            </para>
            </enumMember>
            <enumMember name="UniformSectioned" value="2">
            A uniform sectioned blueprint. The inner area is made up of a user definable number of equal sized grid sections, with each 
            grid section having a custom, unique loading pattern. As the player 
            moves between these grid sections, the loading pattern changes, resulting in World Cells being loaded and unloaded.
            <para>
            The unique patterns for each sectioned area are the same no matter which World Cell the player is standing within, however 
            what World Cells those patterns match up with will of course change as the player moves from one World Cell to another.
            </para>
            </enumMember>
            <enumMember name="NonUniformRing" value="3">
            Allows you to define a unique ring pattern for every Cell in the Loading Blueprint. When the player enters a World Cell 
            that has a defined unique pattern, that pattern will become the "active" pattern. If the player enters a World Cell 
            that does nto have a defined unique pattern, the Default Loading Pattern is used, which serves as a sort of fallback option.
            <para>
            Each cell in the Blueprint should  
            correspond to a cell on a Streamable Grid you are using the blueprint with, i.e. the number 
            of columns, rows, and layers (for 3D worlds) in the blueprint should match the number of columns, rows, and layers 
            on the Streamable Grid. If the blueprint has more columns, rows, and/or layers than the Streamable Grid, the extra 
            rows/columns/layers will not be used, however if the blueprint has less, the Default Loading Pattern will be used for 
            any World Cells not found in the Blueprint.
            </para>
            <para>
            This blueprint can be utilized to optimize your world to the extreme. 
            For instance, perhaps a cell is in an area of your world where the visibility is bad, and the player 
            cannot see as far as in other parts of the world. In such a case, you probably won't need to load as many
            cells around that cell.
            </para>
            </enumMember>
            <enumMember name="NonUniformCustomShape" value="4">
            Allows you to define a unique custom shaped pattern for every Cell in the Loading Blueprint. When the player enters a World Cell 
            that has a defined unique pattern, that pattern will become the "active" pattern. If the player enters a World Cell 
            that does nto have a defined unique pattern, the Default Loading Pattern is used, which serves as a sort of fallback option.
            <para>
            Each cell in the Blueprint should  
            correspond to a cell on a Streamable Grid you are using the blueprint with, i.e. the number 
            of columns, rows, and layers (for 3D worlds) in the blueprint should match the number of columns, rows, and layers 
            on the Streamable Grid. If the blueprint has more columns, rows, and/or layers than the Streamable Grid, the extra 
            rows/columns/layers will not be used, however if the blueprint has less, the Default Loading Pattern will be used for 
            any World Cells not found in the Blueprint.
            </para>
            <para>
            This blueprint can be utilized to optimize your world to the extreme. 
            For instance, perhaps a cell is surrounded by mountains on three sides that block the player's view. You can setup a custom pattern 
            for this cell where no cells behind the mountains are loaded. This might allow you to make the game world within that cell 
            more detailed than it otherwise could be, since the resources normally used by those cells beyond the mountain can be freed up.
            </para>
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LoadingBlueprintType.UniformRing">
            <summary>
            A uniform ring based blueprint, with a definable inner area and set of rings around it that make up 
            the outer area.
            <para>
            The ring pattern is shifted as the player crosses the Inner Area Boundary of the 
            pattern, which causes World Cells to be loaded and unloaded. However, the pattern itself retains the same 
            shape no matter where the player is within the World.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LoadingBlueprintType.UniformCustomShape">
            <summary>
            A uniform custom shape based blueprint, with a definable connected inner area and an outer area that 
            can be made up of one or more (connected or unconnected) non inner area cells.
            <para>
            The custom shaped pattern is shifted as the player crosses the Inner Area Boundary of the 
            pattern, which causes World Cells to be loaded and unloaded. However, the pattern itself retains the same 
            shape no matter where the player is within the World.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LoadingBlueprintType.UniformSectioned">
            <summary>
            A uniform sectioned blueprint. The inner area is made up of a user definable number of equal sized grid sections, with each 
            grid section having a custom, unique loading pattern. As the player 
            moves between these grid sections, the loading pattern changes, resulting in World Cells being loaded and unloaded.
            <para>
            The unique patterns for each sectioned area are the same no matter which World Cell the player is standing within, however 
            what World Cells those patterns match up with will of course change as the player moves from one World Cell to another.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LoadingBlueprintType.NonUniformRing">
            <summary>
            Allows you to define a unique ring pattern for every Cell in the Loading Blueprint. When the player enters a World Cell 
            that has a defined unique pattern, that pattern will become the "active" pattern. If the player enters a World Cell 
            that does nto have a defined unique pattern, the Default Loading Pattern is used, which serves as a sort of fallback option.
            <para>
            Each cell in the Blueprint should  
            correspond to a cell on a Streamable Grid you are using the blueprint with, i.e. the number 
            of columns, rows, and layers (for 3D worlds) in the blueprint should match the number of columns, rows, and layers 
            on the Streamable Grid. If the blueprint has more columns, rows, and/or layers than the Streamable Grid, the extra 
            rows/columns/layers will not be used, however if the blueprint has less, the Default Loading Pattern will be used for 
            any World Cells not found in the Blueprint.
            </para>
            <para>
            This blueprint can be utilized to optimize your world to the extreme. 
            For instance, perhaps a cell is in an area of your world where the visibility is bad, and the player 
            cannot see as far as in other parts of the world. In such a case, you probably won't need to load as many
            cells around that cell.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LoadingBlueprintType.NonUniformCustomShape">
            <summary>
            Allows you to define a unique custom shaped pattern for every Cell in the Loading Blueprint. When the player enters a World Cell 
            that has a defined unique pattern, that pattern will become the "active" pattern. If the player enters a World Cell 
            that does nto have a defined unique pattern, the Default Loading Pattern is used, which serves as a sort of fallback option.
            <para>
            Each cell in the Blueprint should  
            correspond to a cell on a Streamable Grid you are using the blueprint with, i.e. the number 
            of columns, rows, and layers (for 3D worlds) in the blueprint should match the number of columns, rows, and layers 
            on the Streamable Grid. If the blueprint has more columns, rows, and/or layers than the Streamable Grid, the extra 
            rows/columns/layers will not be used, however if the blueprint has less, the Default Loading Pattern will be used for 
            any World Cells not found in the Blueprint.
            </para>
            <para>
            This blueprint can be utilized to optimize your world to the extreme. 
            For instance, perhaps a cell is surrounded by mountains on three sides that block the player's view. You can setup a custom pattern 
            for this cell where no cells behind the mountains are loaded. This might allow you to make the game world within that cell 
            more detailed than it otherwise could be, since the resources normally used by those cells beyond the mountain can be freed up.
            </para>
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LODTransitionStrategy">
            <summary>
            This stategy determines what is prioritized when performing LOD transitions on a given World Grouping. The field is found on the World 
            component under <b>Default World Settings</b>, however you can override that general setting for a specific World Grouping under the 
            World Grouping's <b>World Grouping Overrides</b> section. Please consider that for any LOD transition, there is an <b>LOD From</b> World Cell (the 
            LOD being transitioned from) and an <b>LOD To</b> World Cell (the LOD being transitioned to). Keep this in mind when reading about the 
            different strategies.
            <para>
            SAM makes every attempt to reuse Asset Chunks when a World Cell to be deactivated and a World Cell to be activated 
            have the same Streamable Grid index (meaning the two cells use the same Asset Chunks). This is what is meant by reusing chunks when 
            reading the below paragraphs.
            </para>
            </summary>
            <title>LODTransitionStrategy Enumeration</title>
            <category>Enums</category>
            <navigationName>LODTransitionStrategy</navigationName>
            <fileName>LODTransitionStrategy.html</fileName>
            <syntax>public enum LODTransitionStrategy</syntax>
            <enumMember name="PrioritizeMemory" value="0">
            Prioritize reducing the memory footprint as much as possible when performing LOD transitions.
            <para>
            With this strategy, transitions FROM LOD 1 TO LODs GREATER THAN 1 will be performed first, and then transitions 
            FROM LODs GREATER THAN 1 TO LOD 1 will be performed after. This strategy gives the cells being transitioned 
            TO LOD 1 a greater chance of reusing Asset Chunks, reducing the chance of new chunks having to be loaded.
            </para>
            <para>
            In addition, after the FROM LODs GREATER THAN 1 TO LOD 1 transitions 
            are processed (resulting in the LOD 1 chunks being visible), we know that there will be no more transition to World Cells on LOD 1, 
            therefore we can pass along any remaining chunks from LOD 1 deactivated cells (either from transition TO LOD 1 cells or 
            non transitioned deactivated World Cells) to non transitioned LOD 1 World Cells that have yet to be activated. Then, if there are any 
            remaining chunks, we can pass them along to the Chunk Manager, which should either pool the chunks or 
            pass them to the Chunk Streamer for unloading from the scene. This process results in uneeded LOD 1 chunks (which generally 
            take up the most memory) being unloaded from the scene faster than in any other strategy.
            </para>
            <para>
            After processing FROM LOD 1 TO LODs GREATER THAN 1 transitions and FROM LODs GREATER THAN 1 TO LOD 1, 
            the World Grouping looks for LOD 2 to LODs GREATER THAN 2 transitions and processes them, then FROM LODs GREATER THAN 2 TO LOD 2 transitions, 
            and the process repeats until all transitions are processed and all unused chunks are pooled or unloaded from the scene.
            </para>
            <para>
            The drawback with this strategy is that Asset Chunks further away from the player may be transitioned before Asset Chunks 
            closer to the player. If this is not a concern for you, then you should choose this strategy.
            </para>
            </enumMember>
            <enumMember name="PrioritizeProximity" value="1">
            Prioritize changing higher quality LODs first, which under normal circumstances, 
            should be closer to your player (thus the Proximity keyword). 
            <para>
            With this strategy, all transitions FROM LODs GREATER THAN 1 TO LOD 1 are processed first, 
            followed by all transitions from LODs NOT EQUAL TO 2 to LOD 2, then FROM LODs NOT EQUAL TO 3 TO LOD 3, 
            and so on. As you can hopefully see, this strategy introduces a 0% chance of transitioned FROM LOD 1 World Cell chunks being
            resused by other transitions. The chance of reuse increases for each LOD processed (for example, after processing 
            LODs GREATER THAN 1 TO LOD 1 transitions, there may be transition FROM LOD 2 World Cell chunks that can be used during the 
            LOD NOT EQUAL TO 2 TO LOD 2 transitions). Even so, keep in mind that transitions 
            can still make use of non transitioned, already deactivated cells, and non transitioned LOD cells yet to 
            be activated can still make use of the chunks of transition FROM World Cells.
            </para>
            <para>
            With this strategy, all transitions are processed before passing along unused World Cell chunks to non transitioned World Cells 
            yet to be activated, and then after that, unused chunks are passed along to the Chunk Manager for 
            pooling or unloading. As such, this is the least memory efficient stategy of the three.
            </para>
            <para>
            The advantage is that Asset Chunks closer to the player should theoretically be transitioned more quickly, which reduces the 
            possibility of the player noticing the transition (if they are transitioned later, the player may get closer to the objects where 
            they can notice the transition more easily).
            </para>
            </enumMember>
            <enumMember name="PrioritizeUpgrades" value="2">
            Prioritize processing LOD upgrades (a transition from a larger number LOD to a smaller value LOD, like LODs 2->1, 3->1, etc.) 
            before downgrades (LODs 1->2, 1->3, 1->4, 2->3, etc.).
            <para>
            This strategy is somewhat of a balance between Prioritize Memory and Prioritize Proximity. Because LOD upgrades are usually triggered 
            by the player moving towards an area and downgrades triggered by the player moving away from an area, typically objects closer to the 
            players view will be transitioned first while objects farther away from the view will be transitioned last. However, if the player 
            is moving in one direction but facing the other, this might not be the case. Thus, it is closer to Prioritize Proximity than 
            Prioritize Memory is.
            </para>
            <para>
            First, upgrades FROM LODs GREATER THAN 1 TO LOD 1 are processed, followed by upgrades FROM LODS GREATER THAN 2 TO LOD 2, and so on. 
            This ensures that upgrades closer to the player are processed first. After processing all upgrades, downgrades FROM LOD 1 
            TO LODs GREATER THAN 1 are processed, followed by downgrades FROM LOD 2 TO LODs GREATER THAN 2, and so on.
            </para>
            <para>
            With regards to memory use, there are two advantages PrioritizeUpgrades has over Prioritize Proximity.
            </para>
            <para>
            First, while no FROM LOD 1 World Cell 
            chunks can be reused (since these cells are in the downgrade category and thus won't be processed yet), the first processing step 
            (involving FROM LODs GREATER THAN 1 TO LOD 1 transitions) does open up the possibility of some FROM LOD 2, 3, etc. World Cells being 
            reused in subsequent processing steps (for example, a FROM LOD 2 TO 1 transition occurs, freeing up chunks from LOD 2. These chunks might 
            then be reused in a TO LOD 2 transition World Cell).
            </para>
            <para>
            Second, after the first downgrade processing step (transitioning LOD 1 TO LODs GREATER THAN 1), 
            we can start passing along unused LOD 1 chunks to non transitioned yet to be activated 
            World Cells, and after that pass remaining unused LOD 1 chunks to the Chunk Manager for pooling or unloading. All 
            before continuing on to the next processing step (transitioning LOD 2 TO LODs GREATER THAN 2). Thus, we start freeing memory sooner than 
            we would with the Prioritize Proximity strategy (which must wait until after all transitions have been processed before freeing memory).
            </para>
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LODTransitionStrategy.PrioritizeMemory">
            <summary>
            Prioritize reducing the memory footprint as much as possible when performing LOD transitions.
            <para>
            With this strategy, transitions FROM LOD 1 TO LODs GREATER THAN 1 will be performed first, and then transitions 
            FROM LODs GREATER THAN 1 TO LOD 1 will be performed after. This strategy gives the cells being transitioned 
            TO LOD 1 a greater chance of reusing Asset Chunks, reducing the chance of new chunks having to be loaded.
            </para>
            <para>
            In addition, after the FROM LODs GREATER THAN 1 TO LOD 1 transitions 
            are processed (resulting in the LOD 1 chunks being visible), we know that there will be no more transition TO World Cells on LOD 1, 
            therefore we can pass along any remaining chunks from LOD 1 deactivated cells (either from transition TO LOD 1 cells or 
            non transitioned deactivated World Cells) to non transitioned LOD 1 World Cells that have yet to be activated. Then, if there are any 
            remaining chunks, we can pass them along to the Chunk Manager, which should either pool the chunks or 
            pass them to the Chunk Streamer for unloading from the scene. This process results in uneeded LOD 1 chunks (which generally 
            take up the most memory) being unloaded from the scene faster than in any other strategy.
            </para>
            <para>
            After processing FROM LOD 1 TO LODs GREATER THAN 1 transitions and FROM LODs GREATER THAN 1 TO LOD 1, 
            the World Grouping looks for LOD 2 to LODs GREATER THAN 2 transitions and processes them, then FROM LODs GREATER THAN 2 TO LOD 2 transitions, 
            and the process repeats until all transitions are processed and all unused chunks are pooled or unloaded from the scene.
            </para>
            <para>
            The drawback with this strategy is that Asset Chunks further away from the player may be transitioned before Asset Chunks 
            closer to the player. If this is not a concern for you, then you should choose this strategy.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LODTransitionStrategy.PrioritizeProximity">
            <summary>
            Prioritize changing to higher quality LODs first, which under normal circumstances, 
            should be closer to your player (thus the Proximity keyword). 
            <para>
            With this strategy, all upgrade transitions FROM LODs GREATER THAN 1 TO LOD 1 are processed first, followed by 
            transitions from LODs NOT EQUAL TO 2 to LOD 2, then FROM LODs NOT EQUAL TO 3 TO LOD 3, 
            and so on. As you can hopefully see, this strategy introduces a 0% chance of transitioned FROM LOD 1 World Cell chunks being
            resused by other transitions. The chance of reuse increases for each LOD processed (for example, after processing 
            LODs GREATER THAN 1 TO LOD 1 transitions, there may be transition FROM LOD 2 World Cell chunks that can be used during the 
            LOD NOT EQUAL TO 2 TO LOD 2 transitions). Even so, keep in mind that transitions 
            can still make use of non transitioned, already deactivated cells, and non transitioned LOD cells yet to 
            be activated can still make use of the chunks of transition FROM World Cells.
            </para>
            <para>
            With this strategy, all transitions are processed before passing along unused World Cell chunks to 
            non transitioned World Cells yet to be activated, and then after that, unused chunks are passed 
            along to the Chunk Manager for pooling or unloading.  As such, this is the least memory efficient stategy of the three.
            </para>
            <para>
            The advantage is that Asset Chunks closer to the player should theoretically be transitioned more quickly, which reduces the 
            possibility of the player noticing the transition (if they are transitioned later, the player may get closer to the 
            objects where they can notice the transition more easily). This strategy is especially useful when you expect your player 
            to be moving in one direction while looking off in another direction. If you expect your player to always be 
            facing the direction they are moving, the PrioritizeUpgrades strategy will most likely be better.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.LODTransitionStrategy.PrioritizeUpgrades">
            <summary>
            Prioritize processing LOD upgrades (a transition from a larger number LOD to a smaller value LOD, like LODs 2->1, 3->1, etc.) 
            before downgrades (LODs 1->2, 1->3, 1->4, 2->3, etc.).
            <para>
            This strategy is somewhat of a balance between Prioritize Memory and Prioritize Proximity. 
            Because LOD upgrades are usually triggered by the player moving towards an area and downgrades triggered 
            by the player moving away from an area, typically objects closer to the players view will be transitioned 
            first while objects farther away from the view will be transitioned last. However, if the player 
            is moving in one direction but facing the other, this might not be the case. Thus, it is closer to 
            Prioritize Proximity than Prioritize Memory is.
            </para>
            <para>
            First, upgrades FROM LODs GREATER THAN 1 TO LOD 1 are processed, followed by upgrades FROM LODS GREATER THAN 2 TO LOD 2, 
            and so on. This ensures that upgrades closer to the player are processed first. After processing all upgrades, 
            downgrades FROM LOD 1 TO LODs GREATER THAN 1 are processed, followed by downgrades FROM LOD 2 TO LODs GREATER THAN 2, 
            and so on.
            </para>
            <para>
            With regards to memory use, there are two advantages PrioritizeUpgrades has over Prioritize Proximity.
            </para>
            <para>
            First, while no FROM LOD 1 World Cell 
            chunks can be reused (since these cells are in the downgrade category and thus won't be processed yet), 
            the first processing step 
            (involving FROM LODs GREATER THAN 1 TO LOD 1 transitions) does open up the possibility of some FROM LOD 2, 3, etc. 
            World Cells being reused in subsequent processing steps (for example, a FROM LOD 2 TO 1 transition occurs, 
            freeing up chunks from LOD 2. These chunks might then be reused in a TO LOD 2 transition World Cell).
            </para>
            <para>
            Second, after the first downgrade processing step (transitioning LOD 1 TO LODs GREATER THAN 1), 
            we can start passing along unused LOD 1 chunks to non transitioned yet to be activated 
            World Cells, and after that pass remaining unused LOD 1 chunks to the Chunk Manager for pooling or unloading. All 
            before continuing on to the next processing step (transitioning LOD 2 TO LODs GREATER THAN 2). Thus, we start freeing memory sooner than 
            we would with the Prioritize Proximity strategy (which must wait until after all transitions have been processed before freeing memory).
            </para>
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.MemoryFreeingStrategy">
            <summary>
            Specifies a strategy for freeing memory (which is a call to Resources.UnloadUnusedAssets).
            <para>
            We recommend using DontFreeMemory in most cases, as the UnloadUnusedAssets call can cause performance issues. Usually it is better 
            to manually call this method, timing it such that the call is not noticed by the player.
            </para>
            </summary>
            <title>MemoryFreeingStrategy Enumeration</title>
            <category>Enums</category>
            <navigationName>MemoryFreeingStrategy</navigationName>
            <fileName>MemoryFreeingStrategy.html</fileName>
            <syntax>public enum MemoryFreeingStrategy</syntax>
            <enumMember name ="DontFreeMemory" value="0">
            Memory is not freed automatically. You have trigger it manually.
            </enumMember>
            <enumMember name ="FreeAfterEachChunk" value="1">
            Memory is freed automatically after a single Asset Chunk is destroyed.
            </enumMember>
            <enumMember name ="FreeAfterEachCell" value="2">
            Memory is freed automatically after all Asset Chunks from a single cell are destroyed.
            </enumMember>
            <enumMember name ="FreeAfterAllCells" value="3">
            Memory is freed automatically after all chunks on all cells for the Current operation are destroyed.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.MemoryFreeingStrategy.DontFreeMemory">
            <summary>
            Memory is not freed automatically. You have trigger it manually.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.MemoryFreeingStrategy.FreeAfterEachChunk">
            <summary>
            Memory is freed automatically after a single Asset Chunk is destroyed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.MemoryFreeingStrategy.FreeAfterEachCell">
            <summary>
             Memory is freed automatically after all Asset Chunks from a single cell are destroyed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.MemoryFreeingStrategy.FreeAfterAllCells">
            <summary>
            Memory is freed automatically after all chunks on all cells for the Current operation are destroyed.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.NullWorldCellError">
            <summary>
            Specifies the error that causes a World Cell to be null, when using one of the World Cell retrieval methods on the World, or when 
            accessing the WorldCellPlayerIsIn in an CellPlayerIsInChangedEventArgs object.
            </summary>
            <title>NullWorldCellError Enumeration</title>
            <category>Enums</category>
            <navigationName>NullWorldCellError</navigationName>
            <fileName>NullWorldCellError.html</fileName>
            <syntax>public enum NullWorldCellError</syntax>
            <enumMember name ="None" value="0">
            Indicates there is no error, which means the World Cell was retrieved.
            </enumMember>
            <enumMember name ="CellOutOfBounds" value="1">
            Indicates that the Endless Grid Cell used to retrieve the World Cell was out of bounds. 
            This can only happen if one or more axes are not set to repeating/endless.
            </enumMember>
            <enumMember name ="CellDisabled" value="2">
            Indicates there is no error, which means the World Cell was retrieved.
            </enumMember>
            <enumMember name ="CellHasNoUsers" value="3">
            Indicates that the World Cell could not be retrieved because there are no users of that World Cell. The Active Grid automatically 
            updates the World on which cells it is making use of. If not using an Active Grid, you will need to manually add and remove 
            users for Cells, or make use of World Regions.
            </enumMember>
            <enumMember name ="DesyncedFromWorld" value="4">
            Indicates that World Cell could not be retrieved because the Active Grid has been desynced from the World. 
            This error is only used with CellPlayerIsInChangedEventArgs objects.
            </enumMember>
            <enumMember name ="PlayerOutsideOfZone" value="5">
            Indicates that World Cell could not be retrieved because the Player is outside the boundaries of the indicated Zone, and thus not 
            in any Cells.
            </enumMember>
            <enumMember name ="NotAllWorldCellsActivated" value="6">
            Indicates that the World Cell could not be retrieved because the World has not loaded all World Cells. 
            This may happen in two scenarios.
            <para>
            The first is if you are attempting to retrieve the World Cell before SAM has been initialized via the SAMInitializer component.
            </para>
            <para>
            The second is if the World is currently performing an update, during the update the cell you are trying to access 
            may have already been removed from SAM (even though the chunks may still be in the scene), or the cell may not have had a 
            chance to load yet. You can use the World's 
            <see cref="M:DeepSpaceLabs.SAM.World.IsZoneGroupingUpdatingCells(System.Int32,System.Int32)" href="World.html#IsZoneGroupingUpdatingCells">IsZoneGroupingUpdatingCells</see> 
            method to determine if this is the case.
            </para>
            </enumMember>
            <enumMember name ="WorldUpdating" value="7">
            Indicates that the World Cell might not have been retrieved because the World is in the middle of an update, and the World Cell may have 
            already been removed from the World's internal collection of Cells (even though its asset chunks are still present in the scene), or it 
            may have yet to be added to the collection.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.None">
            <summary>
            Indicates there is no error, which means the World Cell was retrieved.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.CellOutOfBounds">
            <summary>
            Indicates that the Endless Grid Cell used to retrieve the World Cell was out of bounds. 
            This can only happen if one or more axes are not set to repeating/endless.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.CellDisabled">
            <summary>
            Indicates that the Endless Grid Cell used to retrieve the World Cell corresonded to a Streamable Grid Cell that was disabled.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.CellHasNoUsers">
            <summary>
            Indicates that the World Cell could not be retrieved because there are no users of that World Cell. The Active Grid automatically 
            updates the World on which cells it is making use of. If not using an Active Grid, you will need to manually add and remove 
            users for Cells, or make use of World Regions.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.DesyncedFromWorld">
            <summary>
            Indicates that World Cell could not be retrieved because the Active Grid has been desynced from the World. 
            This error is only used with CellPlayerIsInChangedEventArgs objects.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.PlayerOutsideOfZone">
            <summary>
            Indicates that World Cell could not be retrieved because the Player is outside the boundaries of the indicated Zone, and thus not 
            in any Cells.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.NotAllWorldCellsActivated">
            <summary>
            Indicates that the World Cell could not be retrieved because the World has not loaded all World Cells. 
            This may happen in two scenarios.
            <para>
            The first is if you are attempting to retrieve the World Cell before SAM has been initialized via the SAMInitializer component.
            </para>
            <para>
            The second is if the World is currently performing an update, during the update the cell you are trying to access 
            may have already been removed from SAM (even though the chunks may still be in the scene), or the cell may not have had a 
            chance to load yet. You can use the World's 
            <see cref="M:DeepSpaceLabs.SAM.World.IsZoneGroupingUpdatingCells(System.Int32,System.Int32)" href="World.html#IsZoneGroupingUpdatingCells">IsZoneGroupingUpdatingCells</see> 
            method to determine if this is the case.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.NullWorldCellError.WorldUpdating">
            <summary>
            Indicates that the World Cell might not have been retrieved because the World is in the middle of an update, and the World Cell may have 
            already been removed from the World's internal collection of Cells (even though its asset chunks are still present in the scene), or it 
            may have yet to be added to the collection.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.OriginCellChangeStrategy">
            <summary>
            Specifies a strategy for changing the Origin Cell of a <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see>.
            </summary>
            <title>OriginCellChangeStrategy Enumeration</title>
            <category>Enums</category>
            <navigationName>OriginCellChangeStrategy</navigationName>
            <fileName>OriginCellChangeStrategy.html</fileName>
            <syntax>public enum OriginCellChangeStrategy</syntax>
            <enumMember name ="ShiftWorld" value="0">
            Changing the Origin Cell using this method involves manually shifting the objects using a 
            <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">WorldShifter</see> class. You 
            can either use one of the default World Shifters provided, or create your own to enable more fine tuned 
            shifting, which may be necessary to mesh with your particular game (you'll be able to better factor in physics, for 
            exmaple).
            </enumMember>
            <enumMember name ="Duplicate World" value="1">
            Changing the Origin Cell using this method involves rebuilding the entire world at the origin, and then moving the player 
            once the duplicate world is loaded. This method avoids the issues with moving objects (so long as a suitable 
            <see cref="T:DeepSpaceLabs.SAM.PlayerMover" href="PlayerMover.html">Player Mover</see> is used), however as the world is effectively 
            duplicated, the memory used during the origin shift is double what the normal memory use of your game is, so may not 
            be suitable for your game. It also introduces the potential for overlapping assets, as the duplicated new world and the 
            old world will exist (and be visible) at the same time for a short period.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.OriginCellChangeStrategy.ShiftWorld">
            <summary>
            Changing the Origin Cell using this method involves manually shifting the objects using a 
            <see cref="T:DeepSpaceLabs.SAM.WorldShifter" href="WorldShifter.html">WorldShifter</see> class. You 
            can either use one of the default World Shifters provided, or create your own to enable more fine tuned 
            shifting, which may be necessary to mesh with your particular game (you'll be able to better factor in physics, for 
            exmaple).
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.OriginCellChangeStrategy.DuplicateWorld">
            <summary>
            Changing the Origin Cell using this method involves rebuilding the entire world at the origin, and then moving the player 
            once the duplicate world is loaded. This method avoids the issues with moving objects (so long as a suitable 
            <see cref="T:DeepSpaceLabs.SAM.PlayerMover" href="PlayerMover.html">Player Mover</see> is used), however as the world is effectively 
            duplicated, the memory used during the origin shift is double what the normal memory use of your game is, so may not 
            be suitable for your game. It also introduces the potential for overlapping assets, as the duplicated new world and the 
            old world will exist (and be visible) at the same time for a short period.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PlayerType">
            <summary>
            Specifies the type of player to use with an <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see>.
            </summary>
            <title>PlayerType Enumeration</title>
            <category>Enums</category>
            <navigationName>PlayerType</navigationName>
            <fileName>PlayerType.html</fileName>
            <syntax>public enum PlayerType</syntax>
            <enumMember name ="TransformPlayer" value="0">
            Use a traditional Transform based player. This allows you to assign a Transform component to use as the player.
            </enumMember>
            <enumMember name ="CustomPlayer" value="1">
            Use a CustomPlayer. This allows you to assign a component deriving from 
            <see cref="F:DeepSpaceLabs.SAM.PlayerType.CustomPlayer" href="CustomPlayer.html">CustomPlayer</see>, which is useful in situations 
            where your player isn't associated with a Transform (DOTs system, for instance).
            </enumMember>
            <enumMember name ="AssignAtRuntime" value="2">
            Forces you to assign the IPlayer or Transform to use as the player at runtime, via the PreInitialize_SetPlayer method. This is useful if your 
            player is only created at runtime.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.PlayerType.TransformPlayer">
            <summary>
            Use a traditional Transform based player. This allows you to assign a Transform component to use as the player.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.PlayerType.CustomPlayer">
            <summary>
            Use a CustomPlayer. This allows you to assign a component deriving from CustomPlayer, which is useful in situations 
            where your player isn't associated with a Transform (DOTs system, for instance).
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.PlayerType.AssignAtRuntime">
            <summary>
            Forces you to assign the IPlayer or Transform to use as the player at runtime, via the PreInitialize_SetPlayer method. This is useful if your 
            player is only created at runtime.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.RootState">
            <summary>
            Specifies the State (Activated or Deactivated) of the root Game Object 
            Asset Chunks when using Scene Based Asset Chunks for a particular LOD Group.
            <para>
            The setting is ingored when the LOD Group does not use Scene Based Asset Chunks.
            </para>
            </summary>
            <title>RootState Enumeration</title>
            <category>Enums</category>
            <navigationName>RootState</navigationName>
            <fileName>RootState.html</fileName>
            <syntax>public enum RootState</syntax>
            <enumMember name ="Deactivated" value="0">
            Indicates that the root Game Objects in each scene based asset chunk is stored in 
            a deactivated state. This is generally recommended as it makes the scenes work well 
            with SAM's various systems, such as Origin Shifting and Cell Visual Transition Controllers.
            </enumMember>
            <enumMember name ="Activated" value="1">
            Indicates that the root Game Objects in each scene based asset chunk is stored in 
            an activated state. This is generally not recommended unless you need to use the 
            asset chunks with Unity's editor based Static Batching.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.RootState.Deactivated">
            <summary>
            Indicates that the root Game Objects in each scene based asset chunk is stored in 
            a deactivated state. This is generally recommended as it makes the scenes work well 
            with SAM's various systems, such as Origin Shifting and 
            Cell Visual Transition Controllers.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.RootState.Activated">
            <summary>
            Indicates that the root Game Objects in each scene based asset chunk is stored in 
            an activated state. This is generally not recommended unless you need to use the 
            asset chunks with Unity's editor based Static Batching.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SortingMethod">
            <summary>
            Specifies the type of algorithm for Scene Chunk Streamers to use 
            to sort Build Setting scenes (used by Scene Chunk Streamers).
            </summary>
            <title>SortingMethod Enumeration</title>
            <category>Enums</category>
            <navigationName>SortingMethod</navigationName>
            <fileName>SortingMethod.html</fileName>
            <syntax>public enum SortingMethod</syntax>
            <enumMember name ="CustomNormal" value="0">
            A custom sorting algorithm optimized for the most probable Build Setting configuration, 
            which is a collection of pre-sorted scene groups corresponding to individual Asset Chunk Groups.
            <para>
            Within each group, the scenes are sorted in normal order, with smaller valued row/column/layer numbers 
            preceding larger valued row/column/layer numbers (assuming all other characters are equal).
            </para>
            </enumMember>
            <enumMember name ="CustomReversed" value="1">
            A custom sorting algorithm optimized situations where the Build Setting scenes are in individual 
            groups, but where the scenes within each group are sorted in reverse order (with larger valued row/column/layer numbers preceding smaller valued row/column/layer numbers (assuming all other characters are equal).
            </enumMember>
            <enumMember name ="Quick" value="2">
            A rudimentary quick sort algorithm, which will usually work better when the Build Setting scenes are not 
            already in order.
            </enumMember>
            <enumMember name="Insertion" value ="3">
            A rudimentary insertion sort algorithm, which will usually be slower than the other algorithms but 
            is present in case you want to try it out.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.SortingMethod.CustomNormal">
            <summary>
            A custom sorting algorithm optimized for the most probable Build Setting configuration, 
            which is a collection of pre-sorted scene groups corresponding to individual Asset Chunk Groups.
            <para>
            Within each group, the scenes are sorted in normal order, with smaller valued row/column/layer numbers 
            preceding larger valued row/column/layer numbers (assuming all other characters are equal).
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.SortingMethod.CustomReversed">
            <summary>
            A custom sorting algorithm optimized situations where the Build Setting scenes are in individual 
            groups, but where the scenes within each group are sorted in reverse order (with larger valued row/column/layer numbers preceding smaller valued row/column/layer numbers (assuming all other characters are equal).
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.SortingMethod.Quick">
            <summary>
            A rudimentary quick sort algorithm, which will usually work better when the Build Setting scenes are not 
            already in order.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.SortingMethod.Insertion">
            <summary>
            A rudimentary insertion sort algorithm, which will usually be slower than the other algorithms but 
            is present in case you want to try it out.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.VisualState">
             <summary>
             Specifies the visual state of a <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see>. This is used in conjuction with 
             <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">CellVisualTransitionControllers</see>.
             </summary>
             <title>VisualState Enumeration</title>
             <category>Enums</category>
             <navigationName>VisualState</navigationName>
             <fileName>VisualState.html</fileName>
             <syntax>public enum VisualState</syntax>
             <enumMember name ="Invisible" value="0">
            Indicates that the World Cell is in an invisible state. In this state it is expected that the objects 
             belonging to the World Cell cannot be seen by the player, although this is not stricly enforced, so if 
             you want your objects to be visible even in this state, that is your choice.
             </enumMember>
             <enumMember name ="Visible" value="1">
             Indicates that the World Cell is in a visible visual state. In this state it is required that the 
             objects belonging to the World Cell can be seen by the player.
             </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.VisualState.Invisible">
            <summary>
            Indicates that the World Cell is in an invisible state. In this state it is expected that the objects 
            belonging to the World Cell cannot be seen by the player, although this is not stricly enforced, so if 
            you want your objects to be visible even in this state, that is your choice.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.VisualState.Visible">
            <summary>
            Indicates that the World Cell is in a visible visual state. In this state it is required that the 
            objects belonging to the World Cell can be seen by the player.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WhatToShift">
            <summary>
            Specifies what should be shifted by a 
            <see cref="T:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter" href="StandardHierarchyWorldShifter.html">Standard Hierarchy World Shifter</see>.
            </summary>
            <title>WhatToShift Enumeration</title>
            <category>Enums</category>
            <navigationName>WhatToShift</navigationName>
            <fileName>WhatToShift.html</fileName>
            <syntax>public enum WhatToShift</syntax>
            <enumMember name ="ShiftRootTransform" value="0">
            Shift the root transform in the standard hiearchy only.
            </enumMember>
            <enumMember name ="ShiftBaseCellTransforms" value="1">
            Shift the Base Cell transforms in the standard hiearchy.
            </enumMember>
            <enumMember name ="ShiftWorldGroupingTransforms" value="2">
            Shift the World Grouping transforms in the standard hiearchy.
            </enumMember>
            <enumMember name ="ShiftLODTransforms" value="3">
            Shift the LOD transforms in the standard hiearchy.
            </enumMember>
            <enumMember name ="ShiftWorldCellTransforms" value="4">
            Shift the World Cell transforms in the standard hiearchy.
            </enumMember>
            <enumMember name ="ShiftChunkTransforms" value="5">
            Shift the Chunk transforms in the standard hiearchy.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhatToShift.ShiftRootTransform">
            <summary>
            Shift the root transform in the standard hiearchy only.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhatToShift.ShiftBaseCellTransforms">
            <summary>
            Shift the Base Cell transforms in the standard hiearchy.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhatToShift.ShiftWorldGroupingTransforms">
            <summary>
            Shift the World Grouping transforms in the standard hiearchy.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhatToShift.ShiftLODTransforms">
            <summary>
            Shift the LOD transforms in the standard hiearchy.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhatToShift.ShiftWorldCellTransforms">
            <summary>
            Shift the World Cell transforms in the standard hiearchy.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhatToShift.ShiftChunkTransforms">
            <summary>
            Shift the Asset Chunk transforms in the standard hiearchy.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WhenToShift">
            <summary>
            When using a 
            <see cref="T:DeepSpaceLabs.SAM.StandardHierarchyWorldShifter" href="StandardHierarchyWorldShifter.html">Standard Hierarchy World Shifter</see> 
            determine when to execute all code related to the world shift. Note, options other than 'Update' will only be used if the World 
            Shifter's Perform Shift In Single Frame option is disabled.
            <para>
            When a player is set to be shifted, if a PlayerMover is present on the Player, it's MovePlayerByAmount coroutine will be used to move 
            the player, and will begin execution at the time specified by this field. Immediately after this coroutine finishes, the transforms of the 
            world will be shifted at once. If your PlayerMover changes the execution frame (from Update to FixedUpdate) for instance, that may cause 
            issues, so be careful.
            </para>
            </summary>
            <title>WhenToShift Enumeration</title>
            <category>Enums</category>
            <navigationName>WhenToShift</navigationName>
            <fileName>WhenToShift.html</fileName>
            <syntax>public enum WhenToShift</syntax>
            <enumMember name ="FixedUpdate" value="0">
            Perform the shift during Fixed Update.
            </enumMember>
            <enumMember name ="Update" value="1">
            Perform the shift during Update.
            </enumMember>
            <enumMember name ="EndOfFrame" value="2">
            Perform the shift during the End of Frame.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhenToShift.FixedUpdate">
            <summary>
            Perform the shift during Fixed Update.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhenToShift.Update">
            <summary>
            Perform the shift during Update.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WhenToShift.EndOfFrame">
            <summary>
            Perform the shift during the End of Frame.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldSleepMode">
            <summary>
            Specifies under what conditions the <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see> will be put into sleep mode while it is up and running.
            </summary>
            <title>WorldSleepMode Enumeration</title>
            <category>Enums</category>
            <navigationName>WorldSleepMode</navigationName>
            <fileName>WorldSleepMode.html</fileName>
            <syntax>public enum WorldSleepMode</syntax>
            <enumMember name ="NoUsers" value="0">The World will be put to sleep as soon as no users are registered with it, even if World Groupings still have 
            <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cells</see>. This is the default.</enumMember>
            <enumMember name ="NoWorldCells" value="1">The World will be put to sleep only when all World Groupings have no World Cells. If at least one World Grouping 
            has one World Cell, it will not be put to sleep. The number of registered users does not matter.</enumMember>
            <enumMember name ="NoWorldCellsAndUsers" value="2">The World will be put to sleep only when all World Groupings have no World Cells 
            <b>and</b> when there are no users registered with the World. A single user or World Cell will keep it from going to sleep.</enumMember>
            <enumMember name = "NeverSleep" value="3">The World will never be put to sleep (after being awoken for the first time). 
            Not recommended but its an option if you like.</enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldSleepMode.NoUsers">
            <summary>
            The World will be put to sleep as soon as no users are registered with it, even if World Groupings still have 
            World Cells. This is the default.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldSleepMode.NoWorldCells">
            <summary>
            The World will be put to sleep only when all World Groupings have no World Cells. If at least one World Grouping 
            has one World Cell, it will not be put to sleep. The number of registered users does not matter.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldSleepMode.NoWorldCellsAndUsers">
            <summary>
            The World will be put to sleep only when all World Groupings have no World Cells and when there are no users 
            registered with the World. A single user or World Cell will keep it from going to sleep.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldSleepMode.NeverSleep">
            <summary>
            The World will never be put to sleep (after being awoken for the first time). 
            Not recommended but its an option if you like.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldState">
            <summary>
            Specifies the state of a <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see>.
            </summary>
            <title>WorldState Enumeration</title>
            <category>Enums</category>
            <navigationName>WorldState</navigationName>
            <fileName>WorldState.html</fileName>
            <syntax>public enum WorldState</syntax>
            <enumMember name ="Uninitialized" value="0">
            The initial state of the World, before it has been initialized by a component manager. If creating the world via 
            one of the component manager's create world methods, the world will never be in this state, since the 
            component manager automatically initializes the world when it is created.
            </enumMember>
            <enumMember name ="Sleeping" value="1">
            The state of the World after Initialization, while the World has no registered users and/or cell user request. 
            Once the world exits the Sleeping state, it will only enter it again if certain conditions are met (as determined 
            by its World Sleep Mode).
            <para>
            Note that even if a World is sleeping, it still may have loaded World Cells.
            </para>
            </enumMember>
            <enumMember name ="WaitingForInput" value="2">
            Standard phase when the World is waiting for input (either in the form of manual input from the user 
            that triggers a secondary operation, or in user add/remove request and/or Origin Cell update which triggers a world update).
            </enumMember>
            <enumMember name ="PerformingSecondaryOperation" value="3">
            Indiciates the World is currently performing a secondary operation, such as a Group Name change or clamping operation.
            <para>
            Becuase secondary operations can result in asset changes or modifications to World Cell data, this Phase and 
            all phases after should be considered as part of the World Update cycle.
            </para>
            </enumMember>
             <enumMember name ="ProcessingRequest" value="4">
            The World enters this state when it has received cell user add and/or remove request. In this state, duplicate and/or offsetting 
            request are removed.
            </enumMember>
            <enumMember name = "AwaitingUsers" value="5">
            After processing user requests, if the World is determined to need an Origin Cell Change, all World Users will be queried to 
            make sure they are ready for the change. If at least one user is not ready, the World yields for a frame and then checks 
            all users again, repeating the cycle until all users are ready. During this cycle, the World will be in this state. 
            If all users are ready the first time they are queried, this Phase is skipped.
            </enumMember>
            <enumMember name ="UpdatingGroupingsWithoutOriginCellChange" value="6">
            The World enters this state after processing a batch of cell user add/remove request, when at least one request
            survives the processing phase, and an Origin Cell change IS NOT NEEDED. 
            During this state, World Cells are added and removed from Groupings as needed.
            </enumMember>
            <enumMember name ="UpdatingGroupingsWithOriginCellChange" value="7">
            The World enters this state after processing a batch of cell user add/remove request, when at least one request
            survives the processing phase, and an origin reset IS NEEDED. In this state, World Cells are removed/added from 
            each World Grouping as needed while the origin reset is simultaneously processed. During this state any Active Grids 
            registered with the World are notified so they can enter a 'busy' state until the shift is complete.
            </enumMember>
            <enumMember name ="NotifyingUsersThatOriginCellChangeWasCompleted" value="8">
            The World enters this state after completing Grouping Updates that contained an Origin Cell Change. In this state, all 
            World Users are notified that the Origin Cell change was completed.
            </enumMember>
            <enumMember name = "InvokingCallbacks" value="9">
            After Grouping Updates (or after cell user additions/removals have been processed and no Grouping Updates were needed) 
            the World invokes user fulfilled callbacks for any callbacks that were added before cell user processing finished. 
            Because all callbacks are invoked in a single frame, the World is only in this state 
            for a single frame while the callbacks are being invoked. As such, this state is intended to only be 
            queried by the callback methods themselves. It also ensures that 
            if the callback methods add additional user fullfilled callbacks, they are added to the next world update's callback list.
            </enumMember>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.Uninitialized">
            <summary>
            The initial state of the World, before it has been initialized by a component manager. If creating the world via 
            one of the component manager's create world methods, the world will never be in this state, since the 
            component manager automatically initializes the world when it is created. Most methods of the World cannot 
            be called until after it is Initialized, so if you are not sure if it is, query the WorldState on the World to check.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.Sleeping">
            <summary>
            The state of the World after Initialization, while the World has no registered users and/or cell user request. 
            Once the world exits the Sleeping state, it will only enter it again if certain conditions are met (as determined 
            by its World Sleep Mode).
            <para>
            Note that even if a World is sleeping, it still may have loaded World Cells.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.WaitingForExecutionStart">
            <summary>
            After exiting the Sleeping state, the World will query the Execution Controller associated with it to 
            determine if the World should begin executing. Until the controller tells it to begin execution, 
            the state will be this.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.WaitingForInput">
            <summary>
            Standard phase when the World is waiting for input (either in the form of manual input from the user 
            that triggers a secondary operation, or in user add/remove request and/or Origin Cell update which triggers a world update).
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.PerformingSecondaryOperation">
            <summary>
            Indiciates the World is currently performing a secondary operation, such as a Group Name change or clamping operation.
            <para>
            Becuase secondary operations can result in asset changes or modifications to World Cell data, this Phase and 
            all phases after should be considered as part of the World Update cycle.
            </para>
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.ProcessingRequests">
            <summary>
            The World enters this state when it has received cell user add and/or remove request. 
            In this state, the World processes both add and remove requests, cancelling competing orders out to 
            avoid unecessary loading/unloading.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.AwaitingUsers">
            <summary>
            After processing user requests, if the World is determined to need an Origin Cell Change, all World Users will be queried to 
            make sure they are ready for the change. If at least one user is not ready, the World yields for a frame and then checks 
            all users again, repeating the cycle until all users are ready. During this cycle, the World will be in this state. If all users are 
            ready the first time they are queried, this Phase is skipped.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.UpdatingGroupingsWithoutOriginCellChange">
            <summary>
            The World enters this state after processing a batch of cell user add/remove request, when at least one request
            survives the processing phase, and an Origin Cell change IS NOT NEEDED. 
            During this state, World Cells are added and removed from Groupings as needed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.UpdatingGroupingsWithOriginCellChange">
            <summary>
            The World enters this state after processing a batch of cell user add/remove request, when at least one request
            survives the processing phase, and an origin reset IS NEEDED. In this state, World Cells are removed/added from 
            each World Grouping as needed while the origin reset is simultaneously processed. During this state any Active Grids 
            registered with the World are notified so they can enter a 'busy' state until the shift is complete.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.NotifyingUsersThatOriginCellChangeWasCompleted">
            <summary>
            The World enters this state after completing Grouping Updates that contained an Origin Cell Change. In this state, all 
            World Users are notified that the Origin Cell change was completed.
            </summary>
        </member>
        <member name="F:DeepSpaceLabs.SAM.WorldState.InvokingCallbacks">
            <summary>
            After Grouping Updates (or after cell user additions/removals have been processed and no Grouping Updates were needed) 
            the World invokes user fulfilled callbacks for any callbacks that were added before cell user processing finished. 
            Because all callbacks are invoked in a single frame, the World is only in this state 
            for a single frame while the callbacks are being invoked. As such, this state is intended to only be 
            queried by the callback methods themselves. It also ensures that 
            if the callback methods add additional user fullfilled callbacks, they are added to the next world update's callback list.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.DataConversionException">
            <summary>
            The exception that is thrown when a save data conversion operation (via the 
            <see cref="T:DeepSpaceLabs.SAM.ComponentManager" href="ComponentManager.html">Component Manager</see>) fails.
            </summary>
            <title>DuplicateIDException Class</title>
            <category>Exceptions</category>
            <navigationName>DataConversionException</navigationName>
            <fileName>DataConversionException.html</fileName>
            <syntax>public class DataConversionException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.DuplicateIDException">
            <summary>
            The exception that is thrown when multiple components of the same type in the same scene have the same ID.
            </summary>
            <title>DuplicateIDException Class</title>
            <category>Exceptions</category>
            <navigationName>DuplicateIDException</navigationName>
            <fileName>DuplicateIDException.html</fileName>
            <syntax>public class DuplicateIDException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.HierarchyException">
            <summary>
            The exception that is thrown when there is an issue or conflict with a Hierarhcy Organizer.
            </summary>
            <title>HierarchyException Class</title>
            <category>Exceptions</category>
            <navigationName>HierarchyException</navigationName>
            <fileName>HierarchyException.html</fileName>
            <syntax>public class HierarchyException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InitializedSAMObjectException">
            <summary>
            The exception that is thrown when a method of a SAM object has been called after that object has been 
            initialized. This indicates the method must be called before the object has been initialized.
            </summary>
            <title>InitializedSAMObjectException Class</title>
            <navigationName>InitializedSAMObjectException</navigationName>
            <fileName>InitializedSAMObjectException.html</fileName>
            <syntax>public class InitializedSAMObjectException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InvalidPrototypeException">
            <summary>
            The exception that is thrown when trying to create a <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see> or 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see> at runtime from a prototype that does not exist.
            </summary>
            <title>InvalidPrototypeException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidPrototypeException</navigationName>
            <fileName>InvalidPrototypeException.html</fileName>
            <syntax>public class InvalidPrototypeException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InvalidPersistentDataException">
            <summary>
            The exception that is thrown when the persistent data for a 
            <see cref="T:DeepSpaceLabs.SAM.ComponentManager" href="ComponentManager.html">Component Manager</see> is not valid.
            </summary>
            <title>InvalidPersistentDataException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidPersistentDataException</navigationName>
            <fileName>InvalidPersistentDataException.html</fileName>
            <syntax>public class InvalidPersistentDataException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InvalidIDException">
            <summary>
            The exception that is thrown when a supplied ID does not match a valid component.
            </summary>
            <title>InvalidIDException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidIDException</navigationName>
            <fileName>InvalidIDException.html</fileName>
            <syntax>public class InvalidIDException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InvalidNameException">
            <summary>
            The exception that is thrown when a supplied name does not match a valid name.
            </summary>
            <title>InvalidIDException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidNameException</navigationName>
            <fileName>InvalidNameException.html</fileName>
            <syntax>public class InvalidNameException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.InvalidPersistenceException">
            <summary>
            The exception that is thrown when an attempt is made to sync a persistent 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grid</see> 
            to a non persistent <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see>.
            </summary>
            <title>InvalidPersistenceException Class</title>
            <category>Exceptions</category>
            <navigationName>InvalidPersistenceException</navigationName>
            <fileName>InvalidPersistenceException.html</fileName>
            <syntax>public class InvalidPersistenceException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.LoadingBlueprintException">
            <summary>
            The exception that is thrown when information is requested from a loading blueprint regarding an LOD, but that 
            loading blueprint doesn't have information on that LOD.
            </summary>
            <title>LoadingBlueprintException Class</title>
            <category>Exceptions</category>
            <navigationName>LoadingBlueprintException</navigationName>
            <fileName>LoadingBlueprintException.html</fileName>
            <syntax>public class LoadingBlueprintException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.MissingAssetException">
            <summary>
            The exception that is thrown when an asset SAM expects to find is missing.
            </summary>
            <title>MissingAssetException Class</title>
            <category>Exceptions</category>
            <navigationName>MissingAssetException</navigationName>
            <fileName>MissingAssetException.html</fileName>
            <syntax>public class MissingAssetException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.RequiredComponentNotFoundException">
            <summary>
            The exception that is thrown when a required component or Scriptable Object asset are not found on a component that needs to use them.
            </summary>
            <title>RequiredComponentNotFoundException Class</title>
            <category>Exceptions</category>
            <navigationName>RequiredComponentNotFoundException</navigationName>
            <fileName>RequiredComponentNotFoundException.html</fileName>
            <syntax>public class RequiredComponentNotFoundException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.SceneNotFoundException">
            <summary>
            The exception that is thrown when a <see cref="T:DeepSpaceLabs.SAM.SceneChunkStreamer" href="SceneChunkStreamer.html">Scene Chunk Streamer</see> Component cannot 
            find a newly loaded scene.
            </summary>
            <title>SceneNotFoundException Class</title>
            <category>Exceptions</category>
            <navigationName>SceneNotFoundException</navigationName>
            <fileName>SceneNotFoundException.html</fileName>
            <syntax>public class SceneNotFoundException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException">
            <summary>
            The exception that is thrown when a member of a SAM object that can only be accessed after the object 
            has been initilialized is accessed before that object has been initialized.
            </summary>
            <title>UninitializedSAMObjectException Class</title>
            <navigationName>UninitializedSAMObjectException</navigationName>
            <fileName>UninitializedSAMObjectException.html</fileName>
            <syntax>public class UninitializedSAMObjectException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.StreamableGridMismatchException">
            <summary>
            The exception that is thrown when a 
            <see cref="T:DeepSpaceLabs.SAM.StreamableGrid" href="StreamableGrid.html">Streamable Grid</see> on layers 2+ are a mismatch with the Streamable Grid on layer 1, i.e., they 
            cannot be used together.
            </summary>
            <title>StreamableGridMismatchException Class</title>
            <category>Exceptions</category>
            <navigationName>StreamableGridMismatchException</navigationName>
            <fileName>StreamableGridMismatchException.html</fileName>
            <syntax>public class StreamableGridMismatchException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldEnumeratorException">
            <summary>
            The exception that is thrown when there is an error within a <see cref="T:DeepSpaceLabs.SAM.YieldEnumerator" href="YieldEnumerator.html">Yield Enumerator</see>.
            </summary>
            <title>YieldEnumeratorException Class</title>
            <category>Exceptions</category>
            <navigationName>YieldEnumeratorException</navigationName>
            <fileName>YieldEnumeratorException.html</fileName>
            <syntax>public class YieldEnumeratorException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ZoneException">
            <summary>
            The exception that is thrown when there is an error with a particular World Zone or all Zones on the World.
            </summary>
            <title>ZoneException Class</title>
            <category>Exceptions</category>
            <navigationName>ZoneException</navigationName>
            <fileName>ZoneException.html</fileName>
            <syntax>public class ZoneException : Exception</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.CellString">
            <summary>
            The only ICellString implementation you should ever need. Can handle 3D/2D worlds and LODs that utilize 
            multi chunking. This class is responsible for taking in a Streamable Grid Cell Index and Chunk Index and outputting 
            a correctly formatted string that can be used as a key to load the chunk in question. It utilizes the naming convention used by each LOD, 
            as well as any extra data to prepend or append to the generated string.
            </summary>
            <title>CellString Class</title>
            <category>Secondary Non Components</category>
            <navigationName>CellString</navigationName>
            <fileName>CellString.html</fileName>
            <syntax>public class CellString</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellString.ChunkName">
            <summary>
            Gets the name of the chunk associated with the Streamable Grid Cell and chunk passed into the 
            last MatchStringToCell method call. This can and should only be used 
            for naming your objects. It should not be used for actually loading your objects, as it does not take into account any data to prepend or append that 
            you may have passed into the Cell String's constructor. For that, you should use the ChunkLoadKey property, which 
            combines this ChunkName string with data to prepend and append.
            <para>
            This property can be accessed repeatedly without generating garbage.
            </para>
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellString.ChunkLoadKey">
            <summary>
            Gets a string that can be used to load the chunk associated with the Streamable Grid Cell and chunk passed into the 
            last MatchStringToCell method call. This string takes into account any data to prepend or append that might have been passed into 
            the Cell String's constructor or UpdateCellString method. It should not be used for naming objects, as the name should not include 
            prepend/append data.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellString.GetChunkNameAndLoadKey_MultithreadingSupported">
            <summary>
            Gets a method for retrieving the Chunk Name and Chunk Load Key given a Cell and chunk number.
            <para>
            The difference between this method and MatchStringToCell is that this method does not store the Chunk Name and 
            Chunk Load Key that is generated, and as such you cannot use the 
            ChunkName, ChunkLoadKey, or IsEqualTo method. The advantage is because nothing is stored, the method should 
            be safe to use in multithreaded code.
            </para>
            <para>
            The first argument for this method is the Streamable Grid Index of the World Cell. 
            The second is the 1 based index of the chunk you are trying to match the string to.
            </para>
            </summary>
            <type>GetChunkInfoDel delegate</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellString.BaseName">
            <summary>
            The base name of the Cell String. This should match the base name of the object group associated with your World.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellString.PrependLoadStringData">
            <summary>
            Returns the data to prepend when generating load strings for this CellString object, or "" if there is no prepend data.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.CellString.AppendLoadStringData">
            <summary>
            Returns the data to append when generating load strings for this CellString object, or "" if there is no append data.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellString.#ctor(System.String,DeepSpaceLabs.Core.INamingConvention,System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Creates a Cell String object.
            </summary>
            <param name="baseName" type="string">
            The base name shared among all cells.
            </param>
            <param name="namingConvention" type="INamingConvention" link="INamingConvention.html">
            The naming convention that details how the cell string should be constructed.
            </param>
            <param name="is3DCellString" type="bool">
            Is the cell string going to be used with a 3D world?
            </param>
            <param name="useMultiChunkNaming" type="bool">
            Is the cell string going to be used with LODs that utilize multi chunking?
            </param>
            <param name="dataToPrependWhenGeneratingLoadString" type="[string]">
            Optional data to prepend to every ChunkLoadKey string generated by this Cell String object. Using this data (or dataToAppendWhenGeneratingLoadString) 
            does result in two strings being produced everytime MatchStringToCell is used, however in some instances this cannot be helped.
            </param>
            <param name="dataToAppendWhenGeneratingLoadString" type="[string]">
            Optional data to append to every ChunkLoadKey string generated by this Cell String object. Using this data (or dataToPrependWhenGeneratingLoadString) 
            does result in two strings being produced everytime MatchStringToCell is used, however in some instances this cannot be helped.
            </param>
            <displayName id="CellString">
            CellString(string, INamingConvention, bool, bool, [string], [string])
            </displayName>
            <syntax>
            public CellString(string baseName, INamingConvention namingConvention, bool is3DCellString, bool useMultiChunkNaming, string dataToPrependWhenGeneratingLoadString = null, string dataToAppendWhenGeneratingLoadString = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellString.UpdateCellString(System.String,DeepSpaceLabs.Core.INamingConvention,System.Boolean,System.Boolean,System.String,System.String)">
            <summary>
            Updates a Cell String object to use a new base name and naming convention. This allows you to reuse the Cell String 
            object to represent different assets. Do note that this method is not without garbage generation, so it is best not to 
            abuse it.
            </summary>
            <param name="baseName" type="string">
            The base name shared among all cells.
            </param>
            <param name="namingConvention" type="INamingConvention" link="INamingConvention.html">
            The naming convention that details how the cell string should be constructed.
            </param>
            <param name="is3DCellString" type="bool">
            Is the cell string going to be used with a 3D world?
            </param>
            <param name="useMultiChunkNaming" type="bool">
            Is the cell string going to be used with LODs that utilize multi chunking?
            </param>
            <param name="dataToPrependWhenGeneratingLoadString" type="[string]">
            Optional data to prepend to every ChunkLoadKey string generated by this Cell String object. Using this data (or dataToAppendWhenGeneratingLoadString) 
            does result in two strings being produced everytime MatchStringToCell is used, however in some instances this cannot be helped.
            </param>
            <param name="dataToAppendWhenGeneratingLoadString" type="[string]">
            Optional data to append to every ChunkLoadKey string generated by this Cell String object. Using this data (or dataToPrependWhenGeneratingLoadString) 
            does result in two strings being produced everytime MatchStringToCell is used, however in some instances this cannot be helped.
            </param>
            <displayName id="UpdateCellString">
            UpdateCellString(string, INamingConvention, bool, bool, [string], [string])
            </displayName>
            <syntax>
            public void UpdateCellString(string baseName, INamingConvention namingConvention, bool is3DCellString, bool useMultiChunkNaming, string dataToPrependWhenGeneratingLoadString = null, string dataToAppendWhenGeneratingLoadString = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellString.MatchStringToCell(DeepSpaceLabs.SAM.Cell,System.Int32)">
            <summary>
            After calling this method, ChunkName will be set to a string that represents the file name of whatever asset is associated with the input Streamable Grid Cell and 
            chunk index, and ChunkLoadKey will return a string that can be used to load this object.
            <para>
            If you are trying to generate the ChunkName and ChunkLoadKey in multithreaded code, use the GetChunkNameAndLoadKey_MultithreadingSupported method instead.
            </para>
            </summary>
            <param name="cell" type="Cell" link="Cell.html">
            The Streamable Grid Index of the World Cell to match the string to.
            </param>
            <param name="chunkIndex" type="int">
            The 1 based index of the chunk to match the string to.
            </param>
            <displayName id="MatchStringToCell">
            MatchStringToCell(Cell, int)
            </displayName>
            <syntax>
            public void MatchStringToCell(Cell cell, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellString.IsEqualTo(System.String)">
            <summary>
            Checks whether the provided string (str) matches the Chunk Name String.
            </summary>
            <param name="str" type="string">The string to compare the Cell String to.</param>
            <displayName id = "IsEqualTo">IsEqualTo(string)</displayName>
            <syntax>public abstract bool IsEqualTo(string str)</syntax>
            <returns type = "bool">A bool indicating whether the input string matches the Cell String.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.CellString.TryGetCellDataFromChunkName(System.String,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Attempts to get cell data from the chunk named passed in. This can also be used as a way to validate that a specific object belongs to a 
            specific World and World Grouping, assuming the CellString has been configured correctly for that World and World Grouping. Note that it is a 
            computationally expensive method, so generally should not be called multiple times in a single frame in game.
            </summary>
            <param name="chunkName" type="string">
            The name of the object associated with the cell. This name must contain the Group Name associated with the CellString or else the method will return false.
            </param>
            <param name="row" type="int">
            The row of the cell which the chunk belongs to.
            </param>
            <param name="column" type="int">
            The column of the cell which the chunk belongs to.
            </param>
            <param name="layer" type="int">
            The layer of the cell which the chunk belongs to. Will always be 1 if the chunk belongs to a 2D World Grouping.
            </param>
            <param name="chunkIndex" type="int">
            The chunk index of the chunk. Will always be 1 if the chunk belongs to a World Grouping that does not use multi chunking.
            </param>
            <returns type="bool">
            True if the data was retrieved, false otherwise. Will only return true if the format of the name matches what's expected.
            </returns>
            <displayName id="TryGetCellDataFromChunkName">
            TryGetCellDataFromChunkName(string, out int, out int, out int, out int)
            </displayName>
            <syntax>
            public bool TryGetCellDataFromChunkName(string chunkName, out int row, out int column, out int layer, out int chunkIndex)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.IExecutionController">
            <summary>
            Represents an Execution Controller, which is resposible for controlling the execution of SAM related code.
            </summary>
            <title>IExecutionController Interface</title>
            <category>Interfaces</category>
            <navigationName>IExecutionController</navigationName>
            <fileName>IExecutionController.html</fileName>
            <syntax>public interface IExecutionController</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IExecutionController.ShouldStartExecuting">
            <summary>
            For every frame that the component which uses this execution controller is set to execute, this method will 
            be queried to determine whether the component should execute.
            <para>
            A typical use case would be not letting the component execute if x seconds have already transpired during the frame.
            </para>
            </summary>
            <displayName id = "ShouldStartExecuting">
            ShouldStartExecuting()
            </displayName>
            <syntax>
            bool ShouldStartExecuting()
            </syntax>
            <returns type="bool">
            Return true if the component should start executing its logic in the Current frame, or false if it should not (the 
            next frame this method will be queried again).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IExecutionController.ShouldContinueExecuting">
            <summary>
            When the component which uses the IExecutionController wants to know whether it should yield for a frame or 
            continue executing, this method is queried.
            <para>
            Note there are a lot of methods that don't use this strategy, but instead need to always yield for a frame 
            or on some other property (WaitForSeconds for example)
            </para>
            </summary>
            <displayName id = "ShouldContinueExecuting">
            ShouldContinueExecuting()
            </displayName>
            <syntax>
            bool ShouldContinueExecuting()
            </syntax>
            <returns type="bool">
            Return true if the component should continue executing, false if it should yield for a frame.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.IIdentifiable">
            <summary>
            Represents an object which can be Identified via an ID.
            </summary>
            <title>IIdentifiable Interface</title>
            <category>Interfaces</category>
            <navigationName>IIdentifiable</navigationName>
            <fileName>IIdentifiable.html</fileName>
            <syntax>public interface IIdentifiable</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IIdentifiable.ID">
            <summary>
            Gets the identification number of the IIdentifiable object.
            </summary>
            <type>int</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.IZoneLODGroup">
            <summary>
            Represents a LOD Group belonging to a particular Zone on a World. This is similar to the LOD Group found on Streamable Grids, 
            except the IZoneLODGroup is tied to a specific Zone/World 
            Grouping and contains runtime data not found on the LOD Group.
            </summary>
            <title>IZoneLODGroup Interface</title>
            <category>Interfaces</category>
            <navigationName>IZoneLODGroup</navigationName>
            <fileName>IZoneLODGroup.html</fileName>
            <syntax>public interface IZoneLODGroup</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.ChunkStreamer">
            <summary>
            Gets the Chunk Streamer that the Zone LOD Group uses.
            </summary>
            <type link="ChunkStreamer.html">ChunkStreamer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.ChunkReuseLogic">
            <summary>
            Gets the Logic used to determine if the chunks from one World Cell can be reused on a different World Cell for this 
            Zone LOD Group. The logic takes in the Streamable Grid Cell indexes of both World Cell's. This is useful in custom Chunk Managers 
            if you want to implment pooling logic that takes into account reuse logic. Note that this will return null if the 
            Chunk Manager the Zone LOD Group is being used with has cell reuse disabled.
            </summary>
            <type>ChunkReuseJudge.JudgementDelegate</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.ZoneIndex">
            <summary>
            Gets the index of the Zone the Zone LOD Group belongs to.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.WorldGroupingIndex">
            <summary>
            Gets the index of the World Grouping the Zone LOD Group belongs to.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.GridLODDetails">
            <summary>
            Gets an object containing details about this Zone Grouping. These included LOD Group specific settings found on the Streamable Grid.
            </summary>
            <type link="GridLODDetails.html">GridLODDetails</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.GroupName">
            <summary>
            Gets the Group Name associated with the Zone LOD Group.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.InitialOriginCell">
            <summary>
            The initial Origin Cell of the Zone Grouping this Zone LOD Group belongs to, calculated from the Origin Cell set in the inspector of your 
            World. Note, however, that this is different than that Origin Cell, since this is the Origin Cell of the 
            Zone Grouping, while the one in the inspector is the Origin Cell of World as a whole, using its imaginary World Grid.
            <para>
            If you want the current origin cell of the Zone, use 
            <see cref="P:DeepSpaceLabs.SAM.IZoneLODGroup.OriginCell" href="#OriginCell">OriginCell</see> instead.
            </para>
            <para>
            The Zone Grouping Origin Cell is the Cell in the Zone Grouping whose position is closest to the current Origin Position, 
            which changes depending on the World's Origin Cell. If multiple Cells' positions are equadistant from the Origin Position, the 
            Cell closest to 0,0,0 is used. If that does not break the "tie", the Cell with smallest position value will be used.
            </para>
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.OriginCell">
            <summary>
            Gets the current Origin Cell of the Zone Grouping this Zone LOD Group belongs to.
            <para>
            This is the same value returned by World.GetOriginCellOfZoneGrouping when ZoneIndex and 
            WorldGroupingIndex are passed in.
            </para>
            <para>
            The Zone Grouping Origin Cell is the Cell whose position is closest to the current Origin Position, 
            which changes depending on the World's Origin Cell. If multiple Cells' positions are equadistant from the Origin Position, the 
            Cell closest to 0,0,0 is used. If that does not break the "tie", the Cell with smallest position value will be used.
            </para>
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.OriginCellPosition">
            <summary>
            Gets the current position of the Origin Cell for the Zone Grouping this Zone LOD Group belongs to.
            <para>
            This is the same value returned by World.GetOriginCellPositionOfZoneGrouping when  
            ZoneIndex and WorldGroupingIndex are passed in.
            </para>
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.World">
            <summary>
            Gets the World associated with the Zone LOD Group.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IZoneLODGroup.UsedWithHierarchyOrganizer">
            <summary>
            Gets a value indicating whether the Zone LOD Group is being used with a Hierarchy Organizer. Returns false if the World has not been assigned a Hierarchy Organizer, if the Asset Chunks used by theZone LOD Group are not Game Objects, or 
            if the LOD Group associated with the Zone LOD Group (or the World Grouping it belongs to) has 'Use With Hierarcy Organizer' disabled.
            </summary>
            <type>bool</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.IPersistentStateManager">
            <summary>
            Represents a persistent state manager contract. You can create a class that implements this to control how 
            data related to the Streamable Assets Manager is saved and loaded. This is used with the Component Manager's 
            <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Save(DeepSpaceLabs.SAM.IPersistentStateManager)" href="ComponentManager.html#Save">Save</see> and <see cref="M:DeepSpaceLabs.SAM.ComponentManager.Load(DeepSpaceLabs.SAM.IPersistentStateManager,System.Boolean)" href="ComponentManager.html#Load">Load</see> methods.
            </summary>
            <title>IPersistentStateManager Interface</title>
            <category>Interfaces</category>
            <navigationName>IPersistentStateManager</navigationName>
            <fileName>IPersistentStateManager.html</fileName>
            <syntax>public interface IPersistentStateManager</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IPersistentStateManager.DisableAutoInvocationOfBeforeAndAfterSaveMethods">
            <summary>
            By default, when the Component Manager's Save or ConvetOldData methods are called, those methods will 
            automatically call the OnBeforeDataSaved and OnAfterDataSaved methods before/after saving the data is saved. 
            In some instances, this may be undesirable, for instance if you want to 
            save non Streamable Assets Manager data before or after the Component Manager's Save method is called. 
            <para>
            In these instances, you can disable the auto calling of those two methods (by the Component Manager) 
            by returning true with this properties implementation, however note that you will need to call the 
            OnBeforeDataSaved and OnAfterDataSaved methods yourself, before and after beginning/completing the save operations.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IPersistentStateManager.DisableAutoInvocationOfBeforeAndAfterLoadMethods">
            <summary>
            By default, when the Component Manager's Load method is called, it will automatically call 
            OnBeforeDataLoaded before calling the Load... methods, and then it will automatically call OnAfterDataLoaded 
            after all data has been loaded. In some instances, this may be undesirable, for instance if you want to 
            load non Streamable Assets Manager data before or after the Component Manager's Load method is called. 
            <para>
            In these instances, you can disable the auto calling of those two methods (by the Component Manager) 
            by returning true with this properties implementation, however note that you will need to call the 
            OnBeforeDataLoaded and OnAfterDataLoaded methods manually, before and after beginning/completing the load operation.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.OnBeforeDataSaved">
            <summary>
            If DisableAutoInvocationOfBeforeAndAfterSaveMethods is implemented to return false, this method will be 
            called automatically by the Component Manager before it starts the saving process (when its Save or ConvertOldSaveData methods are called). 
            This can be used to setup anything needed 
            to actually perform the save operations, such as a file streams or binary writers.
            <para>
            If DisableAutoInvocationOfBeforeAndAfterSaveMethods is implemented to return true, you will need to manually call this method 
            before beginning the save operation. Usually, you would only do this if you have non Streamable Assets Manager data you wish to 
            save using the IPersistentStateManager.
            </para>
            </summary>
            <displayName id = "OnBeforeDataSaved">OnBeforeDataSaved()</displayName>
            <syntax>void OnBeforeDataSaved()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.SaveInt(System.Int32)">
            <summary>
            Saves an integer value.
            </summary>
            <param name="value" type="int">The integer to save.</param>
            <displayName id = "SaveInt">SaveInt(int)</displayName>
            <syntax>void SaveInt(int value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.SaveBool(System.Boolean)">
            <summary>
            Saves an boolean value.
            </summary>
            <param name="value" type="bool">The bool to save.</param>
            <displayName id = "SaveBool">SaveBool(bool)</displayName>
            <syntax>void SaveBool(bool value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.SaveFloat(System.Single)">
            <summary>
            Saves a float/single value.
            </summary>
            <param name="value" type="float">The float to save.</param>
            <displayName id = "SaveFloat">SaveFloat(float)</displayName>
            <syntax>void SaveFloat(float value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.SaveDouble(System.Double)">
            <summary>
            Saves a double value.
            </summary>
            <param name="value" type="double">The double to save.</param>
            <displayName id = "SaveDouble">SaveDouble(double)</displayName>
            <syntax>void SaveDouble(double value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.SaveString(System.String)">
            <summary>
            Saves an string value.
            </summary>
            <param name="value" type="string">The string to save.</param>
            <displayName id = "SaveString">SaveString(string)</displayName>
            <syntax>void SaveString(string value)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.OnAfterDataSaved">
            <summary>
            If DisableAutoInvocationOfBeforeAndAfterSaveMethods is implemented to return false, this method will be 
            called automatically by the Component Manager after it finishes the saving process (when its Save and ConvertOldSaveData methods are called). 
            This can be used to cleanup/finalize/close streams and other data, such as a file sream or binary writer.
            <para>
            If DisableAutoInvocationOfBeforeAndAfterSaveMethods is implemented to return true, you will need to manually call this method 
            after completing the save operation. Usually, you would only do this if you have non Streamable Assets Manager data you wish to 
            save using the IPersistentStateManager.
            </para>
            </summary>
            <displayName id = "OnAfterDataSaved">OnAfterDataSaved()</displayName>
            <syntax>void OnAfterDataSaved()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.OnBeforeDataLoaded">
            <summary>
            If DisableAutoInvocationOfBeforeAndAfterLoadMethods is implemented to return false, this method will be 
            called automatically by the Component Manager before it starts the loading process (when its Load method is called). 
            This can be used to setup anything needed 
            to actually perform the load operations, such as a file sream or binary writer.
            <para>
            If DisableAutoInvocationOfBeforeAndAfterLoadMethods is implemented to return true, you will need to manually call this method 
            before beginning the load operation. Usually, you would only do this if you have non Streamable Assets Manager data you wish to 
            load using the IPersistentStateManager.
            </para>
            </summary>
            <displayName id = "OnBeforeDataLoaded">OnBeforeDataLoaded()</displayName>
            <syntax>void OnBeforeDataLoaded()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.LoadInt">
            <summary>
            Loads an integer value.
            </summary>
            <displayName id = "LoadInt">LoadInt()</displayName>
            <syntax>int LoadInt()</syntax>
            <returns type = "int">The loaded integer.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.LoadBool">
            <summary>
            Loads a boolean value.
            </summary>
            <displayName id = "LoadBool">LoadBool()</displayName>
            <syntax>bool LoadBool()</syntax>
            <returns type = "bool">The loaded boolean.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.LoadFloat">
            <summary>
            Loads a float value.
            </summary>
            <displayName id = "LoadFloat">LoadFloat()</displayName>
            <syntax>float LoadFloat()</syntax>
            <returns type = "float">The loaded float.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.LoadDouble">
            <summary>
            Loads a double value.
            </summary>
            <displayName id = "LoadDouble">LoadDouble()</displayName>
            <syntax>double LoadDouble()</syntax>
            <returns type = "double">The loaded double.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.LoadString">
            <summary>
            Loads a string value.
            </summary>
            <displayName id = "LoadString">LoadString()</displayName>
            <syntax>string LoadString()</syntax>
            <returns type = "string">The loaded string.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IPersistentStateManager.OnAfterDataLoaded">
            <summary>
            If DisableAutoInvocationOfBeforeAndAfterLoadMethods is implemented to return false, this method will be 
            called automatically by the Component Manager after it completes the loading process (when its Load method is called). 
            This can be used to cleanup/finalize/close streams and other data, such as a file sream or binary writer.
            <para>
            If DisableAutoInvocationOfBeforeAndAfterLoadMethods is implemented to return true, you will need to manually call this method 
            after completing the load operation. Usually, you would only do this if you have non Streamable Assets Manager data you wish to 
            load using the IPersistentStateManager.
            </para>
            </summary>
            <displayName id = "OnAfterDataLoaded">OnAfterDataLoaded()</displayName>
            <syntax>void OnAfterDataLoaded()</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.IPlayer">
            <summary>
            Represents a Player
            </summary>
            <title>
            IName IPlayer
            </title>
            <category>Interfaces</category>
            <navigationName>IPlayer</navigationName>
            <fileName>IPlayer.html</fileName>
            <syntax>
            public interface IPlayer
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IPlayer.Position">
            <summary>
            Gets or Sets the player's position
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ISelfCreatingNewObjectHandler`1">
            <summary>
            Represents an interface for an object capable of handling the withdrawal and depositing of objects. This is usually 
            implemented by pools, however that is not a requirement. The handler should be capable of creating new objects 
            whenever WithdrawObject is called (an no pooled object exist), and properly handling objects that are no longer 
            needed when DepositObject is called.
            </summary>
            <title>ISelfCreatingNewObjectHandler&lt;T&gt; Interface</title>
            <category>Interfaces</category>
            <navigationName>ISelfCreatingNewObjectHandler</navigationName>
            <fileName>ISelfCreatingNewObjectHandler.html</fileName>
            <syntax>public interface ISelfCreatingNewObjectHandler&lt;T&gt;</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ISelfCreatingNewObjectHandler`1.WithdrawObject">
            <summary>
            Withdraws an object from the handler, either by creating it automatically or getting an existing one from the pool.
            </summary>
            <displayName id = "WithdrawObject">
            WithdrawObject()
            </displayName>
            <syntax>
            T WithdrawObject()
            </syntax>
            <returns type="T">
            An object from the handler.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ISelfCreatingNewObjectHandler`1.DepositObject(`0)">
            <summary>
            Deposits an object to the handler, which the handler will usually pool.
            </summary>
            <param name="obj" type="T">
            The object to give to the handler.
            </param>
            <displayName id = "DepositObject">
            DepositObject(T)
            </displayName>
            <syntax>
            void DepositObject(T obj)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.IWorldGroupingListener">
            <summary>
            Provides an interface implementation for 
            <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">World Grouping Listener</see> components and non component classes.
            <para>
            World Grouping Listeners can be assigned to a World Grouping in order to receive notification before or after the 
            World Grouping is updated, and also before/after World Cells on the World Grouping are 
            activated and/or deactivated. Previously, this behaviour 
            was achieved via Cell Actions attached to the individual chunks of a cell, however this system was cumbersome as 
            it required you to attach a component to each chunk game object.
            </para>
            <para>
            The new system utilizes one or more components at the World Grouping level to perform actions on a 
            collection of cells at a time. You can also utilize this system to keep 
            track of what cells are currently active, by adding the cells from one of the 'Activated' methods and removing them 
            from one of the 'Deactivated' methods to/from some internal collection.
            </para>
            <para>
            The most useful situation I can think of for doing this when trying to add integration for 3rd party assets.
            </para>
            <para>
            There are no cirucmstances I can think of where you would create a class that directly implements this interface. Normally, you will 
            want to derive from either the <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see> or 
            <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListenerNonComponent" href="WorldGroupingListenerNonComponent.html">WorldGroupingListenerNonComponent</see> class, as 
            these classes allow you to only override the listening methods (On...) that you need to, and the rest is taken care of (such as returning the 
            correct value from the 'CallOn...' properties.
            </para>
            <para>
            If for some reason you decide to implement this interface, you will need to provide an implementation 
            for all of the listener methods, however if you don't want to actually use one or more of the methods, you can simply return 
            the SimpleYieldBreakEquivalentEnumerator.Instance object in the implementation and then set the 'CallOn...' property for that method to 
            return false. For any methods that you want called, you must return true for the associated 'CallOn...' property.
            </para>
            <para>
            If a method you want to use does not need to utilize multiple frames, place the code you want executed as normal, then return 
            SimpleYieldBreakEquivalentEnumerator.Instance. This will ensure no garbage is generated when the method is called.
            </para>
            </summary>
            <title>
            IWorldGroupingListener Interface
            </title>
            <category>Interfaces</category>
            <navigationName>IWorldGroupingListener</navigationName>
            <fileName>IWorldGroupingListener.html</fileName>
            <syntax>
            public interface IWorldGroupingListener
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IsEnabled">
            <summary>
            Whether the listener is currently enabled. Its methods will only be called if it is enabled.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions">
            <summary>
            Gets a value indicating whether the listener's methods will be called during LOD transitions. When an LOD transition occurs, technically a World Cell is 
            deactivated (the old LOD) and a World Cell is activated (the new LOD), however generally it is better to think of these two World Cells as the same Cell 
            that is just changing its Asset Chunks out. With that said, a lot of logic may be directed at the World Cell's Asset Chunks, and if that is the case with 
            your WorldGroupingListener, you should set this property to return false, because the chunks will change during an LOD transition. The actuall WorldCell 
            object instance will also change, so if you're storing these WorldCell objects in some way, you will also need to set this to false so that you can remove 
            the old World Cells and add the new ones.\n\nIf, on the other hand, your WorldGroupingListeners only utilize data related to the World Cell's 
            (such as position, Streamable Grid Indexes, etc.), this data will not change during an LOD Transition, so you can ignore them.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.YieldBehaviorAfterMethodExecution">
            <summary>
            Gets a value that tells the World the Listener is being used with whether it should 
            yield control (to the Unity Engine and other components your game might have), after fully executing one of its methods. 
            <para>
            The options in the ListenerYieldBehaviour enumerator give you a great 
            deal of control.
            </para>
            <para>
            NeverYield can be chosen if you need to ensure that the next Listener to run runs immediately after this one finishes.
            </para>
            <para>
            AlwaysYield, on the other hand, can be used to force the World to yield for at least a frame, which might be necessary to 
            allow whatever code you've just run to "ferment".
            </para>
            <para>
            Finally, YieldOrContinue can be used if you don't really care one way or the other 
            whether the World yields control, as it will let the Execution Controller used by the World decide.
            </para>
            </summary>
            <type link="ListenerYieldBehaviour.html">ListenerYieldBehaviour</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnBeforeGroupingUpdated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnBeforeAnyCellUpdated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnBeforeAnyCellUpdated called.
            </para>
            <para>
            OnBeforeAnyCellUpdated is useful because it is called regardless of whether any cells will be activated or deactivated for the 
            given World Grouping. Therefore, you can use it to perform logic that is not dependent on cells being specifically activated or deactivated. 
            If your logic is dependent on activated or deactivated cells being present, use the OnBeforeAnyCellsActivated or 
            OnBeforeAnyCellsDeactivated methods instead, utilizing the batchNumber and totalBatchesToExpect to find the last call to the method 
            and performing the logic their, so it is only performed once.
            </para>
            <para>
            Note the method is called regardless of the IgnoreLODTransitions properties value, so long as it is overriden.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnBeforeAnyCellsDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnBeforeAnyCellsDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnBeforeAnyCellsDeactivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnBeforeCellsInBatchDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnBeforeCellsInBatchDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnBeforeCellsInBatchDeactivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnAfterCellsInBatchDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnAfterCellsInBatchDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnAfterCellsInBatchDeactivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnAfterAllCellsDeactivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnAfterAllCellsDeactivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnAfterAllCellsDeactivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnBeforeAnyCellsActivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnBeforeAnyCellsActivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnBeforeAnyCellsActivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnBeforeCellsInBatchActivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnBeforeCellsInBatchActivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnBeforeCellsInBatchActivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnAfterCellsInBatchActivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnAfterCellsInBatchActivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnAfterCellsInBatchActivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnAfterAllCellsActivated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnAfterAllCellsActivated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnAfterAllCellsActivated called.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldGroupingListener.CallOnAfterGroupingUpdated">
            <summary>
            Returns a value indicating whether the World Grouping this IWorldGroupingListener is linked to should call the 
            OnAfterGroupingUpdated method. Please note, when deriving from WorldGroupingListenerNonComponent or WorldGroupingListener, it is not necessary to 
            worry about this property. All you need to do is override the method if you want it to be called. Reflection 
            is used to set this property automatically to true when you override the method, or false if you don't override it.
            <para>
            However, if implementing this interface and not deriving from one of those classes, you will need to ensure this property 
            returns the correct value depending on whether you want OnAfterGroupingUpdated called.
            </para>
            <para>
            OnAfterGroupingUpdated is useful because it is called regardless of whether any cells have been activated or deactivated for the 
            given World Grouping. Therefore, you can use it to perform logic that is not dependent on cells being specifically activated or deactivated. 
            If your logic is dependent on activated or deactivated cells being present, use the OnAfterAllCellsActivated or 
            OnAfterAllCellsDeactivated methods instead, utilizing the batchNumber and totalBatchesToExpect to find the last call to the method 
            and performing the logic their, so it is only performed once.
            </para>
            <para>
            Note the method is called regardless of the IgnoreLODTransitions properties value, so long as it is overriden.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.DetermineMethodCalls">
            <summary>
            This is called once automatically by each World Grouping using the Listener 
            and can be used to calculate the values of the Call... properties 
            (CallOnBeforeGroupingUpdated, CallOnBeforeAnyCellsDeactivated, etc.).
            <para>
            If your Listener does not precompute these values, you can implement this method to do nothing.
            </para>
            <para>
            If you derive from WorldGroupingListener or WorldGroupingListenerNonComponent, this method is already 
            implemented, so you do not need to worry about it.
            </para>
            <para>
            If you do not derive from one of those two classes and need to precompute the values using this methods, 
            keep in mind that if the Listener is being used with multiple World Groupings, this method will be 
            called multiple times. You should have a system in place to ensure your precomputation logic only runs once.
            </para>
            <para>
            Note that this method is called once by each World Grouping using the Listener, so it may be called multiple times 
            in some cases. Usually, you should have some sort of safeguard in place to ensure the method determination logic 
            only runs once.
            </para>
            </summary>
            <displayName id="DetermineMethodCalls">
            DetermineMethodCalls()
            </displayName>
            <syntax>
            void DetermineMethodCalls()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.PrecomputeUseWithLODValues">
            <summary>
            Precomputes data used by the 
            <see cref="M:DeepSpaceLabs.SAM.IWorldGroupingListener.UseWithLOD(System.Int32)" href="#UseWithLOD">UseWithLOD</see> method.
            <para>
            If you derive from 
            <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see>, 
            this method will already have been implemented. To calculate additional 
            data (for if you override UseWithLOD), use the 
            <see cref="M:DeepSpaceLabs.SAM.WorldGroupingListener.PrecomputeUseWithLODValues_Extended" href="WorldGroupingListener.html#PrecomputeUseWithLODValues_Extended">PrecomputeUseWithLODValues_Extended</see> method.
            </para>
            <para>
            Note that this method is called once by each World Grouping using the Listener, so it may be called multiple times 
            in some cases. Usually, you should have some sort of safeguard in place to ensure the precomputation logic 
            only runs once.
            </para>
            </summary>
            <displayName id="PrecomputeUseWithLODValues">
            PrecomputeUseWithLODValues()
            </displayName>
            <syntax>
            void PrecomputeUseWithLODValues()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.UseWithLOD(System.Int32)">
            <summary>
            This method is queried before any of the methods that use cells are called, to determine if that method should be 
            invoked for the current group of cells, given the active LOD of those cells (remember, all cells in a batch 
            are always gauranteed to have the same active LOD).
            <para>
            When deriving from <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">WorldGroupingListener</see> 
            this method is virtually implemented to return a value based on the LOD Filter configured in the Listener's 
            inspector. You can override it to ignore the LOD Filter in favor of a custom system for determining per LOD use.
            </para>
            <para>
            The value returned by this method is not cached. Each time one of the methods would be called, the method is called.
            </para>
            <para>
            This gives you a great deal of freedom, as you can adjust which LODs the Listener is being used with on the fly at runtime.
            </para>
            <para>
            However, if you know that the LODs that the Listener is being used will not change at runtime, and the computation 
            used to determine if an LOD should be used by the Listener is expensive, you should cache the computed value for each 
            LOD and use that when the method is called. Typically, should do this in Awake or AwakeExtended, so that the cached values can be used 
            as early as Start.
            </para>
            <para>
            The value is applied universally across all method calls that use cells (OnBeforeAnyCellsDeactivated, OnBeforeCellsInBatchDeactivated, 
            etc.). If you use more than 1 of these methods and need to use different criteria for determining LOD use for each one, 
            you should return true when UseWithLOD is called and instead filter each LOD within the actual methods that process the cells.
            </para>
            </summary>
            <param name="LOD" type="int">
            The active LOD of the World Cells that one of the methods (OnBeforeAnyCellsDeactivated, 
            OnBeforeCellsInBatchDeactivated, etc.) is about to be invoked for.
            <para>
            This value is 1 based, such that the first (highest quality) LOD is 1.
            </para>
            </param>
            <returns type="type">
            Return true if you want the method (OnBeforeAnyCellsDeactivated, OnBeforeCellsInBatchDeactivated, 
            etc.) to be called for the World Cells of the LOD, or false otherwise.
            </returns>
            <displayName id="UseWithLOD">
            UseWithLOD(int)
            </displayName>
            <syntax>
            bool UseWithLOD(int LOD)
            </syntax>
            <exception name="ExceptionName">
            Description
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnGroupingLinkEstablished(DeepSpaceLabs.SAM.World,System.Int32,System.Int32)">
            <summary>
            Called by the World when a Zone Grouping is linked to a World Grouping Listener.
            <para>
            This can be used to verify configuration settings or perform one time setup for the World and 
            Grouping (rather than placing this setup code in the other On... methods which is less efficient).
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The World the Grouping belongs to.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the Zone Groupings whose link was added.
            </param>
             <param name="groupingIndex" type="int">
            The index of the grouping associated with the Zone Grouping whose link was added.
            </param>
            <displayName id="OnGroupingLinkEstablished">
            OnGroupingLinkEstablished(World, int, int)
            </displayName>
            <syntax>
            void OnGroupingLinkEstablished(World world, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnGroupingLinkRemoved(DeepSpaceLabs.SAM.World,System.Int32,System.Int32)">
            <summary>
            Called by the World when a Zone Grouping link to a World Grouping Listener is removed. This occurs when the World Grouping Listener 
            is removed using the World's RemoveWorldGroupingListener method or if the World is destroyed.
            <para>
            This can be used to cleanup data that was created in the OnGroupingLinkEstablished method.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The World the Grouping belongs to.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the Zone Groupings whose link was removed.
            </param>
             <param name="groupingIndex" type="int">
            The index of the grouping associated with the Zone Grouping whose link was removed.
            </param>
            <displayName id="OnGroupingLinkRemoved">
            OnGroupingLinkRemoved(World, int, int)
            </displayName>
            <syntax>
            void OnGroupingLinkRemoved(World world, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnBeforeAnyCellsDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called before any cells have been added/removed or activated/deactivated during the current World Update, 
            for all cells that the World determines need to be removed completely, and also for cells which are being 
            removed as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that. This method is also called before duplicating a world, before the duplication process begins, with the 
            input cells being the old cells which are about to be duplicated.
            <para>
            Each of the OnCells...Deactivated methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own chunks (game objects) present, and those chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors, and the neighbors chunks will be in an ACTIVATED state.
            </para>
            <para>
            This method is ideal for situations where you need to perform neigbor related cell specific actions that are not time sensitive, since the 
            actual deactivation of the cells will take place some frames after this method is called.
            </para>
            <para>
            In addition, you SHOULD USE this method for adding World Cells or World Cell related data from an internal collection 
            such as a Dictionary.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch cells which will be deactivated in a short amount of time.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeAnyCellsDeactivated">
            OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnBeforeAnyCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnBeforeCellsInBatchDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called right before a batch of cells is set to be deactivated during the current World Update (deactivation 
            involves transitioning the cells to a non visible state, removing them from any HierarchyOrganizers, and removing them 
            from the internal collection of World Cells so that they are no longer "part" of the Streamable World Grouping they were a part of), 
            for all cells that the World determines need to be removed completely, and also for cells which are being 
            removed as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Removed methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own chunks (game objects) present, and those chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors, however the state of the neighbors cannot be predicted, since this 
            method may be called before or after other cells that are to be removed have been deactivated. For example, one of its neighbors 
            may be a cell that will be LOD transitioned, so while currently its neighbor is a cell with LOD 1, once all LOD transitions are 
            processed, its new neighbor might be the same cell but of LOD 2. Or in another example, a neighbor may be not present currently, 
            but after adding new cells, may become present. As such, it is not recommended to carry out any neighbor based logic here. Use the 
            OnBeforeAnyCellsDeactivated method instead!
            </para>
            <para>
            This method is well suited for situations where you need to perform non neighbor related cell specific actions right before a cell is 
            deactivated. However, do note that there is a small delay between this method being called and the deactivation of a cell, 
            since all cells in the batch are deactivated together. If you need more precise timing, you should set the World Grouping or 
            LOD to not be deactivated automatically, and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            and perform that logic there, just before you deactivate each cell.
            </para>
            <para>
            In addition, you should not use this method for removing World Cells or World Cell related data from an internal collection 
            such as a Dictionary, but instead use the OnBeforeAnyCellsDeactivated for this purpose.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch cells which are just about to be deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeCellsInBatchDeactivated">
            OnBeforeCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnBeforeCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnAfterCellsInBatchDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called right after a batch of cells has been deactivated during the current World Update (deactivation 
            involves transitioning the cells to a non visible state, removing them from any HierarchyOrganizers, and removing them 
            from the internal collection of World Cells so that they are no longer "part" of the Streamable World Grouping they were a part of), 
            for all cells that the World determined need to be removed completely, and also for cells which are being 
            removed as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Removed methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own chunks (game objects) present, and those chunks will be in an DEACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors, however the state of the neighbors cannot be predicted, since this 
            method may be called before or after other cells that are to be removed have been deactivated. For example, one of its neighbors 
            may be a cell that will be LOD transitioned, so while currently its neighbor is a cell with LOD 1, once all LOD transitions are 
            processed, its new neighbor might be the same cell but of LOD 2. Or in another example, a neighbor may be not present currently, 
            but after adding new cells, may become present. As such, it is not recommended to carry out any neighbor based logic here. Use the 
            OnBeforeAnyCellsDeactivated method instead!
            </para>
            <para>
            This method is well suited for situations where you need to perform non neigbor related cell specific actions right after a cell is 
            deactivated. However, do note that there is a small delay between the deactivation of a cell and 
            this method being called, since all cells in the batch are deactivated together before this method is called for them. 
            If you need more precise timing, you should set the World Grouping or 
            LOD to not be deactivated automatically, and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            and perform that logic there, just after you deactivate each cell.
            </para>
            <para>
            In addition, you should not use this method for removing World Cells or World Cell related data from an internal collection 
            such as a Dictionary, but instead use the OnBeforeAnyCellsDeactivated for this purpose.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have just been deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterCellsInBatchDeactivated">
            OnAfterCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnAfterCellsInBatchDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnAfterAllCellsDeactivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called after every cell on a Zone Grouping that the World has determined needs to be deactivated, has been deactivated for 
            a given World Update (deactivation involves transitioning the cells to a non visible state, removing them from any 
            HierarchyOrganizers, and removing them from the internal collection of World Cells so that they are no longer "part" of 
            the Streamable World Grouping they were a part of), for all cells that the World determined needed to be removed completely, 
            and also for cells which were removed as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Deactivated methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL NOT have its own chunks (game objects) present.
            3) Each World Cell in the batch WILL NOT have cell neighbors.
            </para>
            <para>
            Based on the gaurantees listed, hopefully you can see that this method is the most limited of the OnCells...Deactivated methods. No 
            chunks or neighbors are present, so this method is only suitable if you need to perform non chunk related operations after all 
            cells that are going to be deactivated have been deactivated in the current World Update.
            </para>
            <para>
            In addition, you should not use this method for removing World Cells or World Cell related data from an internal collection 
            such as a Dictionary, but instead use the OnBeforeAnyCellsDeactivated for this purpose.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been deactivated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being deactivated as part of an LOD transition.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsDeactivated">
            OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsDeactivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnBeforeAnyCellsActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called before any cells have been added/removed or activated/deactivated during the current World Update, 
            for all cells that the World determines need to be newly added, and also for cells which are being 
            added as part of an LOD Transition, so long as IgnoreLODTransitions returns false. See the 
            <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> property for 
            more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL NOT have its own chunks (game objects) present.
            3) Each World Cell in the batch WILL NOT have cell neighbors.
            </para>
            <para>
            This method is ideal for situations where you need to perform non chunk, neigbor related, cell specific 
            actions that are not time sensitive, since the 
            actual activation of the cells will take place some frames after this method is called.
            </para>
            <para>
            In addition, you should not use this method for adding World Cells or World Cell related data from an internal collection 
            such as a Dictionary, but instead use the OnAfterAllCellsActivated for this purpose.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch cells which will be activated in a short time.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeAnyCellsActivated">
            OnBeforeAnyCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnBeforeAnyCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnBeforeCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called just before a batch of cells will be activated (activation involves transitioning 
            the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determines need to be newly added, 
            and also for cells which are added as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own chunks (game objects) present, and those chunks will be in an DEACTIVATED state.
            3) Each World Cell in the batch WILL NOT have cell neighbors set.
            </para>
            <para>
            This method is well suited for non neighbor cell specific logic that you want to perform just prior to the activation of a cell, 
            however do note that there is a small delay between this method being called and the activation of a cell, since all cells in a 
            batch are activated together. If you need more precise timing, you should set the World Grouping or 
            LOD to not be activated automatically, and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            and perform that logic there, just before activating each cell.
            </para>
            <para>
            In addition, you should not use this method for adding World Cells or World Cell related data from an internal collection 
            such as a Dictionary, but instead use the OnAfterAllCellsActivated for this purpose.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which are just about to be activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeCellsInBatchActivated">
            OnBeforeCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnBeforeCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnAfterCellsInBatchActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called just after a batch of cells have been activated (activation involves transitioning 
            the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determined needed to be newly added, 
            and also for cells which were added as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own chunks (game objects) present, and those chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors set, and any non LOD related data of the neighbors can be considered 
            accurate. However the state of the neighbor chunks is not predictable, and the neighbor may be replaced by different cells if 
            the neighbor is undergoing an LOD transition (though do note, the neighbor is gauranteed to not be null in the future of the current 
            World Update, since the deactivation of cells which need to be completely removed is performed prior to this method being called 
            for the first time.
            </para>
            <para>
            This method is well suited for non neighbor cell specific logic that you want to perform just after the activation of a cell, 
            however do note 
            that there is a small delay between the activation of a cell and this method being called, since all cells in a batch are activated 
            together before this method is called for that batch. If you need more precise timing, you should set the World Grouping or 
            LOD to not be activated automatically, and create a custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controller</see> 
            and perform that logic there, just after activating each cell.
            </para>
            <para>
            In addition, you should not use this method for adding World Cells or World Cell related data from an internal collection 
            such as a Dictionary, but instead use the OnAfterAllCellsActivated for this purpose.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have just been activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterCellsInBatchActivated">
            OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnAfterCellsInBatchActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnAfterAllCellsActivated(DeepSpaceLabs.Core.ReadOnlyList{DeepSpaceLabs.SAM.WorldCell},System.Int32,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            This method is called after every cell on a Zone Grouping that the World has determined needs to be activated, have been activated for 
            a given World Update (activation involves transitioning the cells to a visible state, adding them to any 
            HierarchyOrganizers, and adding them to the internal collection of World Cells so that they become "part" of 
            the Streamable World Grouping they were loaded for), for all cells that the World determined needed to be newly added, 
            and also for cells which were added as part of an LOD Transition, so long as IgnoreLODTransitions 
            returns false. See the <see cref="P:DeepSpaceLabs.SAM.IWorldGroupingListener.IgnoreLODTransitions" href="WorldGroupingListener.html#IgnoreLODTransitions">IgnoreLODTransitions</see> 
            property for more details on that.
            <para>
            Each of the OnCells...Activated methods offers different guarantees in regards to the chunks, cell neighbors, and cell 
            neigihbor chunks. You can pick and choose which of these methods you want to utilize based on what you need to do, and what 
            gaurantees your logic depends on. This method offers the following gaurantees.
            </para>
            <para>
            1) World Cell data is configured correctly.
            2) Each World Cell in the batch WILL have its own chunks (game objects) present, and those chunks will be in an ACTIVATED state.
            3) Each World Cell in the batch WILL have cell neighbors set, and the chunks of the cell neighbors will be in an ACTIVATED state. Please 
            note, there is no gaurantee that a cell will have a neighbor, as if its on the edge of the world or next to an empty Streamable Grid Cell, 
            there may be no World Cell to serve as its neighbor.
            </para>
            <para>
            This method is well suited for neighbor related logic where you want a gaurantee that the cell neighbors will be present (if they exist) 
            and accurate (all neighbors will be true neighbors, and not possibly LOD cells that are in the process of transitioning, or cells which 
            will be deactivated; i.e., neighbors which will be nulled out or replaced in the future of this World Update). 
            However, while it is called shortly after cells are activated, the timing is not as precise as OnAfterCellsInBatchActivated, since it 
            is only called after all cells have been activated. Therefore, you should not place code that needs to be timed wiht the 
            activation of a cell here.
            </para>
            <para>
            In addition, you SHOULD USE this method for adding World Cells or World Cell related data from an internal collection 
            such as a Dictionary.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="cells" type="ReadOnlyList&lt;WorldCell&gt;" link="WorldCell.html">
            The batch of cells which have been activated.
            </param>
            <param name="batchNumber" type="int">
            The batch number. Will be between 1 and totalBatchesToExpect. You can use the batch number to determine if the batch of cells 
            is the first or last, and perform specific logic based on that. For instance, you may want to perform a method call that should 
            only be performed after all cells have been processed by your World Grouping Listener.
            </param>
            <param name="totalBatchesToExpect" type="int">
            The total batches to expect. Once the batchNumber is equal to this value, you know that you are on the final batch of cells. This 
            method will not be called again after that, except for a new World Update.
            </param>
            <param name="cellsArePartOfLODTransition" type="bool">
            Whether the current batch of cells are part being activated as part of an LOD transition.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize in the Awake method of some script. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterAllCellsActivated">
            OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt;, int, int, bool, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnAfterAllCellsActivated(ReadOnlyList&lt;WorldCell&gt; cells, int batchNumber, int totalBatchesToExpect, bool cellsArePartOfLODTransition, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnBeforeGroupingUpdated(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called before a Zone Grouping is updated, regardless of whether cells will actually 
            be changed on the Grouping (because remember, all Groupings are updated during a Word update, regardless of 
            whether there are changes on that grouping!).
            <para>
            Because this method is not dependent on activated or deactivated cells 
            being present, it does not have any input WorldCell's, unlike 
            the other methods. This also means that the method is only called once per World Grouping Listener per World Grouping update.
            </para>
            <para>
            The method is also called when the Component Manager is initialized with two frame 
            initialization (for example, if it's Initialize On Awake option is enabled) 
            before the initial starting cell users are added/activated on a World Grouping. Again, this occurs regardless 
            of whether that World Grouping actually has starting cells. In these instances, immediate mode will be true.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world whose World Grouping is about to be updated.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the cells which have been update. This is useful if using multiple Zones.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping associated with the cells which have been updated. This is useful if using the listener with 
            multiple World Groupings.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnBeforeGroupingUpdated">
            OnBeforeGroupingUpdated(World, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnBeforeGroupingUpdated(World world, int zoneIndex, int groupingIndex, bool immediateMode)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldGroupingListener.OnAfterGroupingUpdated(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,System.Boolean)">
            <summary>
            This method is called after a Zone Grouping has been updated, regardless of whether cells have actually 
            been changed on the Grouping (because remember, all Groupings are updated during a Word update, regardless of 
            whether there are changes on that grouping!).
            <para>
            Because this method is not dependent on activated or deactivated cells 
            being present, it does not have any input WorldCell's, unlike 
            the other methods. This also means that the method is only called once per World Grouping Listener per World Grouping update.
            </para>
            <para>
            The method is also called when the Component Manager is initialized with two frame 
            initialization (for example, if it's Initialize On Awake option is enabled) 
            after the initial starting cell users are added/activated on a World Grouping. Again, this occurs regardless 
            of whether that World Grouping actually has starting cells. In these instances, immediate mode will be true.
            </para>
            <para>
            In order for this method to be called by the World, you only need to override the method in your custom 
            WorldGroupingListener class.
            </para>
            </summary>
            <param name="world" type="World" link="World.html">
            The world whose World Grouping has just been updated.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone associated with the cells which have been update. This is useful if using multiple Zones.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping associated with the cells which have been updated. This is useful if using the listener with 
            multiple World Groupings.
            </param>
            <param name="immediateMode" type="bool">
            Whether the method is being called in immediate mode. Immediate mode simply means that the method is not being 
            used as a coroutine. All yield statements are ignored in this mode and the entire code block will execute in a single 
            frame. This mode is used only when the Component Manager in the scene has been Initialized in a non gradual manner, either 
            via its "Initialize on Awake" method being enabled, or you (the user) calling Initialize. In 
            these instances, the World and its World Groupings are initialized and loaded within two frames (Awake and Start) so that 
            the World Chunks appear before the first Update is called.
            <para>
            Typically you will not need to do any special code changes for immediate mode, 
            however in case you do need to, you can query this 
            value to determine if immediate mode is being used.
            </para>
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="OnAfterGroupingUpdated">
            OnAfterGroupingUpdated(World, int, int, bool)
            </displayName>
            <syntax>
            IEnumerator&lt;YieldInstruction&gt; OnAfterGroupingUpdated(World world, int zoneIndex, int groupingIndex, bool immediateMode)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.IWorldUser">
            <summary>
            Represents a user that wishes to be notified when certain events occur on a World. You can register this user 
            via <see cref="M:DeepSpaceLabs.SAM.World.Register(DeepSpaceLabs.SAM.IWorldUser,System.Int32@)" href="World.html#Register">World.Register</see>
            </summary>
            <title>IWorldUser Interface</title>
            <category>Interfaces</category>
            <navigationName>IWorldUser</navigationName>
            <fileName>IWorldUser.html</fileName>
            <syntax>public interface IWorldUser</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldUser.UserID">
            <summary>
            The ID assigned to the user at time of registration with the World.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.IWorldUser.UseFastOnOriginCellChangedMethod">
            <summary>
            Gets a value indicating whether this users OnOriginCellChanged_Fast method should be called rather 
            than its OnOriginCellChanged_Slow method. If you need to perform some work over multiple frames 
            after the world has its Origin Cell changed, you should implement this property to return false, otherwise 
            have it return true so OnOriginCellChanged_Fast is called.
            <para>
            Note, if you are using a World Shifter component with Perform Shift In Single Frame enabled, 
            OnOriginCellChanged_Slow will be executed in a single frame, therefore this property should be 
            set to return true to avoid calling an unecessary enumerator method.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldUser.TryDesyncFromWorld(System.Boolean)">
            <summary>
            Called when the World the user is registered to is about to be destroyed. There are two scenarios where this can occur:
            <para>
            1) The World is being destroyed via the Component Manager. In this case {BoldTagOpen}failureWillDelayDestruction{BoldTagClose} will be true and 
            the destruction of the World can be delayed by the World User, by returning false in the method body.
            </para>
            <para>
            This can be used if an operation is being performed that would fail if the World were destroyed, or result in cascading errors. 
            Each user has the method queried and if one of them returns false for this method, a frame is yielded and the users are queried again afterwards. 
            The cycle repeats until all users desync correctly. Please note, however, that once a user desyncs (and returns true), they will not be queried 
            again (this differs from the way 
            <see cref="M:DeepSpaceLabs.SAM.IWorldUser.IsReadyForOriginCellChange" href="IWorldUser.html#IsReadyForOriginCellChange">IsReadyForOriginCellChange</see> works). Only users that fail to desync are queried again.
            </para>
            <para>
            2) The World is being destroyed via a Destroy method call or the application quitting (which could be exiting play mode if in the editor). 
            In this scenario the destruction cannot be delayed, so failureWillDelayDestruction will be false. Your users must perform as much cleanup as 
            they can and should generally return true. If they return false, an error message is printed giving you details about the user that failed to desync and the World that was destroyed.
            </para>
            </summary>
            <param name="failureWillDelayDestruction" type="bool">
            For option 1 above, failureWillDelayDestruction will be true to indicate that a failed desync will cause a delay, and that the TryDesyncFromWorld 
            will be re-queried again in the future if you return false. For option 2, failureWillDelayDestruction will be false to indicate that the user cannot delay the destruction and 
            this will be there one and only chance to desync (the method will not be called again).
            </param>
            <displayName id="TryDesyncFromWorld">TryDesyncFromWorld(bool)</displayName>
            <syntax> bool TryDesyncFromWorld(bool failureWillDelayDestruction)</syntax>
            <returns type = "bool">
            True if the user was able to sucessfully desync from the world, false otherwise. It's recommended to always return true when failureWillDelayDestruction is false, as returning false 
            will only cause an error to print (but will accomplish nothing else). 
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldUser.IsReadyForOriginCellChange">
            <summary>
            Called when the World the user is registered to is about to perform an Origin Cell Change. The World will 
            query all users using this method to make sure they are ready. You can return false to tell the World your user is 
            not ready. The world will exit the Current frame if at least one user is not ready, and then query 
            all users again in a subsequent frame. Once all users are ready, the world will call 
            <see cref="M:DeepSpaceLabs.SAM.IWorldUser.OnOriginCellChanging" href="IWorldUser.html#OnOriginCellChanging">OnOriginCellChanging</see> before starting the Origin Cell change.
            <para>
            If you need to block execution of certain operations while the Origin Cell Change is running, or run certain code to prepare your user for the change, 
            you should place such code within <see cref="M:DeepSpaceLabs.SAM.IWorldUser.OnOriginCellChanging" href="IWorldUser.html#OnOriginCellChanging">OnOriginCellChanging</see> rather than IsReadyForOriginCellChange.
            </para>
            <para>
            This is because some other World User may return false for IsReadyForOriginCellChange, in which case there is no 
            reason for you to initiate the blocking code or run the preparation code yet. OnOriginCellChanging, on ther other hand, is only called after all users are ready, 
            right before the Origin Cell Change begins, which is where you will need to initiate the blocking code and prepare for the Origin Cell change.
            </para>
            <para>
            An Origin Cell change can be initiated in four ways. Via the Active Grid when the player crosses a World Reset boundary, via the Active 
            Grid when its TryChangeOriginCellOfWorld is called, via the World when its ChangeOriginCell is called, or via the World when its 
            LoadWorldRegion method is called with setOriginCellToWorldRegionOriginCell set to true. No matter how the Origin Cell update is initiated, 
            this method will be queried.
            </para>
            </summary>
            <displayName id="IsReadyForOriginCellChange">IsReadyForOriginCellChange()</displayName>
            <syntax>bool IsReadyForOriginCellChange()</syntax>
            <returns type = "bool">
            Return true if the user is ready for the Origin Cell Change, false otherwise. The Origin Cell change will not occur until all World users are 
            ready for it.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldUser.OnOriginCellChanging">
            <summary>
            Called before an Origin Cell Change has started, after all World Users have returned true for 
            <see cref="M:DeepSpaceLabs.SAM.IWorldUser.IsReadyForOriginCellChange" href="IWorldUser.html#IsReadyForOriginCellChange">IsReadyForOriginCellChange</see>.
            <para>
            You can place code that prepares for the update or blocks other code from executing (that would interfere or cause issues if it ran at the same time as the change) here. Such code should not 
            be placed inside of the <see cref="M:DeepSpaceLabs.SAM.IWorldUser.IsReadyForOriginCellChange" href="IWorldUser.html#IsReadyForOriginCellChange">IsReadyForOriginCellChange</see>, as even if one user returns true for this 
            method, one or more other users may return false, in which case the change will not proceed.
            </para>
            <para>
            An Origin Cell change can be initiated in four ways. Via the Active Grid when the player crosses a World Reset boundary, via the Active 
            Grid when its TryChangeOriginCellOfWorld is called, via the World when its ChangeOriginCell is called, or via the World when its 
            LoadWorldRegion method is called with setOriginCellToWorldRegionOriginCell set to true. No matter how the Origin Cell is initiated, 
            this method will be queried.
            </para>
            </summary>
            <displayName id="OnOriginCellChanging">
            OnOriginCellChanging()
            </displayName>
            <syntax>
            void OnOriginCellChanging()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldUser.OnOriginCellChanged_Fast(DeepSpaceLabs.SAM.OriginCellChangeInfo)">
            <summary>
            Called when the World the user is registered to has completed its Origin Cell change. There are two methods 
            similarly named, OnOriginCellChanged_Fast and OnOriginCellChangeCompletedSlow.
            <para>
            OnOriginCellChanged_Fast is executed in a single frame and will be called when 
            <see cref="P:DeepSpaceLabs.SAM.IWorldUser.UseFastOnOriginCellChangedMethod">UseFastOnOriginCellChangedMethod</see> is implemented to return true. 
            This is ideal when your code is lightweight and/or doesn't need to be run over multiple frames.
            </para>
            <para>
            OnOriginCellChanged_Slow is executed (usually) over multiple frames by introducing yield statements in 
            your method implementation, and is called when <see cref="P:DeepSpaceLabs.SAM.IWorldUser.UseFastOnOriginCellChangedMethod">UseFastOnOriginCellChangedMethod</see> 
            is implemented to return false.
            </para>
            <para>
            Also note that if you are using a World Shifter component with its Perform Shift In Single Frame option enabled, the 
            OnOriginCellChanged_Slow method will be run in a single frame, which is a waste. In this situation, it is better to set 
            your UseFastOnOriginCellChangedMethod to return true and put your code in OnOriginCellChanged_Fast.
            </para>
            <para>
            An Origin Cell change can be initiated in four ways. Via the Active Grid when the player crosses a World Reset boundary, via the Active 
            Grid when its TryChangeOriginCellOfWorld is called, via the World when its ChangeOriginCell is called, or via the World when its 
            LoadWorldRegion method is called with setOriginCellToWorldRegionOriginCell set to true. No matter how the Origin Cell is initiated, 
            this or OnOriginCellChangeCompletedSlow will be used.
            </para>
            </summary>
            <param name="originCellChangeInfo" type="OriginCellChangeInfo" link="OriginCellChangeInfo.html">
            Information pertaining to the Origin Cell Change. See the OriginCellChangeInfo page for more information.
            </param>
            <displayName id="OnOriginCellChanged_Fast">
            OnOriginCellChanged_Fast(OriginCellChangeInfo)
            </displayName>
            <syntax>void OnOriginCellChanged_Fast(OriginCellChangeInfo originCellChangeInfo)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldUser.OnOriginCellChanged_Slow(DeepSpaceLabs.SAM.OriginCellChangeInfo)">
            <summary>
            Called when the World the user is registered to has completed its Origin Cell change. There are two methods 
            similarly named, OnOriginCellChangeCompletedFast and OnOriginCellChanged_Slow.
            <para>
            OnOriginCellChanged_Fast is executed in a single frame and will be called when 
            <see cref="P:DeepSpaceLabs.SAM.IWorldUser.UseFastOnOriginCellChangedMethod">UseFastOnOriginCellChangedMethod</see> is implemented to return true. 
            This is ideal when your code is lightweight and/or doesn't need to be run over multiple frames.
            </para>
            <para>
            OnOriginCellChanged_Slow is executed (usually) over multiple frames by introducing yield statements in 
            your method implementation, and is called when <see cref="P:DeepSpaceLabs.SAM.IWorldUser.UseFastOnOriginCellChangedMethod">UseFastOnOriginCellChangedMethod</see> 
            is implemented to return false.
            </para>
            <para>
            Also note that if you are using a World Shift component with its Perform Shift In Single Frame option enabled, the 
            OnOriginCellChanged_Slow method will be run in a single frame, which is a waste. In this situation, it is better to set 
            your UseFastOnOriginCellChangedMethod to return true and put your code in OnOriginCellChanged_Fast.
            </para>
            <para>
            An Origin Cell change can be initiated in four ways. Via the Active Grid when the player crosses a World Reset boundary, via the Active 
            Grid when its TryChangeOriginCellOfWorld is called, via the World when its ChangeOriginCell is called, or via the World when its 
            LoadWorldRegion method is called with setOriginCellToWorldRegionOriginCell set to true. No matter how the Origin Cell is initiated, 
            this or OnOriginCellChangeCompletedFast will be used.
            </para>
            </summary>
            <param name="originCellChangeInfo" type="OriginCellChangeInfo" link="OriginCellChangeInfo.html">
            Information pertaining to the Origin Cell Change. See the OriginCellChangeInfo page for more information.
            </param>
            <displayName id="OnOriginCellChanged_Slow">
            OnOriginCellChanged_Slow(OriginCellChangeInfo)
            </displayName>
            <syntax>IEnumerator&lt;YieldInstruction&gt; OnOriginCellChanged_Slow(OriginCellChangeInfo originCellChangeInfo)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.IWorldUser.OnOriginCellsClamped(DeepSpaceLabs.SAM.ClampingOperationInfo)">
            <summary>
            Called when a World's Origin Cell and its Zone Groupings' Origin Cells are clamped. See the 
            <see cref="M:DeepSpaceLabs.SAM.World.ClampOriginCells(System.Boolean,System.Boolean,System.Action{DeepSpaceLabs.SAM.World})" href="World.html#ClampOriginCells">ClampOriginCell</see> method for more information.
            </summary>
            <param name="operationInfo" type="ClampingOperationInfo" link="ClampingOperationInfo.html">
            Information about the Clamping Operation. See the ClampingOperationInfo page for more information.
            </param>
            <displayName id="OnOriginCellsClamped">
            OnOriginCellsClamped(ClampingOperationInfo)
            </displayName>
            <syntax>
            void OnOriginCellsClamped(ClampingOperationInfo operationInfo)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkManager">
            <summary>
            Provides a base implementation for Chunk Managers. These managers perform two tasks:
            <para>
            1) They provide implementations for Asset Chunk Type specific logic, like getting/setting chunk positions and activating/deactivated asset chunks.
            </para>
            <para>
            2) They interface between the 
            <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see> and <see cref="T:DeepSpaceLabs.SAM.ChunkStreamer" href="ChunkStreamer.html">Chunk Streamers</see>. When the World needs chunks for 
            one or more <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cells</see>, it requests them from the Chunk Manager assigned to a particular LOD. The manager may have the needed chunks already (if using a 
            pooling manager), however if it does not, it requests new chunks be streamed in via the Chunk Streamer assigned to the same LOD. In addition, when 
            the World no longer needs a World Cell, the World Cell is sent to the manager so that its chunks can be processed. The manager may choose to pool 
            the chunks, or unload them from the scene (via the Chunk Streamer). This strategy 
            allows for different chunk life cycle management strategies to be employed, including custom ones you write yourself.
            </para>
            <para>
            The provided default managers are the 
            <see cref="T:DeepSpaceLabs.SAM.NonPoolingChunkManager" href="NonPoolingChunkManager.html">
            NonPoolingChunkManager
            </see>, 
            <see cref="T:DeepSpaceLabs.SAM.PoolingChunkManager" href="PoolingChunkManager.html">
            PoolingChunkManager</see>, and 
            <see cref="T:DeepSpaceLabs.SAM.DistancePoolingChunkManager" href="DistancePoolingChunkManager.html">
            DistancePoolingChunkManager
            </see>.
            </para>
            <para>
            The actual method of loading new chunks into the scene and unloading uneeded chunks from the scene is left up 
            to the <see cref="T:DeepSpaceLabs.SAM.ChunkStreamer" href="ChunkStreamer.html">Chunk Streamer</see> you are using. Think of the 
            Chunk Manager not as a creator/destroyer, but as a manager that determines whether uneeded objects 
            should be kept in the scene, and if so, managing the lifetime of them so that they can be reused in the future. You can also 
            think of it as specific logic that targets the exact type of objects you are using.
            </para>
            <para>
            All Chunk Managers are configured to work with any chunk (both game object based and non game object based), 
            however there are certain methods of the Chunk Manager class 
            that are by default, configured to work with Game Objects. Those methods include:
            </para>
            <para>
            GetChunkPosition - For retrieving the Vector3Double position of a chunk. Only called if the LOD using this manager has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkPosition - For setting the chunk position to a Vector3Double value. Only called if the LOD using this manager has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkActiveState - For setting the state of the chunk to active or deactive. This method is called only if Auto Activate/Deactivate 
            Cell Chunks is enabled in your World inspector, for any LODs that use this manager.
            </para>
            <para>
            If you anticipate any of these methods being called, you will need to create a custom class deriving from this one or one of the existing Chunk Managers, 
            and in that class override the methods that will be called, so that they function correctly with your custom chunks.
            </para>
            <para>
            Additional Note: This component contains its own special class (ChunkManagerUser) which enables multiple 
            users to use the manager at the same time. The data associated with each user is stored in this user object and retrieved
            using the userID passed into each method.
            </para>
            <para>
            This user object does not contain any data by default other than the 
            <see cref="T:DeepSpaceLabs.SAM.IZoneLODGroup" href="IZoneGrouping.html">IZoneGrouping</see> object associated with the user and the chunkStreamerUserID of 
            the user (in reference to the Chunk Streamer it uses). You can access the user object via the  
            <see cref="P:DeepSpaceLabs.SAM.ChunkManager.RegisteredUsers" href = "#RegisteredUsers">RegisteredUsers</see> property and userID, 
            like so: RegisteredUsers[userID].
            </para>
            <para>
            You may also create your own custom user object class which
            derives from ChunkManagerUser, in order to store custom data or add custom methods. 
            In fact, this strategy is utilized by some of the other Chunk Managers in the kit. Simply override the
            <see cref="M:DeepSpaceLabs.SAM.ChunkManager.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32)" href = "#CreateNewUser">CreateNewUser</see> method and return your custom user object.
            </para>
            <para>
            The properties, methods, and constructors of this ChunkManagerUser class have been included on this webpage along side 
            the other members of the ChunkManager class. You can easily identify them as their member names include a ChunkManagerUser prefix. You can 
            use these as a reference when creating custom ChunkManagerUser classes.
            </para>
            <para>
            You should never have to interact directly with the Chunk Manager unless deriving from it, 
            as its methods/properties are called/used as needed by the Streamable Assets Manager automatically.
            </para>
            </summary>
            <title>ChunkManager Abstract Class</title>
            <category>Chunk Managers</category>
            <navigationName>ChunkManager</navigationName>
            <fileName>ChunkManager.html</fileName>
            <syntax>public abstract class ChunkManager : MonoBehaviour</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkManager.AttachmentProgress">
            <summary>
            Tracks the progress of this Chunk Manager's current AttachChunksToCells method call as a value between 0 (no chunks attached) and 1 (all chunks attached). 
            The progress is calculated automatically by the base Chunk Manager class. It does so by calculating the total number of Asset Chunks that need to be attached. After 
            AttachChunksAlreadyInSceneToCells is called, it increments the progress by a value equal to total reused chunks / total chunks to attach. The remaining Cell's that 
            still need Chunks are passed to the LOD Group's Chunk Streamer. The progress from the Chunk Streamer is then used to increment the AttachmentProgress the rest of the way to 1.
            </summary>
            <type>float</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkManager.ChunkReusePossible">
            <summary>
            Gets a value indicating whether chunk reuse is possible on this manager. Reuse allows 
            chunks from one World Cell to be used by another. This just returns the value as set 
            in the inspector of your manager, which is by default set to true, as reuse is an 
            invaluable means of removing some unecessary loading and unloading.
            <para>
            When true, the managers 
            <see cref="T:DeepSpaceLabs.SAM.ChunkReuseJudge" href="ChunkReuseJudge.html">ChunkReuseJudge</see> is used to determine if 
            a deactivated World Cell's chunks can be reused on a World Cell that is soon to be activated. If the 
            reuse judge determines that objects can be reused, the chunks are transferred from the old World Cell to the 
            new World Cell, reducing the number of new assets that need to be streamed in.
            </para>
            <para>
            You can set the setting to false in the inspector, 
            which is especially useful if you know that reuse is impossible.
            </para>
            <para>
            For instance, imagine a scenario where the manager is used to load unique per World Cell chunks. 
            Reuse would only be possible on two World Cells with the same Streamable Grid Cell index in this scenario. If, however, 
            the World is not endless, there would never be a situation where a deactivated World Cell and new World Cell (that 
            is soon to be activated) both exist with the same Streamable Grid Cell index. Thus, reuse would be impossible. By 
            setting this value to false, some overhead related to checking for reuse potential is eliminated, which should 
            result in slightly faster loading and unloading.
            </para>
            <para>
            With that said, you should take extreme care when setting the value to false, 
            as it will disable all attempts to reuse objects on whatever worlds/World Groupings, and/or LODs that are using 
            the manager, which may eliminate some potential performance boosts.
            </para>
            <para>
            Also note that Chunk Reuse does not apply to pooling logic on any derived Chunk Managers. If you want to 
            create a pooling manager that allows chunks from different Streamable Grid Cell's to be used interchangeably, 
            you will need to create a custom manager that does so.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkManager.RegisteredUsers">
            <summary>
            Gets the users registered with the manager.
            </summary>
            <type link="RegistrationHandler.html">RegistrationHandler&lt;ChunkManagerUser&gt;</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.Awake">
            <summary>
            The Chunk Manager's Awake method, called by Unity. You cannot utilize Awake in your derived class. 
            If you need to perform some sort of Awake related logic, override the AwakeExtended method, which will be called by this 
            classes Awake method. Also note that you do not need to call base.AwakeExtended(); from your AwakeExtended method, as 
            this is a virtual empty method that does nothing unless you override it. Also note that this method is protected simply so 
            that if you derive from this class, you will see an error when trying to add the Awake method.
            </summary>
            <displayName id="Awake">
            Awake()
            </displayName>
            <syntax>
            protected void Awake()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.AwakeExtended">
            <summary>
            Can be overriden to perform logic that would normally go in Awake (which is used by the base class). 
            Use this instead of implementing Awake! You do not need to 
            call base.AwakeExtended if you override this, as the base method is empty.
            </summary>
            <displayName id="AwakeExtended">AwakeExtended()</displayName>
            <syntax>protected virtual void AwakeExtended()</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.OnDestroy">
            <summary>
            The Chunk Manager's OnDestroy method, called by Unity. You cannot utilize OnDestroy in your derived class, 
            if you need to perform some sort of OnDestroy related logic, override the OnDestroyExtended method, which will be called by this 
            classes OnDestroy method. Also note that you do not need to call base.OnDestroyExtended(); from your OnDestroyExtended method, as 
            this is a virtual empty method that does nothing unless you override it. Also note that this method is protected simply so 
            that if you derive from this class, you will see an error when trying to add the OnDestroy method.
            </summary>
            <displayName id="OnDestroy">
            OnDestroy()
            </displayName>
            <syntax>
            protected void OnDestroy()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.OnDestroyExtended">
            <summary>
            Can be overriden to perform logic that would normally go in OnDestroy (which is used by the base class). 
            Use this instead of implementing OnDestroy! You do not need to 
            call base.OnDestroyExtended if you override this, as the base method is empty.
            </summary>
            <displayName id="OnDestroyExtended">
            OnDestroyExtended()
            </displayName>
            <syntax>
            protected virtual void OnDestroyExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.Register(DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32@)">
            <summary>
            A user can call this method to register with the Chunk Manager. 
            The userID must be stored by the user
            and passed in when calling the methods of the Chunk Manager.
            <para>
            The Chunk Manager automatically registers the Zone LOD Group with its assigned 
            Chunk Streamer as well.
            </para>
            </summary>
            <param name="zoneLODGroup" type="IZoneLODGroup" link="IZoneLODGroup.html">
            The Zone LOD Group being registered.</param>
            <param name="userID" type="int">
            An ID that is assigned to the user when this method is called. Each user has its
            own ChunkManagerUser object created for it.
            </param>
            <displayName id="Register">
            Register(IZoneLODGroup, out int)
            </displayName>
            <syntax>
            public void Register(IZoneLODGroup zoneLODGroup, out int userID)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.OnUserRegistered(DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Called just after a user has been registered by the Chunk Manager. You can 
            override this in a custom manager to perform additional post-registration logic on a per user basis.
            </summary>
            <param name="user" type="ChunkManagerUser">
            The user that has just beeen registered.
            </param>
            <displayName id="OnUserRegistered">
            OnUserRegistered(ChunkManagerUser)
            </displayName>
            <syntax>
            public virtual void OnUserRegistered((ChunkManagerUser user)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.DeRegister(System.Int32)">
            <summary>
            A user can call this method to de register with the Chunk Manager. The Chunk 
            Manager will also automatically de-register the LOD Group with its assigned 
            Chunk Streamer.
            </summary>
            <param name="userID" type="int">The ID of the user to de register.</param>
            <displayName id="DeRegister">DeRegister(int)</displayName>
            <syntax>public void DeRegister(int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.GetChunkStreamerIDOfUser(System.Int32)">
            <summary>
            Can be used to retrieve the chunk streamer ID of a given Chunk Manager user.
            </summary>
            <param name="userID" type="int">
            the ID of the chunk manager user.
            </param>
            <returns type="int">
            The chunk streamer user ID.
            </returns>
            <displayName id="GetChunkStreamerIDOfUser">
            GetChunkStreamerIDOfUser(int)
            </displayName>
            <syntax>
            public int GetChunkStreamerIDOfUser(int userID)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.OnUserDeRegistering(DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Called just before a user is deregistered by the Chunk Manager. You can 
            override this in a custom manager to perform additional pre-deregistration logic on a per user basis.
            </summary>
            <param name="user" type="ChunkManagerUser">
            The user that is about to be deregistered.
            </param>
            <displayName id="OnUserDeRegistering">
            OnUserDeRegistering(ChunkManagerUser)
            </displayName>
            <syntax>
            public virtual void OnUserDeRegistering((ChunkManagerUser user)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.OnUserDeRegistered(DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Called just after a user has been deregistered by the Chunk Manager. You can 
            override this in a custom manager to perform additional post-deregistration logic on a per user basis.
            </summary>
            <param name="user" type="ChunkManagerUser">
            The user that has just beeen deregistered.
            </param>
            <displayName id="OnUserDeRegistered">
            OnUserDeRegistered(ChunkManagerUser)
            </displayName>
            <syntax>
            public virtual void OnUserDeRegistered((ChunkManagerUser user)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32)">
            <summary>
            Method used to create a new user object during user registration. This can be overridden to return
            a custom user object. User objects store pertitent information about a particular ZoneGrouping. They allow the 
            Chunk Manager to be used with multiple LOD's/Zone Groupings.
            </summary>
            <param name="zoneGrouping" type="IZoneGrouping" link="IZoneGrouping.html">The Zone Grouping that the user object is being created for.</param>
            <param name="chunkStreamerUserID" type="int">When the Zone Grouping registered with the manager, the manager automatically registered the 
            Zone Grouping with the Chunk Streamer associated with it. This is the user ID assigned to the Zone Grouping by that Chunk Streamer, and can 
            be used if you need to interface with the Chunk Streamer for some reason.
            </param>
            <returns type="ChunkManagerUser">
            The new user created, which may be a basic ChunkManagerUser or may be a custom user object as returned by the derived Chunk Manager.
            </returns>
            <displayName id="CreateNewUser">CreateNewUser(IZoneGrouping, int)</displayName>
            <syntax>protected virtual ChunkManagerUser CreateNewUser(IZoneGrouping zoneGrouping, int chunkStreamerUserID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.AttachChunksToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Attaches chunks to the list of passed in cells in a single frame. This is done by first calling the 
            AttachChunksAlreadyInSceneToCellsInSingleFrame method. If any cells still need chunks after calling this method, 
            they are passed to the Chunk Streamer associated with the user, which carries out this function.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells that need chunks attached.</param>
            <param name="userID" type="int">The ID of the user requesting the attachment.</param>
            <displayName id="AttachChunksToCellsInSingleFrame">AttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public abstract void AttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.AttachChunksAlreadyInSceneToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            When overridden in a derived class, attaches any chunks already in the scene to the appropriate cells in a single frame.
            <para>
            Overriding this method is optional. If you don't, all cells will be sent to the Chunk Streamer for it to load new chunks 
            into the scene.
            </para>
            <para>
            If you do have chunks to attach, you must attach all chunks needed by the cell using the 
            WorldCell.AttachChunkToCell method, and then remove the cell from the list so that it is not sent to the 
            Chunk Streamer (otherwise, uneeded chunks will be loaded into the scene!).
            </para>
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells that need chunks attached.</param>
            <param name="user" type="ChunkManagerUser">The user requesting the attachment.</param>
            <displayName id="AttachChunksAlreadyInSceneToCellsInSingleFrame">
            AttachChunksAlreadyInSceneToCellsInSingleFrame(List&lt;WorldCell&gt;, ChunkManagerUser)
            </displayName>
            <syntax>
            protected virtual void AttachChunksAlreadyInSceneToCellsInSingleFrame(List&lt;WorldCell&gt; cells, ChunkManagerUser user)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.AttachChunksToCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Attaches chunks to the list of passed in cells. This is done by first calling the 
            AttachChunksAlreadyInSceneToCells method. If any cells still need objects after calling this method, 
            they are passed to the attached Chunk Streamer, which carries out this function.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells whose objects need to be attached.
            </param>
            <param name="userID" type = "int">
            The ID of the user requesting the attachment.
            </param>
            <displayName id = "AttachChunksToCells">
            AttachChunksToCells(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; AttachChunksToCells(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.AttachChunksAlreadyInSceneToCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            When overridden in a derived class, attaches any chunks already in the scene to the appropriate cells over multiple frames.
            <para>
            Overriding this method is optional. If you don't, all cells will be sent to the Chunk Streamer for it to stream new chunks 
            into the scene.
            </para>
            <para>
            If you do have chunks to attach, you must attach all chunks needed by the cell using the 
            WorldCell.AttachChunkToCell method, and then remove the cell from the list so that it is not sent to the 
            Chunk Streamer (otherwise, uneeded objects will be loaded into the scene!).
            </para>
            <para>
            Never store the World Cells themselves for later use; only store non reference data associated with the World Cells (although, 
            for this method, that should not be needed).
            </para>
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells that need chunks attached.</param>
            <param name="user" type="ChunkManagerUser">The user requesting the attachment.</param>
            <displayName id="AttachChunksAlreadyInSceneToCells">
            AttachChunksAlreadyInSceneToCells(List&lt;WorldCell&gt;, ChunkManagerUser)
            </displayName>
            <syntax>
            protected virtual IEnumerator&lt;YieldInstruction&gt; AttachChunksAlreadyInSceneToCells(List&lt;WorldCell&gt; cells, ChunkManagerUser user)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.DetachAndProcessChunksFromDeactivatedCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Detaches and processes the chunks associated with the input cells over a period of frames.
            <para>
            This method first calls the DetachAndProcessChunksToKeepInScene method, which is implemented by 
            derived classes. This method loops through the list of cells and determines if any of them can be reused or otherwise 
            do not need to be unloaded from the scene. It removes those cells from the list and stores or does whatever with the 
            chunks (chunks).
            </para>
            <para>
            If there are any cells remaining, they are sent to the Chunk Streamer via its 
            DetachAndUnloadChunksFromCells method so that the objects associated with the cells can be unloaded.
            </para>
            <para>
            Please note, previously this method was abstract and had to be implemented by derived classes. The new method to implement is 
            DetachAndProcessChunksFromDeactivatedCells, which should do pretty much the same thing, except cells from the list 
            need to be removed if you don't want their objects to be unloaded, and you must not do any sort of object unloading yourself.
            </para>
            </summary>
            <param name="deactivatedCells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose objects need to be detached and processed.</param>
            <param name="userID" type = "int">The ID of the user requesting the detachment and processing.</param>
            <displayName id = "DetachAndProcessChunksFromDeactivatedCells">
            DetachAndProcessChunksFromDeactivatedCells(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public abstract IEnumerator&lt;YieldInstruction&gt; DetachAndProcessChunksFromDeactivatedCells(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.DetachAndProcessChunksToKeepInScene(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Optionally overridable method that should detach and processes the objects associated with the input cells over a period of frames, but 
            only for cells with objects that should be kept in the scene. For example, if using a pooling system, this method would 
            store the objects for any cells determined to be reusable. When such reusable cells are found, 
            you must remove the World Cell from the list, 
            and you must remove all chunks belonging to the cell. As such, 
            it is best to process the list of cell in descending order so that you can remove them as you go.
            <para>
            Once this processing is complete, any remaining cells are passed along to the Chunk Streamer to be unloaded from 
            the scene.
            </para>
            <para>
            If you are NOT using a pooling solution or otherwise don't want to keep any objects in the scene, 
            you can choose to NOT override this method, however consider that there is very little point in creating a custom 
            Chunk Manager if you are not retaining objects in the scene.
            </para>
            <para>
            It's also important to note that you SHOULD not store the World Cells themselves for later use, for example for the purpose 
            of determining if specific objects can be reused by another World Cell down the line. Instead, store non reference data 
            of the World Cell, such as its CellOnStreamableGrid or CellOnEndlessGrid, and use that data instead to make those determinations. 
            </para>
            <para>
            The reason is, internally SAM keeps track of these World Cells and once this method is finished executing, it clears the World 
            Cell's data and returns them to an internal pool to be reused, thus conserving memory. The input list is a duplicated list, therefore 
            removing a World Cell from the list does not effect this process.
            </para>
            </summary>
            <param name="deactivatedCells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells whose objects need to be detached and processed.
            </param>
            <param name="user" type = "ChunkManagerUser">
            The user requesting the detachment and processing.
            </param>
            <displayName id = "DetachAndProcessChunksToKeepInScene">
            DetachAndProcessChunksToKeepInScene(List&lt;WorldCell&gt;, ChunkManagerUser)
            </displayName>
            <syntax>
            protected virtual IEnumerator&lt;YieldInstruction&gt; DetachAndProcessChunksToKeepInScene(List&lt;WorldCell&gt; cells, ChunkManagerUser user)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.GetChunkPosition(System.Object)">
            <summary>
            Default implementation to get the position of a single asset chunk associated with a World Cell.
            <para>
            The default behaviour is to simply get the transform position of the chunk, which assumes the chunk is a GameObject.
            You can override this using a custom manager if your objects are not traditional game objects (and thus do 
            not have transform components), however you only need to do so if you have indicated on your Streamable Grid LOD that 
            the objects use positional data, or if the objects are Terrain.
            </para>
            </summary>
            <param name="chunk" type="System.Object">
            The chunk whose position to get.
            </param>
            <displayName id="GetChunkPosition">
            GetChunkPosition(object)
            </displayName>
            <syntax>
            public virtual Vector3Double GetChunkPosition(object chunk)
            </syntax>
            <returns type="Vector3Double.html">
            The Chunk's position as a Vector3Double.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.SetChunkPosition(System.Object,DeepSpaceLabs.SAM.Vector3Double)">
            <summary>
            Default implementation to set the position of a single chunk associated with a World Cell.
            <para>
            The default behaviour is to simply set the transform position of the object to the passed in position. 
            You can override this using a custom manager, which would typically be done for one of two reasons.
            </para>
            <para>
            1) If you do not need your chunks to be positioned (i.e., the position of the chunks does not matter, 
            in which case setting the position is an uneccesary performance hit).
            </para>
            <para>
            2) If your chunks are not traditional GameObjects and thus cannot be positioned using a transform component.
            </para>
            <para>
            Note, you only need to do so if you have indicated on your Streamable Grid LOD that 
            the objects use positional data, or if the objects are Terrain.
            </para>
            </summary>
            <param name="chunk" type="System.Object">
            The chunk whose position should be set.
            </param>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position to set the chunk to.
            </param>
            <displayName id="SetChunkPosition">
            SetChunkPosition(object, Vector3Double)
            </displayName>
            <syntax>
            public virtual void SetChunkPosition(object chunk, Vector3Double position)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.GetChunkActiveState(System.Object)">
            <summary>
            Gets the active state of the chunk. This is not necessarily whether the chunk is 
            active in the scene view, but should be instead the active state of the chunk itself (such as activeSelf).
            </summary>
            <param name="chunk" type="System.Object">
            The chunk whose position should be set.
            </param>
            <returns type="bool">True if the chunk is active, false otherwise. For Game Objects (which the 
            default implementation assumes the chunk is) this returns the activeSelf property, meaning the chunk 
            may not actually be active in the scene.
            </returns>
            <displayName id="GetChunkActiveState">
            GetChunkActiveState(object)
            </displayName>
            <syntax>
            public virtual bool GetChunkActiveState(object chunk)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.SetChunkActiveState(System.Object,System.Boolean,DeepSpaceLabs.SAM.WorldCell,System.Int32)">
            <summary>
            Default implementation to set the chunk for a World Cell as active or deactive. The default behaviour, which 
            calls GameObject.SetActive, should be sufficient if your chunks are normal Unity Game Objects. 
            Typically, you would only override this method if using non game objects.
            <para>
            Also note that this method is only called if 
            either 'Auto Activate Chunks When Adding Cells' or 'Auto Deactivate Chunks When 
            Removing Cells' are enabled for the LOD using your Chunk Manager, so if these options 
            would always be disabled, there is no need to override this method.
            </para>
            </summary>
            <param name="chunk" type="System.Object">
            The chunk to set to active or deactive.
            </param>
            <param name="isActive" type="bool">
            True if the chunk should be set to active, false if it should be set to deactive.
            </param>
            <param name="worldCellOfChunk" type="WorldCell" link="WorldCell.html">
            The World Cell the chunk belongs to.
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk in relation to other chunks belonging to the World Cell.
            </param>
            <displayName id="SetChunkActiveState">
            SetChunkActiveState(object, bool, WorldCell, int)
            </displayName>
            <syntax>
            public virtual void SetChunkActiveState(object chunk, bool isActive, WorldCell worldCellOfChunk, int chunkIndex)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser">
            <summary>
            Stores LOD Group user related data. You can create a custom class deriving 
            from this type in order to store additional data or provide user specific 
            properties/methods. If you do, you need to override the CreateNewUser method 
            in your custom Chunk Manager to return an instance of this new class.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser.ChunkManager">
            <summary>
            Gets the Chunk Manager instance that created this user object.
            </summary>
            <type link="ChunkManager.html">ChunkManager</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser.ChunkStreamerUserID">
            <summary>
            Gets the User ID of the LOD Group that was assigned to it by the 
            Chunk Streamer when it was registered with it.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser.ZoneLODGroup">
            <summary>
            Gets the LOD Group this user object is associated with.
            </summary>
            <type link="IZoneLODGroup.html">IZoneLODGroup</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser.StreamableGrid">
            <summary>
            Get the Streamable Grid associated with the LOD Group.
            </summary>
            <type link="StreamableGrid.html">StreamableGrid</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser.#ctor(DeepSpaceLabs.SAM.ChunkManager,DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32)">
            <summary>
            Create an instance of the Chunk Manager User object. If you are overriding the ChunkManager class and 
            not overriding the ChunkManagerUser, you can create a new instance of this user object via this 
            constructor, which can be returned in the ChunkManager's CreateNewUser method.
            <para>
            If you are overriding ChunkManagerUser, your custom user class will need constructors with at least these parameters 
            (but can also have more), and they must also call the base constructor, which is accomplished by placing 
            : (chunkManager, ZoneGrouping, chunkStreamerUserID) after your constructor declaration.
            </para>
            <para>
            Note, this construct can only be used from a class deriving from ChunkManager or ChunkManagerUser.
            </para>
            </summary>
            <param name="chunkManager" type="ChunkManager" link="ChunkManager.html">
            The parent Chunk Manager instance creating the user object.
            </param>
            <param name="zoneLODGroup" type="IZoneLODGroup" link="IZoneLODGroup.html">
            The Zone LOD Group the user object is being created for.
            </param>
            <param name="chunkStreamerUserID" type="int">
            The User ID of the LOD Group that was assigned to it by the 
            Chunk Streamer when it was registered with it. 
            </param>
            <displayName id="ChunkManagerUser.ChunkManagerUser">
            ChunkManagerUser.ChunkManagerUser(ChunkManager, IZoneLODGroup, int)
            </displayName>
            <syntax>
            public ChunkManagerUser(ChunkManager chunkManager, IZoneLODGroup zoneLODGroup, int chunkStreamerUserID)
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.OneBasedOriginCell">
            <summary>
            The current one based Origin Cell of this zone grouping.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.World">
            <summary>
            The World the grouping belongs to.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.StreamableGrid">
            <summary>
            The Streamable Grid associated with the grouping.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.#ctor(DeepSpaceLabs.SAM.World,System.Int32,System.Int32,DeepSpaceLabs.SAM.ZoneSettings,DeepSpaceLabs.SAM.ZoneGroupingSettings,DeepSpaceLabs.SAM.WorldGroupingSettings,DeepSpaceLabs.SAM.WorldGroupingPoolingOptions,DeepSpaceLabs.SAM.GridValues{System.Boolean},DeepSpaceLabs.SAM.Cell,System.Collections.Generic.List{DeepSpaceLabs.SAM.StreamableGrid.IncompatibilityError})">
            <summary>
            Translation function expects a zero based Endless Grid Cell (though if a Streamable Grid Cell is passed in, 
            it will return a Streamable Grid Cell.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.ChunkStreamer">
            <summary>
            Gets the Chunk Streamer that the Zone Grouping uses.
            </summary>
            <type link="ChunkStreamer.html">ChunkStreamer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.ChunkReuseLogic">
            <summary>
            Gets the Logic used to determine if the chunks from one World Cell can be reused on a different World Cell for this 
            Zone Grouping. The logic takes in the Streamable Grid Cell indexes of both World Cell's. This is useful in custom Chunk Managers 
            if you want to implment pooling logic that takes into account reuse logic. Note that this will return null if the 
            Chunk Manager the Zone Grouping is being used with has cell reuse disabled.
            </summary>
            <type>ChunkReuseJudge.JudgementDelegate</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.ZoneIndex">
            <summary>
            Gets the index of the Zone the Zone Grouping belongs to.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.WorldGroupingIndex">
            <summary>
            Gets the index of the World Grouping the Zone Grouping belongs to.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.GridLODDetails">
            <summary>
             Gets an object containing details about this Zone Grouping. These included LOD Group specific settings found on the Streamable Grid.
            </summary>
            <type link="GridLODDetails.html">GridLODDetails</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.GroupName">
            <summary>
            Gets the Group Name associated with the Zone Grouping.
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.InitialOriginCell">
            <summary>
            The initial Origin Cell of the Zone Grouping, calculated from the Origin Cell set in the inspector of your 
            World. Note, however, that this is different than that Origin Cell, since this is the Origin Cell of the 
            Zone Grouping, while the one in the inspector is the Origin Cell of World as a whole, using its imaginary World Grid.
            <para>
            If you want the current origin cell of the Zone Grouping, use 
            <see cref="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.OriginCell" href="#OriginCell">OriginCell</see> instead.
            </para>
            <para>
            The Zone Grouping Origin Cell is the Cell in the Zone whose position is closest to the current Origin Position, 
            which changes depending on the World's Origin Cell. If multiple Cells' positions are equadistant from the Origin Position, the 
            Cell closest to 0,0,0 is used. If that does not break the "tie", the Cell with smallest position value will be used.
            </para>
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.OriginCell">
            <summary>
            Gets the current Origin Cell of the Zone Grouping.
            <para>
            This is the same value returned by World.GetOriginCellOfZoneGrouping when ZoneIndex and 
            WorldGroupingIndex are passed in.
            </para>
            <para>
            The Zone Grouping Origin Cell is the Cell whose position is closest to the current Origin Position, 
            which changes depending on the World's Origin Cell. If multiple Cells' positions are equadistant from the Origin Position, the 
            Cell closest to 0,0,0 is used. If that does not break the "tie", the Cell with smallest position value will be used.
            </para>
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.OriginCellPosition">
            <summary>
            Gets the current position of the Origin Cell for the Zone Grouping.
            <para>
            This is the same value returned by World.GetOriginCellPositionOfZoneGrouping when  
            ZoneIndex and WorldGroupingIndex are passed in.
            </para>
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.World">
            <summary>
            Gets the World associated with the Zone Grouping.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneGrouping.ZoneLODGroup.UsedWithHierarchyOrganizer">
            <summary>
            Gets a value indicating whether the Zone Grouping is being used with a Hierarchy Organizer. Returns false if the World has not been assigned a Hierarchy Organizer, if the Asset Chunks used by the Zone Grouping are not Game Objects, or 
            if the LOD Group associated with the Zone Grouping (or the World Grouping it belongs to) has 'Use With Hierarcy Organizer' disabled.
            </summary>
            <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.GetPositionOfEndlessGridRow(System.Int32,System.Int32,System.Double)">
            <summary>
            Gets the position of a row on a theoretically Endless Grid. Note that the Streamable Grid knows nothing about 
            positioning in World Space, so for this method to work you you must pass in the Current Origin Cell row of your world and 
            the position of that Origin Cell row. If using this with a World component, the Origin Cell row can be queried 
            via the World's OriginCell property, while the position can be queried via the OriginRowPosition property.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridRow" type="int">The row whose position you wish to get.</param>
            <param name="originCellRow" type="int">The Origin Cell row of your World.</param>
            <param name="originCellRowPosition" type="double">The Origin Cell row position of your World.</param>
            <displayName id="GetPositionOfEndlessGridRow">GetPositionOfEndlessGridRow(int, int, double)</displayName>
            <syntax>public double GetPositionOfEndlessGridRow(int endlessGridRow, int originCellRow, double originCellRowPosition)</syntax>
            <returns type="flaot">The position of the Endless Grid row.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridRowPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@)">
            <summary>
            Finds the Endless Grid row that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridRowAndPositionPointIsIn(double, int, double, out double)" href="#FindEndlessGridRowAndPositionPointIsIn">FindEndlessGridRowAndPositionPointIsIn</see> 
            if you need the scene space position of the row, or 
            <see cref="!:FindEndlessGridRowPointIsIn(double, int, double, out double)" href="#FindEndlessGridRowPointIsIn2">FindEndlessGridRowPointIsIn (alt)</see> if you need the row displacement from the originCellRowPosition.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="double">The point that will be used to find the Endless Grid row.</param>
            <param name="originCellRow" type="int">The Origin Cell row of your World.</param>
            <param name="originCellRowPosition" type="double">The Origin Cell row position of your World.</param>
            <displayName id="FindEndlessGridRowPointIsIn1">FindEndlessGridRowPointIsIn(double, int, double)</displayName>
            <syntax>public int FindEndlessGridRowPointIsIn(double point, int originCellRow, double originCellRowPosition)</syntax>
            <returns type="int">The Endless Grid row that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridRowPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@,System.Double@)">
            <summary>
            Finds the Endless Grid row that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridRowAndPositionPointIsIn(double, int, double, out double)" href="#FindEndlessGridRowAndPositionPointIsIn">FindEndlessGridRowAndPositionPointIsIn</see> 
            if you need the scene space position of the row, or 
            <see cref="!:FindEndlessGridRowPointIsIn(double, int, double)" href="#FindEndlessGridRowPointIsIn1">FindEndlessGridRowPointIsIn</see> 
            if you only need the row without any position data.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="double">The point that will be used to find the Endless Grid row.</param>
            <param name="originCellRow" type="int">The Origin Cell row of your World.</param>
            <param name="originCellRowPosition" type="double">The Origin Cell row position of your World.</param>
            <param name="rowDisplacementFromOrigin" type="double">An additional out parameter that meausres the displacement of the 
            found Endless Grid row to the Origin Cell's row.</param>
            <displayName id="FindEndlessGridRowPointIsIn2">FindEndlessGridRowPointIsIn(double, int, double, out double)</displayName>
            <syntax>public int FindEndlessGridRowPointIsIn(double point, int originCellRow, double originCellRowPosition, out double rowDistanceFromOrigin)</syntax>
            <returns type="int">The Endless Grid row that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridRowAndPositionPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@,System.Double@)">
            <summary>
            Finds the Endless Grid row and scene position of the row that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridRowPointIsIn(double, int, double)" href="#FindEndlessGridRowPointIsIn1">FindEndlessGridRowPointIsIn</see> 
            if you don't care about the position of the layer. If you want to know the displacement of the row from the input originCellRowPosition, use 
            <see cref="!:FindEndlessGridRowPointIsIn(double, int, double, out double)" href="#FindEndlessGridRowPointIsIn2">FindEndlessGridRowPointIsIn (alt)</see>.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="double">The point that will be used to find the Endless Grid row.</param>
            <param name="originCellRow" type="int">The Origin Cell row of your World.</param>
            <param name="originCellRowPosition" type="double">The Origin Cell row position of your World.</param>
            <param name="rowPosition" type="double">An additional out parameter that tells you the scene position of the row.</param>
            <displayName id="FindEndlessGridRowAndPositionPointIsIn">FindEndlessGridRowAndPositionPointIsIn(double, int, double, out double)</displayName>
            <syntax>public int FindEndlessGridRowAndPositionPointIsIn(double point, int originCellRow, double originCellRowPosition, out double rowPosition)</syntax>
            <returns type="int">The Endless Grid row that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.GetPositionOfEndlessGridColumn(System.Int32,System.Int32,System.Double)">
            <summary>
            Gets the position of a column on a theoretically Endless Grid. Note that the Streamable Grid knows nothing about 
            positioning in World Space, so for this method to work you you must pass in the Current origin 
            cell column of your world and 
            the position of that Origin Cell column. If using this with a World component, the Origin Cell column can be queried 
            via the World's OriginCell property, while the position can be queried via the OriginColumnPosition property.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridColumn" type="int">The column whose position you wish to get.</param>
            <param name="originCellColumn" type="int">The Origin Cell column of your World.</param>
            <param name="originCellColumnPosition" type="double">The Origin Cell column position of your World.</param>
            <displayName id="GetPositionOfEndlessGridColumn">GetPositionOfEndlessGridColumn(int, int, double)</displayName>
            <syntax>public double GetPositionOfEndlessGridColumn(int endlessGridColumn, int originCellColumn, double originCellColumnPosition))</syntax>
            <returns type="flaot">The position of the Endless Grid column.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridColumnPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@)">
            <summary>
            Finds the Endless Grid column that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridColumnAndPositionPointIsIn(double, int, double, out double)" href="#FindEndlessGridColumnAndPositionPointIsIn">FindEndlessGridColumnAndPositionPointIsIn</see> 
            if you need the scene space position of the column, or 
            <see cref="!:FindEndlessGridColumnPointIsIn(double, int, double, out double)" href="#FindEndlessGridColumnPointIsIn2">FindEndlessGridColumnPointIsIn (alt)</see> if you need the columns displacement from the originCellColumnPosition.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="double">The point that will be used to find the Endless Grid column.</param>
            <param name="originCellColumn" type="int">The Origin Cell column of your World.</param>
            <param name="originCellColumnPosition" type="double">The Origin Cell column position of your World.</param>
            <displayName id="FindEndlessGridColumnPointIsIn1">FindEndlessGridColumnPointIsIn(double, int, double)</displayName>
            <syntax>public int FindEndlessGridColumnPointIsIn(double point, int originCellColumn, double originCellColumnPosition)</syntax>
            <returns type="int">The Endless Grid column that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridColumnPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@,System.Double@)">
            <summary>
            Finds the Endless Grid column that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridColumnAndPositionPointIsIn(double, int, double, out double)" href="#FindEndlessGridColumnAndPositionPointIsIn">FindEndlessGridColumnAndPositionPointIsIn</see> 
            if you need the scene space position of the column, or 
            <see cref="!:FindEndlessGridColumnPointIsIn(double, int, double)" href="#FindEndlessGridColumnPointIsIn1">FindEndlessGridColumnPointIsIn</see> 
            if you only need the column without any position data.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="double">The point that will be used to find the Endless Grid column.</param>
            <param name="originCellColumn" type="int">The Origin Cell column of your World.</param>
            <param name="originCellColumnPosition" type="double">The Origin Cell column position of your World.</param>
            <param name="columnDisplacementFromOrigin" type="double">An additional out parameter that meausres the displacement of the 
            found Endless Grid column to the Origin Cell's column.</param>
            <displayName id="FindEndlessGridColumnPointIsIn2">FindEndlessGridColumnPointIsIn(double, int, double, out double)</displayName>
            <syntax>public int FindEndlessGridColumnPointIsIn(double point, int originCellColumn, double originCellColumnPosition, out double columnDistanceFromOrigin)</syntax>
            <returns type="int">The Endless Grid column that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridColumnAndPositionPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@,System.Double@)">
            <summary>
            Finds the Endless Grid column and scene position of the column that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridColumnPointIsIn(double, int, double)" href="#FindEndlessGridColumnPointIsIn1">FindEndlessGridColumnPointIsIn</see> 
            if you don't care about the position of the column. If you want to know the displacement of the column from the input originCellColumnPosition, use 
            <see cref="!:FindEndlessGridColumnPointIsIn(double, int, double, out double)" href="#FindEndlessGridColumnPointIsIn2">FindEndlessGridColumnPointIsIn (alt)</see>.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="double">The point that will be used to find the Endless Grid column.</param>
            <param name="originCellColumn" type="int">The Origin Cell column of your World.</param>
            <param name="originCellColumnPosition" type="double">The Origin Cell column position of your World.</param>
            <param name="columnPosition" type="double">The scene position of the column (set after method runs).</param>
            <displayName id="FindEndlessGridColumnAndPositionPointIsIn">FindEndlessGridColumnAndPositionPointIsIn(double, int, double, out double)</displayName>
            <syntax>public int FindEndlessGridColumnAndPositionPointIsIn(double point, int originCellColumn, double originCellColumnPosition, out double columnPosition)</syntax>
            <returns type="int">The Endless Grid column that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.GetPositionOfEndlessGridLayer(System.Int32,System.Int32,System.Double)">
            <summary>
            Gets the position of a layer on a theoretically Endless Grid. Note that the Streamable Grid knows nothing about 
            positioning in World Space, so for this method to work you you must pass in the Current Origin Cell layer of your world and 
            the position of that Origin Cell layer. If using this with a World component, the Origin Cell layer can be queried 
            via the World's OriginCell property, while the position can be queried via the OriginLayerPosition property.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridLayer" type="int">The layer whose position you wish to get.</param>
            <param name="originCellLayer" type="int">The Origin Cell layer of your World.</param>
            <param name="originCellLayerPosition" type="double">The Origin Cell layer position of your World.</param>
            <displayName id="GetPositionOfEndlessGridLayer">GetPositionOfEndlessGridLayer(int, int, double)</displayName>
            <syntax>public double GetPositionOfEndlessGridLayer(int endlessGridLayer, int originCellLayer, double originCellLayerPosition)</syntax>
            <returns type="double">The position of the Endless Grid layer.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridLayerPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@)">
            <summary>
            Finds the Endless Grid layer that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridLayerAndPositionPointIsIn(double, int, double, out double)" href="#FindEndlessGridLayerAndPositionPointIsIn">FindEndlessGridLayerAndPositionPointIsIn</see> 
            if you need the scene space position of the layer, or 
            <see cref="!:FindEndlessGridLayerPointIsIn(double, int, double, out double)" href="#FindEndlessGridLayerPointIsIn2">FindEndlessGridLayerPointIsIn (alt)</see> if you need the layer displacement from the originCellLayerPosition.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="point" type="double">The point that will be used to find the Endless Grid layer.</param>
            <param name="originCellLayer" type="int">The Origin Cell layer of your World.</param>
            <param name="originCellLayerPosition" type="double">The Origin Cell layer position of your World.</param>
            <displayName id="FindEndlessGridLayerPointIsIn1">FindEndlessGridLayerPointIsIn(double, int, double)</displayName>
            <syntax>public int FindEndlessGridLayerPointIsIn(double point, int originCellLayer, double originCellLayerPosition)</syntax>
            <returns type="int">The Endless Grid layer that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridLayerPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@,System.Double@)">
            <summary>
            Finds the Endless Grid layer that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridLayerAndPositionPointIsIn(double, int, double, out double)" href="#FindEndlessGridLayerAndPositionPointIsIn">FindEndlessGridLayerAndPositionPointIsIn</see> 
            if you need the scene space position of the layer, or 
            <see cref="!:FindEndlessGridLayerPointIsIn(double, int, double)" href="#FindEndlessGridLayerPointIsIn1">FindEndlessGridLayerPointIsIn</see> 
            if you only need the layer without any position data.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <para>This is a runtime method and should not be used in the editor.</para>
            <param name="point" type="double">The point that will be used to find the Endless Grid layer.</param>
            <param name="originCellLayer" type="int">The Origin Cell layer of your World.</param>
            <param name="originCellLayerPosition" type="double">The Origin Cell layer position of your World.</param>
            <param name="layerDisplacementFromOrigin" type="double">An additional out parameter that meausres the displacement of the 
            found Endless Grid layer to the Origin Cell's layer. (Ex: if found cell is above the origin, displacement will be positive, if below it will be negative).</param>
            <displayName id="FindEndlessGridLayerPointIsIn2">FindEndlessGridLayerPointIsIn(double, int, double, out double)</displayName>
            <syntax>public int FindEndlessGridLayerPointIsIn(double point, int originCellLayer, double originCellLayerPosition, out double layerDistanceFromOrigin)</syntax>
            <returns type="int">The Endless Grid layer that the point is in.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ZoneGrouping.FindEndlessGridLayerAndPositionPointIsInOrClosestTo(System.Double,System.Int32,System.Double,System.Boolean@,System.Double@)">
            <summary>
            Finds the Endless Grid layer and scene position of the layer that a point in world space falls within. Use 
            <see cref="!:FindEndlessGridLayerPointIsIn(double, int, double)" href="#FindEndlessGridLayerPointIsIn1">FindEndlessGridLayerPointIsIn</see> 
            if you don't care about the position of the layer. If you want to know the displacement of the layer from the input originCellLayerPosition, use 
            <see cref="!:FindEndlessGridLayerPointIsIn(double, int, double, out double)" href="#FindEndlessGridLayerPointIsIn2">FindEndlessGridLayerPointIsIn (alt)</see>.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <para>This is a runtime method and should not be used in the editor.</para>
            <param name="point" type="double">The point that will be used to find the Endless Grid layer.</param>
            <param name="originCellLayer" type="int">The Origin Cell layer of your World.</param>
            <param name="originCellLayerPosition" type="double">The Origin Cell layer position of your World.</param>
            <param name="layerPosition" type="double">The scene position of the layer.</param>
            <displayName id="FindEndlessGridLayerAndPositionPointIsIn">FindEndlessGridLayerAndPositionPointIsIn(double, int, double, out double)</displayName>
            <syntax>public int FindEndlessGridLayerAndPositionPointIsIn(double point, int originCellLayer, double originCellLayerPosition, out double layerPosition)</syntax>
            <returns type="int">The Endless Grid layer that the point is in.</returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkStreamer">
            <summary>
            Provides a base implementation for Chunk Streamers. Chunk Streamers should be able
            to load objects over several frames and depending on the asset type, in a single frame. When single frame loading is impossible
            (as is the case with some load methods) pre-loading will be used (pre-loading occurs in one frame, then
            the actual single frame load occurs in the next).
            <para>
            In order to accomplish this, the 
            <see href = "#IsSingleFrameAttachmentPreloadRequired">IsSingleFrameAttachmentPreloadRequired</see> property must be
            overridden in the derived class to indicate whether pre-loading is required.
            </para>
            <para>
            If one or two frame loading is impossible, THAT'S OKAY!. However, you will need to 
            ensure that 'Initialize On Awake' is disabled on your Component Manager, and manually initialize the 
            everything over multiple frames via the InitializeGradually method (also via the Component Manager).
            </para>
            <para>
            The Chunk Streamer class is also responsible for unloading asset chunks from the scene as well! In addition, 
            you can use a custom Chunk Streamer to load and unload non Game Objects, by creating a custom Chunk Manager 
            that makes use of your custom objects. These non game objects can be stored on World Cells just as Game Objects, however 
            you will need to ensure that the Chunk Type on your LODs that use these objects are set to Custom Objects (on your Streamable Grid asset).
            </para>
            <para>
            Additional Note: This component contains its own special class (ChunkStreamerUser) which enables multiple 
            users to use the Chunk Streamer at the same time. The data associated with each user is stored in
            this user object and retrieved using the userID passed into each method. A user can effectively be thought of as a specific LOD from a 
            specific Streamable Grid. The utlization of users allows the same streamer to be used with multiple LODs, so long as these LODs are setup to work 
            with the settings configured on the streamer.
            </para>
            <para>
            This user object contains a <see cref="T:DeepSpaceLabs.SAM.CellString" href = "CellString.html">Cell String</see>, which you are
            free to use in your own derived Chunk Streamer component. You can access the user object and cell string via the  
            <see cref="P:DeepSpaceLabs.SAM.ChunkStreamer.RegisteredUsers" href = "#RegisteredUsers">RegisteredUsers</see> property and userID, like so: RegisteredUsers[userID] (accesses the user object) or RegisteredUsers[userID].CellString.
            </para>
            <para>
            You may also create your own custom user object class which
            derives from ChunkStreamerUser, in order to store custom data or add custom methods. 
            In fact, this strategy is utilized by some of the other Chunk Streamers in the kit. Simply override the
            <see cref="M:DeepSpaceLabs.SAM.ChunkStreamer.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup)" href = "#CreateNewUser">CreateNewUser</see> method and return your custom user object.
            </para>
            <para>
            The properties, methods, and constructors of this ChunkStreamerUser class have been included on this webpage along side 
            the other members of the ChunkStreamer class. You can easily identify them as their member names include a ChunkStreamerrUser prefix. You can 
            use these as a reference when creating custom ChunkStreamerUser classes.
            </para>
            <para>
            You should never have to interact directly with this component, as the methods/properties are called/used
            as needed by the Streamable Assets Manager.
            </para>
            </summary>
            <title>ChunkStreamer Abstract Class</title>
            <category>Chunk Streamers</category>
            <navigationName>ChunkStreamer</navigationName>
            <fileName>ChunkStreamer.html</fileName>
            <syntax>public abstract class ChunkStreamer : MonoBehaviour</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.IsSingleFrameAttachmentPreloadRequired">
            <summary>
            When overridden in derived class, gets a bool value indicating whether the derived class
            requires pre loading in order to execute the PerformSingleFrameAttachmentPreload method successfully.
            <para>If overridden to return true, then the 
            <see cref="M:DeepSpaceLabs.SAM.ChunkStreamer.PerformSingleFrameAttachmentPreload(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)" href = "#PerformSingleFrameAttachmentPreload">PerformSingleFrameAttachmentPreload</see> 
            method must also be overridden.</para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.CompatibleWithHiearchyOrganizer">
            <summary>
            Gets a value indicating whether the Chunk Streamer is compatible with Hiearchy Organizers.
            <para>
            By default it returns true, which should work for most Chunk Streamers.
            </para>
            <para>
            However, in cases where reassigning an Asset Chunks parent might be problematic (which is what 
            occurs with Hierarchy Organizers), you can override this property to return false.
            </para>
            <para>
            This property is queried when the World using a Hiearchy Organizer is initialized, if an LOD Group 
            using this Streamer has Hierarchy Organizers enabled (in the inspector). 
            If they are enabled and the LOD Group's Streamer returns false for this property, 
            the Hierarchy Organizer will be disabled for that LOD Group and an error will be printed to the console.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ExtraDataToPrependKey">
            <summary>
            Normally, the names used to load chunks are constructed using three or four components. The naming convention assigned to each LOD Group 
            (via Streamable Grid LODs), the Group Name associated with the LOD Group, the Streamable Grid Cell Index of the cell whose chunks/objects are being loaded, 
            and optionally the chunk index of the chunk being loaded (if multi chunking is being used). The output name is known as the Cell String, and is 
            generated using the CellString class.
            <para>
            In some cases, this is not enough to load the object. For instance, when loading prefabs from the Resources folder, and if the prefabs are located in a 
            sub folder, just using this generated name will not allow the prefabs to be loaded. You must also include the sub folder path in the name passed 
            to Resources.LoadAsync.
            </para>
            <para>
            In these situations, you may need to prepend some extra string data to each Cell String in order to generate a valid string that can be used to load 
            your chunks. Rather than have this data be constant per user (which would limit the streamer to being used by a limited number of users), instead it 
            is derived from each individual user by accessing either the Extra Data stored 
            globally on the Streamable Grid associated with the user, or in the LOD's (also on the Streamable Grid asset) Extra Data. This extra data is stored in a 
            dictionary and requires a key to access. This property returns the key that will be used by the streamer to look up the extra data to prepend.
            </para>
            <para>
            Note, it is possible to have some users need the prepended data and others to not need it. In this case, simply omit the extra data from the LOD or 
            Streamable Grid associated with the users that do not need to use the prepended data. When the streamer finds no data associated with the key, prepended 
            data is simply ignored for that user.
            </para>
            <para>
            Note, by default this property returns null, indicating that there is no extra data to prepend. Only override it you need to prepend some 
            extra data!
            </para>
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ExtraDataToAppendKey">
            <summary>
            Normally, the names used to load chunks are constructed using three or four components. The naming convention assigned to each user 
            (via Streamable Grid LODs), the Group Name associated with the user, the Streamable Grid Cell Index of the cell whose chunks/objects are being loaded, 
            and optionally the chunk index of the chunk being loaded (if multi chunking is being used). The output name is known as the Cell String, and is 
            generated using the CellString class.
            <para>
            In some cases, this is not enough to load the object. For instance, when loading Addressable Assets via one of the Addressable Asset Streamers, 
            if the address of your assets include the file extension (.prefab for prefabs or .asset for scenes), this file extension will need to be included 
            in the keys used to load the assets.
            </para>
            <para>
            In these situations, you have three options. Append extra data that is different for each Chunk Streamer user, append some data that is constant for all 
            users, or append both types of data (in which case the constant data will be appended after the extra data that is different for each user).
            </para>
            <para>
            This property returns the key used to access the extra data that is different for each Chunk Streamer user. 
            The extra data may be stored either in the Extra Data stored 
            globally on the Streamable Grid associated with the user, or in the LOD's (also on the Streamable Grid asset) Extra Data. If extra data is stored 
            in both places (matching the key), the extra data stored in the LOD takes priority.
            </para>
            <para>
            Note, it is possible to have some users need the appended data and others to not need it. In this case, simply omit the extra data from the LOD or 
            Streamable Grid associated with the users that do not need to use the appended data. When the streamer finds no data associated with the key, appended 
            data is simply ignored for that user. If you know that all users will use the same appended data, you may wish to override the 
            ConstantDataToAppend property isntead.
            </para>
            <para>
            By default this returns null, indicating there is no extra data to append. Only override the property if you need to append extra data!
            </para>
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ConstantDataToAppend">
            <summary>
            Normally, the names used to load chunks are constructed using three or four components. The naming convention assigned to each user 
            (via Streamable Grid LODs), the Group Name associated with the user, the Streamable Grid Cell Index of the cell whose chunks/objects are being loaded, 
            and optionally the chunk index of the chunk being loaded (if multi chunking is being used). The output name is known as the Cell String, and is 
            generated using the CellString class.
            <para>
            In some cases, this is not enough to load the object. For instance, when loading Addressable Assets via one of the Addressable Asset Streamers, 
            if the address of your assets include the file extension (.prefab for prefabs or .asset for scenes), this file extension will need to be included 
            in the keys used to load the assets.
            </para>
            <para>
            In these situations, you have three options. Append extra data that is different for each Chunk Streamer user, append some data that is constant for all 
            users, or append both types of data (in which case the constant data will be appended after the extra data that is different for each user).
            </para>
            <para>
            This property returns the constant data to append; by default it returns null, so if you want to return some other data, override it!
            </para>
            </summary>
            <type>string</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.LoadProgress">
            <summary>
            Tracks the progress of this Chunk Streamer's current LoadAndAttachChunksToCells method call as a value between 0 (nothing loading) and 1 (all chunks loaded). 
            When LoadAndAttachChunksToCells is called, you should set this value to 0f, gradually incrementing it 
            as you load a new chunk. At the methods end, it should be set to 1f. This is automatically done by the built in Chunk Streamer implementations, however 
            you will need to do this manually if creating a custom Chunk Streamer.
            <para>
            An easy way to calculate how much the progress should be incremented each time a new chunk is loaded is to divide 1f by the total number of chunks that need to be loaded 
            with the operation (1f / total chunks).
            </para>
            <para>
            This value is used internally by SAM to track loading progress when the Component Manager is gradually initialized. You can query the property yourself, however 
            it will only be valid when a load operation is in progress, which is difficult to know (though generally speaking, if the value is equal to 1f, a load operation is 
            not in progress).
            </para>
            </summary>
            <type>float</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.RegisteredUsers">
            <summary>
            The users registered with the Chunk Streamer.
            </summary>
            <type link = "RegistrationHandler.html">RegistrationHandler&lt;ChunkStreamerUser&gt; (protected)</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.UpdateDefaultMaxAsyncLoadOpsToStartInSingleFrame(System.Int32)">
            <summary>
            Updates the Default Max Async Load Ops To Start In Single Frame value used by this Chunk Streamer. Any Zone LOD Groups 
            that do not have Extra Data that overrides this value will immediately start using the new value.
            <para>
            Updating each Zone LOD Group to use the new value is not a free operation, so it recommended to call this method 
            sparingly.
            </para>
            </summary>
            <param name="newValue" type="int">
            The new value to use.
            </param>
            <displayName id="UpdateDefaultMaxAsyncLoadOpsToStartInSingleFrame">
            UpdateDefaultMaxAsyncLoadOpsToStartInSingleFrame(int)
            </displayName>
            <syntax>
            public void UpdateDefaultMaxAsyncLoadOpsToStartInSingleFrame(int newValue)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.UpdateDefaultMaxAsyncLoadOpsToCompleteInSingleFrame(System.Int32)">
            <summary>
            Updates the Default Max Async Load Ops To Complete In Single Frame value used by this Chunk Streamer. Any Zone LOD Groups 
            that do not have Extra Data that overrides this value will immediately start using the new value.
            <para>
            Updating each Zone LOD Group to use the new value is not a free operation, so it recommended to call this method 
            sparingly.
            </para>
            </summary>
            <param name="newValue" type="int">
            The new value to use.
            </param>
            <displayName id="UpdateDefaultMaxAsyncLoadOpsToCompleteInSingleFrame">
            UpdateDefaultMaxAsyncLoadOpsToCompleteInSingleFrame(int)
            </displayName>
            <syntax>
            public void UpdateDefaultMaxAsyncLoadOpsToCompleteInSingleFrame(int newValue)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.UpdateDefaultMaxAsyncUnloadOpsToStartInSingleFrame(System.Int32)">
            <summary>
            Updates the Default Max Async Unload Ops To Start In Single Frame value used by this Chunk Streamer. Any Zone LOD Groups 
            that do not have Extra Data that overrides this value will immediately start using the new value.
            <para>
            Updating each Zone LOD Group to use the new value is not a free operation, so it recommended to call this method 
            sparingly.
            </para>
            </summary>
            <param name="newValue" type="int">
            The new value to use.
            </param>
            <displayName id="UpdateDefaultMaxAsyncUnloadOpsToStartInSingleFrame">
            UpdateDefaultMaxAsyncUnloadOpsToStartInSingleFrame(int)
            </displayName>
            <syntax>
            public void UpdateDefaultMaxAsyncUnloadOpsToStartInSingleFrame(int newValue)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.UpdateDefaultMaxAsyncUnloadOpsToCompleteInSingleFrame(System.Int32)">
            <summary>
            Updates the Default Max Async Unload Ops To Complete In Single Frame value used by this Chunk Streamer. Any Zone LOD Groups 
            that do not have Extra Data that overrides this value will immediately start using the new value.
            <para>
            Updating each Zone LOD Group to use the new value is not a free operation, so it recommended to call this method 
            sparingly.
            </para>
            </summary>
            <param name="newValue" type="int">
            The new value to use.
            </param>
            <displayName id="UpdateDefaultMaxAsyncUnloadOpsToCompleteInSingleFrame">
            UpdateDefaultMaxAsyncUnloadOpsToCompleteInSingleFrame(int)
            </displayName>
            <syntax>
            public void UpdateDefaultMaxAsyncUnloadOpsToCompleteInSingleFrame(int newValue)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.Awake">
            <summary>
            Awake method for all Chunk Streamers. This method is where the background loading priority is 
            set, if the Global Runtime Settings asset is configured to set it.
            <para>
            If you need to implement Awake related logic in your custom Chunk Streamers, override the 
            AwakeExtended method.
            </para>
            </summary>
            <displayName id="Awake">
            Awake()
            </displayName>
            <syntax>
            protected void Awake()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.AwakeExtended">
            <summary>
            Override to implement Awake related logic in your custom Chunk Streamers.
            </summary>
            <displayName id="AwakeExtended">
            AwakeExtended()
            </displayName>
            <syntax>
            protected virtual void AwakeExtended()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.Register(DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32@)">
            <summary>
            A user can call this method to register with the Chunk Streamer. The userID must be stored by the user
            and passed in when calling the methods of the Chunk Streamer.
            </summary>
            <param name="zoneLODGroup" type="IZoneLODGroup" link="IZoneLODGroup.html">
            The Zone LOD Group being registered.
            </param>
            <param name="userID" type = "int">
            An ID that is assigned to the user when this method is called. Each user has its
            own ChunkStreamerUser object created for it.
            </param>
            <displayName id = "Register">Register(IZoneLODGroup, out int)</displayName>
            <syntax>public void Register(IZoneLODGroup zoneLODGroup, out int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.DeRegister(System.Int32)">
            <summary>
            A user can call this method to de register with the Chunk Streamer.
            </summary>
            <param name="userID" type = "int">The ID of the user to de register.</param>
            <displayName id = "DeRegister">DeRegister(int)</displayName>
            <syntax>public void DeRegister(int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Method used to create a new user object during user registration. This can and usually should 
            be overridden to return a custom user object. Each user represents a single Zone Grouping on a single World.
            </summary>
            <param name="zoneGrouping" type="IZoneGrouping" link="IZoneGrouping.html">The Zone Grouping being registered.</param>
            <displayName id = "CreateNewUser">CreateNewUser(IZoneGrouping)</displayName>
            <syntax>protected virtual ChunkStreamerUser CreateNewUser(IZoneGrouping zoneGrouping)</syntax>
            <returns type = "ChunkStreamerUser">A new user object created using the zoneGrouping as input.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.PerformSingleFrameAttachmentPreload(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            Certain types of load methods require a frame to pass before objects are added to the scene 
            (LoadLevelAdditive for example). In order to successfully execute the 
            LoadAndAttachChunksToCellsInSingleFrame method, 
            these load methods must "pre load" the objects in the frame before. 
            This method is used to do that, but should only be called by the registered user 
            when IsSingleFrameAttachmentPreloadRequired is true.
            <para>
            By default, this method does nothing, and you only need to provide your own implementation 
            if pre loading is required (in 
            which case, 
            <see cref="P:DeepSpaceLabs.SAM.ChunkStreamer.IsSingleFrameAttachmentPreloadRequired" href = "#IsSingleFrameAttachmentPreloadRequired">
            IsSingleFrameAttachmentPreloadRequired</see> 
            must also be overridden to return true.
            </para>
            <para>
            If you need to store some data about chunks in order to properly unload them later using DetachAndUnloadChunksFromCells, you should use a 
            key related to the underlying chunk objects themselves rather than the World Cell. This is because the chunks may be passed between 
            World Cells (if using Chunk Reuse or Pooling), so the World Cell the chunks were originally loaded for may not be the World Cells 
            they are attached to when DetachAndUnloadChunksFromCells is called.
            </para>
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose objects need to be pre loaded.</param>
            <param name="userID" type = "int">The ID of the user requesting the pre load.</param>
            <displayName id = "PerformSingleFrameAttachmentPreload">
            PerformSingleFrameAttachmentPreload(List&lt;WorldCell&gt;, int)
            </displayName>
            <syntax>
            public virtual void PerformSingleFrameAttachmentPreload(List&lt;WorldCell&gt; cells, int userID)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.LoadAndAttachChunksToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            When overridden in a derived class, loads and attaches the chunks associated with the input cells to the cells in a single frame.
            <para>
            If you need to store some data about chunks in order to properly unload them later using DetachAndUnloadChunksFromCells, you should use a 
            key related to the underlying chunk objects themselves rather than the World Cell. This is because the chunks may be passed between 
            World Cells (if using Chunk Reuse or Pooling), so the World Cell the chunks were originally loaded for may not be the World Cells 
            they are attached to when DetachAndUnloadChunksFromCells is called.
            </para>
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose chunks need to be attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the attachment.</param>
            <displayName id = "LoadAndAttachChunksToCellsInSingleFrame">LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public abstract void LoadAndAttachChunksToCellsInSingleFrame(List&lt;WorldCell&gt; cells, int userID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.LoadAndAttachChunksToCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            When overridden in a derived class, loads and attaches the chunks associated with the input 
            cells to the cells over a period of frames.
            <para>
            If you need to store some data about chunks in order to properly unload them later using DetachAndUnloadChunksFromCells, you should use a 
            key related to the underlying chunk objects themselves rather than the World Cell. This is because the chunks may be passed between 
            World Cells (if using Chunk Reuse or Pooling), so the World Cell the chunks were originally loaded for may not be the World Cells 
            they are attached to when DetachAndUnloadChunksFromCells is called.
            </para>
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose chunks need to be loaded and attached.</param>
            <param name="userID" type = "int">The ID of the user requesting the load and attachment.</param>
            <displayName id = "LoadAndAttachChunksToCells">LoadAndAttachChunksToCells(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; LoadAndAttachChunksToCells(List&lt;WorldCell&gt; cells, int userID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.DetachAndUnloadChunksFromCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},System.Int32)">
            <summary>
            When overridden in a derived class, detaches and unloads the objects associated with the input cells over a period of frames.
            <para>
            Please note that the list of World Cells passed in may need to be used by the calling method after this method finishes executing; as such, 
            you should not remove World Cells or otherwise manipulate the list, as that will result in errors.
            </para>
            <para>
            Also note that in some instances, the Chunk Set on the World Cell may have been re-used/taken from another World Cell, so if you need to access some data 
            related to the chunk set, it is better to use an identifier from the underlying objects in the chunk set rather than data from the World Cell. This is 
            especially true because the Endless Grid Cell value on the World Cell may not be accurate, therefore you should never use it as a key to store data.
            </para>
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">The cells whose chunks need to be detached and unloaded.</param>
            <param name="userID" type = "int">The ID of the user requesting the unload and detachment.</param>
            <displayName id = "DetachAndUnloadChunksFromCells">DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt;, int)</displayName>
            <syntax>public abstract IEnumerator&lt;YieldInstruction&gt; DetachAndUnloadChunksFromCells(List&lt;WorldCell&gt; cells, int userID)</syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser">
            <summary>
            Stores data related to each user of the Chunk Streamer. You can use this class in a custom Chunk Streamer, or derive a new class from it (if you 
            do this, you need to override the CreateNewUser method to return an instance your new class!).
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.ChunkStreamer">
            <summary>
            The ChunkStreamer that created the user object. Think of it as the parent of the object.
            </summary>
            <type link="ChunkStreamer.html">ChunkStreamer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.CellString">
            <summary>
            A Cell String object created via the CreateCellString method.
            </summary>
            <type link="CellString.html">CellString</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.ZoneGrouping">
            <summary>
            The IZoneGrouping passed in by the user. This contains useful information related to the user.
            </summary>
            <type link="IZoneGrouping.html">IZoneGrouping</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.UserScene">
            <summary>
            The scene associated with the user. If the user's World makes use of a Hierarchy Organizer, this will be the scene 
            that the Organizer is in, otherwise it will be the scene that the World component is in. Keep in mind that in most 
            instances, both the Organizer and World will be in the same scene.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.MaxAsyncLoadOpsToStartInSingleFrame">
            <summary>
            The Max Async Load Ops To Start In A Single Frame. If the LOD Group has Extra Data available corresponding to this, that data will have been 
            used to set this value. If not, this will be set to Default Max Async Load Ops To Start In Single Frame
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.MaxAsyncLoadOpsToCompleteInSingleFrame">
            <summary>
            The Max Async Load Ops To Start In A Single Frame. If the LOD Group has Extra Data available corresponding to this, that data will have been 
            used to set this value. If not, this will be set to Default Max Async Load Ops To Start In Single Frame
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.MaxAsyncUnloadOpsToStartInSingleFrame">
            <summary>
            The Max Async Unload Ops To Start In A Single Frame. If the LOD Group has Extra Data available corresponding to this, that data will have been 
            used to set this value. If not, this will be set to Default Max Async Unload Ops To Start In Single Frame
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.MaxAsyncUnloadOpsToCompleteInSingleFrame">
            <summary>
            The Max Async Unload Ops To Start In A Single Frame. If the LOD Group has Extra Data available corresponding to this, that data will have been 
            used to set this value. If not, this will be set to Default Max Async Unload Ops To Start In Single Frame
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.#ctor(DeepSpaceLabs.SAM.ChunkStreamer,DeepSpaceLabs.SAM.IZoneLODGroup)">
            <summary>
            Creates a new instance of the Chunk Streamer User object. If you are overriding the ChunkStreamer class and 
            not overriding the ChunkStreamerUser, you can create a new instance of this user object via this 
            constructor, which can be returned in the ChunkStreamer's CreateNewUser method.
            <para>
            If you are overriding ChunkStreamerUser, your custom user class will need constructors with at least these parameters 
            (but can also have more), and they must also call the base constructor, which is accomplished by placing 
            : (streamer, zoneGrouping) after your constructor declaration.
            </para>
            <para>
            Note, this constructor can only be used from a class deriving from ChunkStreamer or ChunkStreamerUser.
            </para>
            </summary>
            <param name="zoneLODGroup" type="IZoneLODGroup" link="IZoneLODGroup.html">The Zone LOD Group associated with the user.</param>
            <param name="streamer" type="ChunkStreamer" link="ChunkStreamer.html">
            The Chunk Streamer that created the instance of the ChunkStreamerUser.
            </param>
            <displayName>
            ChunkStreamerUser.ChunkStreamerUser(ChunkStreamer, IZoneLODGroup)
            </displayName>
            <syntax>
            public ChunkStreamerUser(ChunkStreamer streamer, IZoneLODGroup zoneLODGroup)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.OnMaxAsyncLoadOpsToStartInSingleFrameChanged">
            <summary>
            Can be overriden in a derived class to receive notification when the value of 
            MaxAsyncLoadOpsToStartInSingleFrame for the user changes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.OnMaxAsyncLoadOpsToCompleteInSingleFrameChanged">
            <summary>
            Can be overriden in a derived class to receive notification when the value of 
            tMaxAsyncUnloadOpsToStartInSingle for the user changes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.OnMaxAsyncUnloadOpsToStartInSingleFrameChanged">
            <summary>
            Can be overriden in a derived class to receive notification when the value of 
            MaxAsyncUnloadOpsToStartInSingleFrame for the user changes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.OnMaxAsyncUnloadOpsToCompleteInSingleFrameChanged">
            <summary>
            Can be overriden in a derived class to receive notification when the value of 
            MaxAsyncUnloadOpsToCompleteInSingleFrame for the user changes.
            </summary>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ChunkStreamer.ChunkStreamerUser.CreateCellString(DeepSpaceLabs.SAM.IZoneLODGroup,System.String,System.String)">
            <summary>
            The method used to create the CellString object. By default it uses the Group Name from the IZoneGrouping objet, as well as the Naming Convention, 
            UtilizesCellChunking, and StreamableGrid.IsStreamableGrid3D fields from the GridLODDetails property of the IZoneGrouping object. You can override to 
            use different information, however do so with extreme caution only if you know what you are doing. The IZoneGrouping object passed in is the 
            one passed to the ChunkStreamerUser constructor. To use a different group, call this method manually and pass in a different group, 
            then use the returned CellString rather than the one from the CellString property.
            </summary>
            <param name="zoneGrouping" type="IZoneGrouping" link="IZoneGrouping.html">The Zone Grouping to use to create the Cell String object.</param>
            <param name="extraDataToPrepend" type="string">
            Extra data to prepend to the strings generated with the Cell String. Pass this into your CellString object, and don't worry about 
            whether it is null or blank, as those cases are handled automatically by the CellString.
            </param>
            <param name="extraDataToAppend" type="string">
            Extra data to append to the strings generated with the Cell String. Pass this into your CellString object, and don't worry about 
            whether it is null or blank, as those cases are handled automatically by the CellString.
            </param>
            <returns type="CellString" link="CellString.html">A Cell String object</returns>
            <displayName>ChunkStreamerUser.CreateCellString(IZoneGrouping, string, string)</displayName>
            <syntax>protected virtual CellString CreateCellString(IZoneGrouping zoneGrouping, string extraDataToPrepend, string extraDataToAppend)</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PlayerPrefsPersistentDataController">
            <summary>
            [Deprecated] - Saving state via a Persistent Data Controller is no longer possible. Please use the new IPersistentStateManager 
            interface instead. If you have old data saved with the player prefs persistent data controller that you absolutely need to make use of, you can 
            convert the data using the <see cref="M:DeepSpaceLabs.SAM.ComponentManager.ConvertOldSaveData(DeepSpaceLabs.SAM.PersistentDataController,DeepSpaceLabs.SAM.IPersistentStateManager,System.Collections.Generic.List{System.String},System.Collections.Generic.List{DeepSpaceLabs.SAM.OldActiveGridData})" href="ComponentManager.html#ConvertOldSaveData1">ComponentManager.ConvertOldSaveData</see> method. To do so, you will need to upgrade your Player Prefs Persistent Data Controllers (see Upgrade 
            Chapter in SAM Editor Guide for more information).
            <para>
            Provides an implementation for a Persistent Data Controller that uses Unity's built in 
            <see href="http://docs.unity3d.com/ScriptReference/PlayerPrefs.html">Player Prefs</see> to save and load
            persistent data between game sessions.
            </para>
            </summary>
            <title>PlayerPrefsPersistentDataController Class</title>
            <category>Deprecated Components</category>
            <navigationName>PlayerPrefsPersistentDataController</navigationName>
            <fileName>PlayerPrefsPersistentDataController.html</fileName>
            <syntax>public sealed class PlayerPrefsPersistentDataController : <see href = "PersistentDataController.html">PersistentDataController</see></syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PlayerPrefsPersistentDataController.SaveData(System.String,System.String)">
            <summary>
            Saves the specified data using the specified key in Player Prefs.
            </summary>
            <param name="key" type="string">The key used to save the persistent data.</param>
            <param name="data" type="string">The persistent data that will be saved.</param>
            <displayName id="SaveData">SaveData(string, string)</displayName>
            <syntax>public sealed override void SaveData(string key, string data)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PlayerPrefsPersistentDataController.TryGetData(System.String,System.String@)">
            <summary>
            Attempts to get the persistent data associated with the specified key from Player Prefs.
            </summary>
            <param name="key" type="string">The key used to try and retrieve the persistent data.</param>
            <param name="data" type="string">A string which will contain the data if successfully retrieved.</param>
            <returns type="bool">A value indicating whether the data was successfully retrieved. If false, "data" will be null.</returns>
            <displayName id="TryGetData">TryGetData(string, out string)</displayName>
            <syntax>public sealed override bool TryGetData(string key, out string data)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PlayerPrefsPersistentDataController.TryDeleteData(System.String)">
            <summary>
            Attempts to to delete the persistent data associated with the specified key from Player Prefs.
            </summary>
            <param name="key" type="string">The key used to identify the persistent data that should be deleted.</param>
            <returns type ="bool">A value indicating whether the persistent data was successfully deleted.</returns>
            <displayName id="TryDeleteData">TryDeleteData(string)</displayName>
            <syntax>public sealed override bool TryDeleteData(string key)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PlayerPrefsPersistentDataController.DoesDataExist(System.String)">
            <summary>
            Gets a value indicating whether data exist in PlayerPrefs for the given key.
            </summary>
            <param name="key" type="string">
            The key used to store the data.
            </param>
            <returns type="bool">
            True if data exist, false otherwise.
            </returns>
            <displayName id="DoesDataExist">
            DoesDataExist(string)
            </displayName>
            <syntax>
            public sealed override bool DoesDataExist(string key)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.BoundaryMonitor">
            <summary>
            A component which actively monitors boundaries.
            <para>
            This component is not meant to be used outside of the Streamable Assets Manager, and as such
            many of its members are hidden. Look at the source code provided with the kit if you wish to create
            your own boundary monitor based on this one for non SAM stuff.
            </para>
            <para>
            The boundary monitor can have multiple users, each using different boundaries and detection frequencies. Therefore, you should 
            only ever need one Boundary Monitor in a scene.
            </para>
            </summary>
            <title>BoundaryMonitor Class</title>
            <category>Secondary Components</category>
            <navigationName>BoundaryMonitor</navigationName>
            <fileName>BoundaryMonitor.html</fileName>
            <syntax>public sealed class BoundaryMonitor : MonoBehaviour</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.BoundaryMonitor.UpdateDefaultDetectionFrequency(System.Single)">
            <summary>
            Updates the default frequency at which this Boundary Monitor checks for boundary crosses. Any Active Grid 
            Layers utilizing the default frequency will be updated to reflect this new frequency.
            </summary>
            <displayName id = "UpdateDetectionFrequency">UpdateDetectionFrequency(float)</displayName>
            <syntax>public void UpdateDetectionFrequency(float newDetectionFrequency)</syntax>
            <param name="newDetectionFrequency" type = "float">The new frequency, in seconds.</param>
        </member>
        <member name="T:DeepSpaceLabs.SAM.StreamableGrid">
            <summary>
            Each Streamable Grid represents a collection of Stremable Cells, and more importantly, the 
            Streamable Asset Chunks associated with those Cells. 
            It stores vital information about the Cells, such as their dimensions and whether each Cell 
            has Asset Chunks associated with it (and if they do, how many Asset Chunks are used by it), 
            and vital information about those Chunks, such as the shared name of all Asset Chunks in the 
            group and their level of detail.
            <para>
            You can think of a Streamable Grid as a blueprint for building 
            <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World's</see> at runtime (Worlds combines multiple Streamable Grid's 
            and actual scene positional space to form a physical game world).
            </para>
            <para>
            To create a Streamable Grid asset, right click the folder where you'd like to create it and choose 
            "Create -> Deep Space Labs -> SAM -> Streamable Grid".
            </para>
            <para>
            All of the public methods that take in or return a <see cref="T:DeepSpaceLabs.SAM.Cell" href="Cell.html">Cell</see> 
            are 1 based. This means the first 
            Cell on the Streamable Grid has a row of 1, column of 1, and (for 3D worlds) a layer of 1.
            </para>
            <para>
            If you see PreInitSafe in the name of one of the methods or properties below, it means that the 
            method or property can be called before the Streamable Grid has been initialized (at runtime or 
            in editor code). Methods or properties without PreInitSafe should only be called after the 
            Streamable Grid has been intialized (which only happens when the game is run).
            </para>
            </summary>
            <title>StreamableGrid Class</title>
            <category>Scriptable Assets</category>
            <navigationName>StreamableGrid</navigationName>
            <fileName>StreamableGrid.html</fileName>
            <syntax>public sealed class StreamableGrid : <see href="http://docs.unity3d.com/ScriptReference/ScriptableObject.html">ScriptableObject</see></syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.RowLengthsNative">
            <summary>
            Gets the row lengths of the Streamable Grid as a native array. The lengths are only configured once the Streamable Grid 
            has been initialized. The lifetime of this array is handled by the Streamable Grid, so you should never dispose it yourself. You 
            should also treat it as a read only array and not reassign values to any of its indexes, otherwise you will 
            screw things up royally since SAM uses these arrays internally. Finally, note that the length of the array will be 1 
            if all rows are of equal size (in an attempt to save space).
            </summary>
            <type>NativeArray&lt;double&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.ColumnWidthsNative">
            <summary>
            Gets the column widths of the Streamable Grid as a native array. The widths are only configured once the Streamable Grid 
            has been initialized. The lifetime of this array is handled by the Streamable Grid, so you should never dispose it yourself. You 
            should also treat it as a read only array and not reassign values to any of its indexes, otherwise you will 
            screw things up royally since SAM uses these arrays internally. Finally, note that the length of the array will be 1 
            if all columns are of equal size (in an attempt to save space).
            </summary>
            <type>NativeArray&lt;double&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.LayerHeightsNative">
            <summary>
            Gets the layer heights of the Streamable Grid as a native array. The heights are only configured once the Streamable Grid 
            has been initialized. The lifetime of this array is handled by the Streamable Grid, so you should never dispose it yourself. You 
            should also treat it as a read only array and not reassign values to any of its indexes, otherwise you will 
            screw things up royally since SAM uses these arrays internally. Finally, note that the length of the array will be 1 
            if all layers are of equal size (in an attempt to save space), or if the Streamable Grid is 2D.
            </summary>
            <type>NativeArray&lt;double&gt;</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.Register">
            <summary>
            Registers with the Streamable Grid. This initializes the Grid if no other users have already registered with it, and must be 
            used if you wish to access members that are only available after the Grid has been initialized, such as the native arrays.
            <para>
            Note that SAM automatically calls this method when the Streamable Grid is used with any World (even if it's just a prototype), so the 
            chances of you needing to call it yourself are slim. The only time that might not be true is if you are using the Streamable Grid 
            for some custom purpose, and it is not being used with any Worlds in the scene.
            </para>
            <para>
            For each call to Register, you must call DeRegister! This method should also not be called in the editor outside of Play Mode!
            </para>
            </summary>
            <displayName id="Register">
            Register()
            </displayName>
            <syntax>
            public void Register()
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Columns_PreInitSafe">
            <summary>
            Gets the number of columns on the Streamable Grid.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.IsCellDisabled">
            <summary>
            Gets (post initialization only)/Sets (PreInitSafe) a function that can be used to determine if a particular cell on the Streamable Grid is disabled.
            <para>
            When no function is manually assigned, at initialization the function is configured to return a value based on how the cell states are configured 
            in the Unity Editor (via the visual grid or World Designer tool), however for very large worlds or especially for procedural worlds, the information about 
            which cells are disabled can either be too large or may even be unconfigurable (for instance, the information 
            for procedural worlds might only be known at runtime!).
            </para>
            <para>
            In these situations, you can assign a custom function. When doing so, it is recommended to either enable or disable all 
            cells on your Streamable Grid (in the insepctor or via the World Designer Tool) to save on memory, 
            unless you plan on setting this property to null in the future (which 
            will cause the Grid to revert back to the editor configured enabled/disabled settings, so you'll want them to remain accurate).
            </para>
            <para>
            Setting this property before the Streamable Grid is initialized is allowed, however you cannot use the function to try and determine if a cell is 
            disabled until after the Grid is intialized (i.e., you should not get the property until after initialization), unless of course you have set it to a 
            custom function already.
            </para>
            <para>
            If you need to find out whether a cell is disabled before the Grid is initialized (such as in editor code), use the 
            <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.IsCellDisabled_PreInitSafe(DeepSpaceLabs.SAM.Cell)" href="#IsCellDisabled_PreInitSafe">IsCellDisabled_PreInitSafe</see> method instead.
            </para>
            <para>
            However, if you know that the Grid has been initialized, you should use this property/function as it will be faster.
            </para>
            </summary>
            <type>Func&lt;Cell, bool&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.IsInitialized">
            <summary>
            Gets a value indicating if the Streamable Grid is initialized. It should go without saying, but this property can be accessed 
            before the Grid has been intialized (in which case it will return false).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.LevelsOfDetail_PreInitSafe">
            <summary>
            Gets the number of LOD Groups on the Streamable Grid (effectively the levels of detail the Grid makes use of).
            <para>
            Remember that just because a Grid has an LOD Group, it does not mean that the LOD Group will be used. You still need an Active Grid 
            with a Loading Blueprint that makes use of the LOD Group, a World Region that contains Cells associated with the LOD Group, or a script 
            that adds users for Cells associated with the LOD Group.
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Rows_PreInitSafe">
            <summary>
            Gets the number of rows on the Streamable Grid.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Axes_PreInitSafe">
            <summary>
            Gets the Axes used by the Streamable Grid
            </summary>
            <type link="Axes.html">Axes</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.CellEqualityComparer">
            <summary>
            Gets an <see cref="T:DeepSpaceLabs.SAM.Cell" href="Cell.html">Cell</see> equality comparer matching the type of Streamable Grid (2D or 3D).
            <para>
            This can be used with dictionaries and other classes that utilaize Equality Comparers.
            </para>
            </summary>
            <type>EqualityComparer&lt;Cell&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.GridDimensions">
            <summary>
            Gets the dimensions of the Streamable Grid expressed as a Vector3Double. This can be useful in math operations. The components 
            of the vector are automatically set correctly according to the Axes of the Grid.
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.EnabledCells">
            <summary>
            Gets the total number of enabled cells on this Streamable Grid.
            </summary>
            <type>long</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Height">
            <summary>
            Gets the height of the Streamable Grid, which is the distance between the beginning of the first layer and end of the last layer.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Layers">
            <summary>
            Gets the number of layers on the Streamable Grid. Will be 1 if the Axes is not Three Dimensional.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Length">
            <summary>
            Gets the length of the Streamable Grid, which is the distance between the 
            beginning of the first row and end of the last row.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.IsGrid3D">
            <summary>
            Gets a value indicating whether the Streamable Grid is 3D (Axes Type set to Three Dimensional).
            <para>
            If you need this info befor ethe Grid is intialized, use the 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.Axes_PreInitSafe" href="#Axes_PreInitSafe">Axes_PreInitSafe</see> property and check 
            if it's set to <see cref="F:DeepSpaceLabs.SAM.Axes.Three_Dimensional" href="Axes.html">Three_Dimensional</see>
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.ToOneBasedCell">
            <summary>
            Gets a function that can be used to convert a cell in zero based format to a cell in one based format. This method is especially 
            useful for processing large amounts of cells, as it will disregard the layer value if the Streamable Grid is not 3D (will always be 
            1 on the returned Cell).
            </summary>
            <type>Func&lt;Cell, Cell&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.ToZeroBasedCell">
            <summary>
            Gets a function that can be used to convert a cell in one based format to a cell in zero based format. This method is especially 
            useful for processing large amounts of cells, as it will disregard the layer value if the Streamable Grid is not 3D (will always be 
            0 on the returned Cell).
            </summary>
            <type>Func&lt;Cell, Cell&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.GetRowLengthFunction">
            <summary>
            Gets a function that can be used to get the length of a particular row (the input) on this Streamable Grid. Configured after the Streamable Grid is initialized.
            </summary>
            <type>Func&lt;int, double&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.GetColumnWidthFunction">
            <summary>
            Gets a function that can be used to get the width of a particular column (the input) on this Streamable Grid. Configured after the Streamable Grid is initialized.
            </summary>
            <type>Func&lt;int, double&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.GetLayerHeightFunction">
            <summary>
            Gets a function that can be used to get the height of a particular layer (the input) on this Streamable Grid. Configured after the Streamable Grid is initialized.
            </summary>
            <type>Func&lt;int, double&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Width">
            <summary>
            Gets the width of the Streamable Grid, which is the distance between the beginning of the first column and end of the last column.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndex">
            <summary>
            A function that can be retrieved and used to flatten a Streamable Grid Cell Index.
            <para>
            Flattening treats the Streamable Grid as if it were a 
            2D or 3D multidimensional array, and then converts a Streamable Grid Cell index to a 0 based index that can be used 
            in a 1D array.
            </para>
            <para>
            Note that the input Streamable Grid Cell index should be 1 based, so that the first row is Row = 1, first 
            column is Column = 1, and first layer is Layer = 1. In this scenario, the index would be flattend to 0.
            </para>
            <para>
            You can use this index in a 1D array to store per Streamable Grid Cell data, however if you have a very large world with a large number 
            of disabled cells, you would be better off using a sparse array that only stores data for enabled cells. You can use 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndexForSparseEnabledArray" href="StreamableGrid.html#FlattenCellIndexForSparseEnabledArray">FlattenCellIndexForSparseEnabledArray</see> 
            for that purpose instead of this method (alternatively, you could also use a dictionary that uses the non flattened Streamable Grid Cell Index 
            as key).
            </para>
            <para>
            Note that the returned value is a long, however if it exceeds the max value of an int, the returned value will not be 
            suitable to be used as an array index.
            </para>
            </summary>
            <type>Func&lt;Cell, long&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndex_ZeroBased">
            <summary>
            Works just like 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndex" href="#FlattenCellIndex">FlattenCellIndex</see>, 
            except the input Streamable Grid Cell should be zero based.
            <para>
            This means the first row on the Streamable Grid is Row = 0, first 
            column is Column = 0, and first layer is Layer = 0.
            </para>
            </summary>
            <type>Func&lt;Cell, long&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndexForSparseEnabledArray">
            <summary>
            A function that can be retrieved and used to flatten the Cell Index of an Enabled Cell on the Streamable Grid, where the input Cell is 
            one based.
            <para>
            Flattening treats the Streamable Grid as if it were a 
            2D or 3D multidimensional array, and then converts the enabled Streamable Grid Cell index to a 0 based index that can be used 
            in a 1D array.
            </para>
            <para>
            The difference between this function and 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndex" href="#FlattenCellIndex">FlattenCellIndex</see> 
            is that this function takes into account the 
            enabled/disabled cell state of all cells, allowing it to be used with a sparse array 
            which stores data only for enabled cells. However, you must ensure that the cell is enabled before using it, as errors 
            will arise if it is not!
            </para>
            <para>
            Example: Say you have a 2 x 2 2D Streamable Grid with 3 enabled cells and 1 disabled cell (at Row = 2, Column = 1, or index 2 in a 1D array).
            </para>
            <para>
            A normal array storing data for all cells would look like this: [1-1, 1-2, 2-1, 2-2], where 2-1 is the disabled cell. If you wanted to 
            find the index of cell 2-2 within this array, you would use FlattenCellIndex(new Cell(2,2)), which would return a value of 3.
            </para>
            <para>
            A sparse array storing data only for enabled cells would look like this: [1-1, 1-2, 2-2]. As you can see, the data for cell 1-1 and 1-2 are 
            still in the correct position, however data for 2-2 is now at index 2 rather than 3,  because cell 2-1 has been removed from the array. In order 
            to retrieve the correct index of 2, you would need to use FlattenEnabledCellIndex_SparseEnabledArray(new Cell(2,2)).
            </para>
            <para>
            Do note that this function is more expensive to use than FlattenCellIndex, so you should be cautious about using it alot in a single frame (however, 
            profile to find out whether it's truly an issue!)
            </para>
            <para>
            Because the value is intended to be used as an index into an array, it is an int. If the number of enabled cells exceeds 
            2,147,483,647 issues will arise!
            </para>
            <para>
            Note that the input Streamable Grid Cell index should be 1 based, so that the first row on the Streamable Grid is Row = 1, first 
            column is Column = 1, and first layer is Layer = 1.
            </para>
            </summary>
            <type>Func&lt;Cell, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenEnabledCellIndexForSparseEnabledArray_ZeroBased">
            <summary>
            Works just like 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndexForSparseEnabledArray" href="#FlattenCellIndexForSparseEnabledArray">FlattenCellIndexForSparseEnabledArray</see>, 
            except the input Streamable Grid Cell should be zero based.
            <para>
            This means the first row on the Streamable Grid is Row = 0, first 
            column is Column = 0, and first layer is Layer = 0.
            </para>
            </summary>
            <type>Func&lt;Cell, int&gt;</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.RowsAsLong">
            <summary>
            Gets the number of rows on the Streamable Grid as a long.
            </summary>
            <type>long</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.ColumnsAsLong">
            <summary>
            Gets the number of columns on the Streamable Grid as a long.
            </summary>
            <type>long</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.LayersAsLong">
            <summary>
            Gets the number of layers on the Streamable Grid as a long.
            </summary>
            <type>long</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.StreamableGrid.Indices">
            <summary>
            Gets the number of Rows, Columns, and Layers expressed as a Cell structure.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetLODDetails_PreInitSafe(System.Int32)">
            <summary>
            Returns the grid LOD details for the given LOD. All LOD Group specific data can be retrieved from the GridLODDetails object.
            </summary>
            <param name="LOD" type="int">
            The LOD.
            </param>
            <returns type="GridLODDetails" link="GridLODDetails.html">
            The grid LOD details for the LOD.
            </returns>
            <displayName id="GetLODDetails_PreInitSafe">
            GetLODDetails_PreInitSafe(int)
            </displayName>
            <syntax>
            public GridLODDetails GetLODDetails_PreInitSafe(int LOD)
            </syntax>
            <exception cref="T:System.NullReferenceException">
            thrown if the LOD is less than 1 or greater than the number of levels of detail on this Streamable Grid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.StreamableGridCells_PreInitSafe">
            <summary>
            Gets an enumerable collection of the cells on this Streamable Grid. This can be used in a foreach statement to iterate over 
            every cell in the grid in a garbage free manner, and automatically takes into account whether the grid is 2D or 3D.
            <para>
            This is very useful in situations where 
            you need to perform some operation that uses a Cell struct, for each cell on the Streamable Grid. Note that the enumerable does not take into account 
            disabled cell locations, which may or may not be a problem.
            </para>
            <para>
            If you have a very large world with many disabled cells, you should consider using the 
            <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.EnabledStreamableGridCells" href="StreamableGrid.html#EnabledStreamableGridCells_PreInitSafe">EnabledStreamableGridCells_PreInitSafe</see> method instead.
            </para>
            </summary>
            <returns type="StreamableGridEnumerable">
            The enumerable collection of Streamable Grid Cells
            </returns>
            <example>
            <code>
            class IterateOverStreamableGridCellsExample
            {
                StreamableGrid streamableGrid;
                
                public void Iterate()
                {
                    foreach(Cell cell in streamableGrid.StreamableGridCells_PreInitSafe())
                        DoSomething(cell);
                }
            }
            </code>
            </example>
            <displayName id="StreamableGridCells_PreInitSafe">
            StreamableGridCells_PreInitSafe()
            </displayName>
            <syntax>
            public StreamableGridEnumerable StreamableGridCells_PreInitSafe()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.EnabledStreamableGridCells">
            <summary>
            Gets an enumerable collection of the enabled cells on this Streamable Grid. This can be used in a foreach statement to iterate over 
            only enabled cells in the grid in a garbage free manner, and automatically takes into account whether the grid is 2D or 3D. This is very useful in situations where 
            you need to perform some operation that uses a Cell struct, for each enabled cell on the Streamable Grid. If you have a very large world with a ton of cells where 
            most are disabled, it can make more sense to use this rather than iterating over every cell on the Streamable Grid via 
            <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.StreamableGridCells_PreInitSafe" href="StreamableGrid.html#StreamableGridCells_PreInitSafe">StreamableGridCells_PreInitSafe</see>.
            <para>
            Also note that in some cases, it may be beneficial to iterate over the flattened index of each enabled cell rather than the index in 
            <see cref="T:DeepSpaceLabs.SAM.Cell" href="Cell.html">Cell</see> form, for example if you want to retrieve the number of chunks used by a cell, you can use 
            the flattened index rather than the Cell with the 
            <see cref="M:DeepSpaceLabs.SAM.GridLODDetails.GetCellChunksUsingArrayIndex(System.Int64)" href="GridLODDetails.html#GetCellChunksUsingArrayIndex">GetCellChunksUsingArrayIndex</see> 
            method, which is more efficient. To iterate over the flattened indexes of enabled cells, 
            use <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.FlattenedIndexesOfEnabledCells" href="StreamableGrid.html#FlattenedIndexesOfEnabledCells">FlattenedIndexesOfEnabledCells</see>.
            </para>
            <para>
            Finally, take heed that this method can only be used after the Streamable Grid has been initialized. If you need to a method that will work 
            before the Grid is intialized, for example outside of Play Mode in the editor, use <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.EnabledStreamableGridCells_PreInitSafe" href="#EnabledStreamableGridCells_PreInitSafe">EnabledStreamableGridCells_PreInitSafe</see> instead.
            </para>
            </summary>
            <returns type="EnabledStreamableGridEnumerable">
            The enumerable collection of enabled Streamable Grid Cells.
            </returns>
            <example>
            <code>
            class IterateOverEnabledStreamableGridCellsExample
            {
                StreamableGrid streamableGrid;
                
                public void Iterate()
                {
                    foreach(Cell enabledCell in streamableGrid.EnabledStreamableGridCells())
                        DoSomething(enabledCell);
                }
            }
            </code>
            </example>
            <displayName id="EnabledStreamableGridCells">
            EnabledStreamableGridCells()
            </displayName>
            <syntax>
            public EnabledStreamableGridEnumerable EnabledStreamableGridCells()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.EnabledStreamableGridCells_PreInitSafe">
            <summary>
            Same as <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.EnabledStreamableGridCells" href="#EnabledStreamableGridCells">EnabledStreamableGridCells</see>, except this method can be 
            used even if the Streamable Grid has not be initialized, for example in the editor outside of Play Mode.
            </summary>
            <returns type="EnabledCellsEnumerable_PreInitSafe">
            The enumerable collection of enabled Streamable Grid Cells.
            </returns>
            <example>
            <code>
            class IterateOverEnabledStreamableGridCellsExample
            {
                StreamableGrid streamableGrid;
                
                public void Iterate()
                {
                    foreach(Cell enabledCell in streamableGrid.EnabledStreamableGridCells_PreInitSafe())
                        DoSomething(enabledCell);
                }
            }
            </code>
            </example>
            <displayName id="EnabledStreamableGridCells_PreInitSafe">
            EnabledStreamableGridCells_PreInitSafe()
            </displayName>
            <syntax>
            public EnabledCellsEnumerable_PreInitSafe EnabledStreamableGridCells_PreInitSafe()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.FlattenedIndexesOfEnabledCells">
            <summary>
            Gets an enumerable collection of the flattened indexes of enabled cells on this Streamable Grid. This can be used in a foreach statement to iterate over 
            only the enabled cells in the grid in a garbage free manner, and automatically takes into account whether the grid is 2D or 3D. 
            This is very useful in situations where you need to perform some operation that uses the Flattened Index of each enabled cell on the Streamable Grid.
            <para>
            If you have a very large world with a ton of cells where 
            most are disabled, it can make more sense to use this rather than iterating over every cell and checking whether each one is enabled or disabled.
            </para>
            <para>
            For each enabled cell, the flattened index is equivalent to the value returned by the 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndex" href="StreamableGrid.html#FlattenCellIndex">FlattenCellIndex</see> function for that cell (not the 
            <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.FlattenCellIndexForSparseEnabledArray" href="StreamableGrid.html#FlattenEnabledCellIndex">FlattenEnabledCellIndex</see> function!).
            </para>
            <para>
            The number of items in the collection will always be equal to <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.EnabledCells" href="StreamableGrid.html#EnabledCells">EnabledCells</see>. If you need 
            to iterate over this collection repeatedly over different frames, it may make sense to store the values in an array, using EnabledCells as the 
            length of the array.
            </para>
            </summary>
            <returns type="FlattenedEnabledStreamableGridIndexesEnumerable">
            The enumerable collection of the flattened indexes of Streamable Grid Cells that are enabled.
            </returns>
            <example>
            <code>
            class IterateOverFlattenedIndexesOfEnabledCellsExample
            {
                StreamableGrid streamableGrid;
                
                public void Iterate()
                {
                    Data[] enabledCellData = new Data[streamableGrid.EnabledCells];
                    int i = 0;
                    foreach(int flattenedIndex in streamableGrid.FlattenedIndexesOfEnabledCells))
                        enabledCellData[i++] = GetCellData(flattenedIndex);
                }
            }
            </code>
            </example>
            <displayName id="FlattenedEnabledStreamableGridIndexes">
            FlattenedEnabledStreamableGridIndexes()
            </displayName>
            <syntax>
            public FlattenedIndexesOfEnabledCellsEnumerable FlattenedIndexesOfEnabledCells()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.ConvertCellOnEndlessGridToCellOnStreamableGrid(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Converts an Endless Grid Cell to its equivalent Streamable Grid Cell. Each Endless 
            Grid Cell is just a projection of a Streamable Grid Cell, and thus has the same dimensions and chunk associations.
            <para>
            Note that the passed in cell should be 1 based. That is, the first cell in the grid has a row of 1, column of 1, 
            and layer of 1. The returned Streamable Grid Cell will also be 1 based.
            </para>
            <para>
            Use this method over the PreInitSafe version if you know the Streamable Grid is initialized, as it will be slightly faster.
            </para>
            </summary>
            <param name="cellOnEndlessGrid" type="Cell" link="Cell.html">The Endless Grid Cell to be converted.</param>
            <returns type="Cell" link="Cell.html">The equivalent Streamable Grid Cell for the Endless Grid Cell specified.</returns>
            <displayName id="ConvertCellOnEndlessGridToCellOnStreamableGrid">ConvertCellOnEndlessGridToCellOnStreamableGrid(Cell)</displayName>
            <syntax>public Cell ConvertCellOnEndlessGridToCellOnStreamableGrid(Cell cellOnEndlessGrid)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetCellDimensionsOfStreamableGridCell(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Get the cell dimensions of cell on the Streamable Grid. The indexes of this cell must fall within the range 
            of rows, columns, and/or layers of your Streamable Grid.
            <para>
            For instance, in a 4 rows x 4 columns Streamable Grid, a row or column index of
            0 or 5 would not be valid (but 1, 2, 3, or 4 would be).
            </para>
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The cell on the Streamable Grid whose dimensions should be retrieved.
            </param>
            <returns type="CellDimensions" link="CellDimensions.html">
            The cell dimensions of the cell.
            </returns>
            <displayName id="GetCellDimensionsOfStreamableGridCell">GetCellDimensionsOfStreamableGridCell(Cell)</displayName>
            <syntax>public CellDimensions GetCellDimensionsOfStreamableGridCell(Cell streamableGridCell)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.TryGetGlobalExtraData_PreInitSafe(System.String,System.String@)">
            <summary>
            Attemps to get data stored in the Streamable Grids Global Extra Data. Use this if you know for certain the data you want is stored in 
            the Global Extra Data. If you are not sure if it's stored here, or you know it is but there also may be data with the same key stored 
            in an LOD's Extra Data, use the GridLODDetails 
            <see cref="M:DeepSpaceLabs.SAM.GridLODDetails.TryGetExtraData_PostInit(System.String,System.String@)" href="GridLODDetails.html#TryGetExtraData_PreInitSafe">TryGetExtraData_PreInitSafe</see> 
            method istead, as that will return the data from the LOD if it exist, or data from the Global Extra Data if it does not exist on the LOD.
            </summary>
            <param name="key" type="string">
            The key to use to access the data.
            </param>
            <param name="data" type="string">
            Will be set to the data if the method returns true or null if the method returns false.
            </param>
            <returns type="bool">
            True if the data was successfully retrieved, false otherwise.
            </returns>
            <displayName id="TryGetGlobalExtraData_PreInitSafe">
            TryGetGlobalExtraData_PreInitSafe(string, out string)
            </displayName>
            <syntax>
            public bool TryGetGlobalExtraData_PreInitSafe(string key, out string data)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.SetGlobalExtraData_PreInitSafe(System.String,System.String)">
            <summary>
            Sets the global extra data for a given key. 
            <para>
            This will replace any existing data using the key for this Streamable Grid, or create a new entry if there is no existing entry using the key.
            </para>
            <para>
            Generally speaking, you should call this method before SAM has been initialized in order to ensure that anything making use of the 
            Extra Data will have the correct value, as most things making use of it will retrieve the extra data just once (when SAM is 
            initialized) and cache the value for performance reasons.
            </para>
            <para>
            If you want to set/change the extra data for a specific LOD Group, you should use the GridLODDetail class's  
            <see cref="M:DeepSpaceLabs.SAM.GridLODDetails.SetExtraData_PreInitSafe(System.String,System.String)" href="GridLODDetails.html#SetExtraData_PreInitSafe">SetExtraData_PreInitSafe</see> method instead.
            </para>
            </summary>
            <param name="key" type="string">
            The key used to set the extra data.
            </param>
            <param name="data" type="string">
            The data to set.
            </param>
            <displayName id="SetGlobalExtraData_PreInitSafe">
            SetGlobalExtraData_PreInitSafe(string, string)
            </displayName>
            <syntax>
            public void SetGlobalExtraData_PreInitSafe(string key, string data)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetLengthOfStreamableGridRow(System.Int32)">
            <summary>
            Get the length of a Streamable Grid row. The input streamableGridRow should be 0 index based. 
            For instance, to get the length of the very first row
            in the grid, you would pass in 0, not 1. To get the second row, you'd pass in 1, not 2, and so on.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="streamableGridRow" type="double">The row who's length should be retrieved.</param>
            <displayName id="GetLengthOfStreamableGridRow">GetLengthOfStreamableGridRow(int)</displayName>
            <syntax>public double GetLengthOfStreamableGridRow(int streamableGridRow)</syntax>
            <returns type="double">The length of the input streamableGridRow.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetLengthOfEndlessGridRow(System.Int32)">
            <summary>
            Get the length of an Endless Grid row. Each input Endless Grid row is translated
            to its equivalent Streamable Grid row, and then the length of that Streamable Grid row is returned.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridRow" type="double">The row who's length should be retrieved.</param>
            <displayName id="GetLengthOfEndlessGridRow">GetLengthOfEndlessGridRow(int)</displayName>
            <syntax>public double GetLengthOfEndlessGridRow(int endlessGridRow)</syntax>
            <returns type="double">The length of the input endlessGridRow.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetWidthOfStreamableGridColumn(System.Int32)">
            <summary>
            Get the width of a Streamable Grid column. The input streamableGridColumn should be 0 index based. 
            For instance, to get the width of the very first column
            in the grid, you would pass in 0, not 1. To get the second column, you'd pass in 1, not 2, and so on.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="streamableGridColumn" type="double">The column who's width should be retrieved.</param>
            <displayName id="GetWidthOfStreamableGridColumn">GetWidthOfStreamableGridColumn(int)</displayName>
            <syntax>public double GetWidthOfStreamableGridColumn(int streamableGridColumn)</syntax>
            <returns type="double">The width of the input streamableGridColumn.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetWidthOfEndlessGridColumn(System.Int32)">
            <summary>
            Get the width of an Endless Grid column. Each input Endless Grid column is translated
            to its equivalent Streamable Grid column, and then the width of that Streamable Grid column is returned.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridColumn" type="double">The column who's width should be retrieved.</param>
            <displayName id="GetWidthOfEndlessGridColumn">GetWidthOfEndlessGridColumn(int)</displayName>
            <syntax>public double GetWidthOfEndlessGridColumn(int endlessGridColumn)</syntax>
            <returns type="double">The width of the input endlessGridColumn.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetHeightOfStreamableGridLayer(System.Int32)">
            <summary>
            Get the height of a Streamable Grid layer. The input streamableGridLayer should be 0 index based. For instance, to get the 
            height of the very first layer
            in the grid, you would pass in 0, not 1. To get the second layer, you'd pass in 1, not 2, and so on.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="streamableGridLayer" type="double">The layer who's height should be retrieved.</param>
            <displayName id="GetHeightOfStreamableGridLayer">GetHeightOfStreamableGridLayer(int)</displayName>
            <syntax>public double GetHeightOfStreamableGridLayer(int streamableGridLayer)</syntax>
            <returns type="double">The height of the input streamableGridLayer.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetHeightOfEndlessGridLayer(System.Int32)">
            <summary>
            Get the height of an Endless Grid layer. Each input Endless Grid layer is translated
            to its equivalent Streamable Grid layer, and then the height of that Streamable Grid layer is returned.
            <para>This is a runtime method and should not be used in the editor.</para>
            </summary>
            <param name="endlessGridLayer" type="double">The layer who's height should be retrieved.</param>
            <displayName id="GetHeightOfEndlessGridLayer">GetHeightOfEndlessGridLayer(int)</displayName>
            <syntax>public double GetHeightOfEndlessGridLayer(int endlessGridLayer)</syntax>
            <returns type="double">The height of the input endlessGridLayer.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.IsCellDisabled_PreInitSafe(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Can be used to determine if a particular Streamable Cell on this grid is disabled. Uses the states of the cells as set in the inspector of the 
            Streamable Grid. At runtime it is better to use the IsCellDisabled function, as it will be faster.
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The Streamable Grid Cell you wish to know the state of.
            </param>
            <returns type="bool">
            True if the Cell is disabled, false otherwise.
            </returns>
            <displayName id="IsCellDisabled_PreInitSafe">
            IsCellDisabled_PreInitSafe(Cell)
            </displayName>
            <syntax>
            public bool IsCellDisabled_PreInitSafe(Cell streamableGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.ConvertCellOnEndlessGridToCellOnStreamableGrid_PreInitSafe(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Converts a cell on the Endless Grid to a cell on the Streamable Grid. You can use this method before the Streamable Grid has been initialized.
            </summary>
            <param name="cellOnEndlessGrid" type="Cell" link="Cell.html">
            The one based cell on the Endless Grid you wish to convert
            </param>
            <returns type="Cell" link="Cell.html">
            The converted one based cell on the Streamable Grid.
            </returns>
            <displayName id="ConvertCellOnEndlessGridToCellOnStreamableGrid_PreInitSafe">
            ConvertCellOnEndlessGridToCellOnStreamableGrid_PreInitSafe(Cell)
            </displayName>
            <syntax>
            public Cell ConvertCellOnEndlessGridToCellOnStreamableGrid_PreInitSafe(Cell cellOnEndlessGrid)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.ConvertEndlessGridRowToStreamableGridRow_PreInitSafe(System.Int32)">
            <summary>
            Converts an Endless Grid row to a row on the Streamable Grid. You can use this method before the Streamable Grid has been initialized.
            </summary>
            <param name="endlessGridRow" type="int">The Endless Grid row to convert.</param>
            <displayName id="ConvertEndlessGridRowToStreamableGridRow_PreInitSafe">ConvertEndlessGridRowToStreamableGridRow_PreInitSafe(int)</displayName>
            <syntax>public int ConvertEndlessGridRowToStreamableGridRow_PreInitSafe(int endlessGridRow)</syntax>
            <returns type="int">The row on the Streamable Grid.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.ConvertEndlessGridColumnToStreamableGridColumn_PreInitSafe(System.Int32)">
            <summary>
            Converts an Endless Grid column to a column on the Streamable Grid. You can use this method before the Streamable Grid has been initialized.
            </summary>
            <param name="endlessGridColumn" type="int">The Endless Grid column to convert.</param>
            <displayName id="ConvertEndlessGridColumnToStreamableGridColumn_PreInitSafe">ConvertEndlessGridColumnToStreamableGridColumn_PreInitSafe(int)</displayName>
            <syntax>public int ConvertEndlessGridColumnToStreamableGridColumn_PreInitSafe(int endlessGridColumn)</syntax>
            <returns type="int">The column on the Streamable Grid.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.ConvertEndlessGridLayerToStreamableGridLayer_PreInitSafe(System.Int32)">
            <summary>
            Converts an Endless Grid layer to a layer on the Streamable Grid. You can use this method before the Streamable Grid has been initialized.
            </summary>
            <param name="endlessGridLayer" type="int">The Endless Grid layer to convert.</param>
            <displayName id="ConvertEndlessGridLayerToStreamableGridLayer_PreInitSafe">ConvertEndlessGridLayerToStreamableGridLayer_PreInitSafe(int)</displayName>
            <syntax>public int ConvertEndlessGridLayerToStreamableGridLayer_PreInitSafe(int endlessGridLayer)</syntax>
            <returns type="int">The layer on the Streamable Grid.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetCellDimensionsOfStreamableGridCell_PreInitSafe(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Gets the dimensions of a specific cell on the Streamable Grid. Safe for use before Streamable Grid has 
            been initialized (for example, in the editor).
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The cell on the Streamable Grid to get the dimensions for
            </param>
            <returns type="CellDimensions" link="CellDimensions.html">
            The cell's dimensions
            </returns>
            <displayName id="GetCellDimensionsOfStreamableGridCell_PreInitSafe">
            GetCellDimensionsOfStreamableGridCell_PreInitSafe(Cell)
            </displayName>
            <syntax>
            public CellDimensions GetCellDimensionsOfStreamableGridCell_PreInitSafe(Cell streamableGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetVectorDimensionsOfStreamableGridCell_PreInitSafe(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Gets the dimensions of a specific cell on the Streamable Grid. Safe for use before Streamable Grid has 
            been initialized (for example, in the editor).
            <para>
            This method is similar to 
            GetCellDimensionsOfStreamableGridCell_PreInitSafe, however the dimensions are placed on the correct axes according 
            to the Streamable Grid's Axes. For example, if the Axes is 2D XZ or 3D, the row length of the cell is placed 
            in the z component of the Vector3Double and the layer height is placed in the y component. 
            If the Axes is 2D XY, the row length is placed in the y component instead, and the layer height is placed in the 
            z component.
            </para>
            </summary>
            <param name="streamableGridCell" type="Cell" link="Cell.html">
            The cell on the Streamable Grid to get the dimensions for
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The cell's dimensions as a Vector3Double. This method automatically takes into account the Axes and places 
            the cell's dimensions on the correct axes.
            </returns>
            <displayName id="GetVectorDimensionsOfStreamableGridCell_PreInitSafe">
            GetVectorDimensionsOfStreamableGridCell_PreInitSafe(Cell)
            </displayName>
            <syntax>
            public CellDimensions GetVectorDimensionsOfStreamableGridCell_PreInitSafe(Cell streamableGridCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetChunksOfStreamableGridCell_PreInitSafe(System.Int32,DeepSpaceLabs.SAM.Cell)">
            <summary>
            Gets the number of chunks the cellOnStreamableGrid has in the LOD group specified by the LOD index.
            </summary>
            <param name="LOD" type="index">The index of the LOD as shown in the inspector.</param>
            <param name="streamableGridCell" type="Cell" link="Cell.html">The cell on the Streamable Grid.</param>
            <returns type="int">The number of chunks.</returns>
            <displayName id="GetLODName">GetChunksOfStreamableGridCell_PreInitSafe(int, Cell)</displayName>
            <syntax>public int GetChunksOfStreamableGridCell_PreInitSafe(int LOD, Cell streamableGridCell)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.GetCountOfEnabledCells_PreInitSafe">
            <summary>
            Gets a count of the total Enabled Cells on this Streamable Grid (as set in the Unity Editor). Safe to use before or after the 
            Streamable Grid has been initialized, although if you know for sure that the Grid has been initialized, using 
            the <see cref="P:DeepSpaceLabs.SAM.StreamableGrid.EnabledCells" href="#EnabledCells">EnabledCells</see> property will be marginally faster.
            </summary>
            <returns type="long">
            The number of Enabled Cells. If you have set a custom IsCellDisabled function, note that this value will not be accurate, as 
            there is no way to count the number of enabled cells in that case.
            </returns>
            <displayName id="GetCountOfEnabledCells_PreInitSafe">
            GetCountOfEnabledCells_PreInitSafe()
            </displayName>
            <syntax>
            public long GetCountOfEnabledCells_PreInitSafe()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.CalculateTotalCells(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the total number of cells given rows, columns, and layers values. The input values are casted to long before 
            the calculation is performed, allowing the total number of cells to be as large as 18,446,744,073,709,551,615. This method 
            does not detect overflow, if overflow occurs the returned value will likely be negative and invalid. If using this method with 
            input values retrieved from a Streamable Grid, however, you do not need to worry about overflow, as the Streamable Grid can only contain 
            rows/columns/layers values that do not overflow.
            </summary>
            <param name="rows" type="int">
            The number of rows to use in the calculation.
            </param>
            <param name="columns" type="int">
            The number of columns to use in the calculation.
            </param>
            <param name="layers" type="int">
            The number of layers to use in the calculation.
            </param>
            <returns type="long">
            The total number of cells.
            </returns>
            <displayName id="CalculateTotalCells">
            CalculateTotalCells(int, int, int)
            </displayName>
            <syntax>
            public static long CalculateTotalCells(int rows, int columns, int layers)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.CalculateTotalCellsWithOverflowCheck(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates the total number of cells given rows, columns, and layers values. The input values are casted to long before 
            the calculation is performed, allowing the total number of cells to be as large as 18,446,744,073,709,551,615. This method will 
            detect and throw an overflow exception if the total number of cells is greater than this value!
            </summary>
            <param name="rows" type="int">
            The number of rows to use in the calculation.
            </param>
            <param name="columns" type="int">
            The number of columns to use in the calculation.
            </param>
            <param name="layers" type="int">
            The number of layers to use in the calculation.
            </param>
            <returns type="long">
            The total number of cells.
            </returns>
            <displayName id="CalculateTotalCellsWithOverflowCheck">
            CalculateTotalCellsWithOverflowCheck(int, int, int)
            </displayName>
            <syntax>
            public static long CalculateTotalCellsWithOverflowCheck(int rows, int columns, int layers)
            </syntax>
            <exception cref="T:System.OverflowException">
            Thrown if the calculated value is greater than 18,446,744,073,709,551,615
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.StreamableGrid.DeRegister">
            <summary>
            Deregisters with the World and if no more users are registered, de-initializes the 
            World (disposes of Native Containers used by the Streamable Grid at runtime).
            <para>
            The World cannot be reinitialized because the arrays used to create the native arrays are cleared at runtime (to save on memory).
            So, once user count becomes 0, the World should never be registered with another user.
            </para>
            <para>
            Note, in practice it should never be necessary for you to call this method manually; it is done automatically by SAM! The only time you 
            might need to do so is if you are using the Streamable Grid for some sort of custom purpose. Every De-Register call must have been proceeded 
            by a Register call previously!
            </para>
            </summary>
            <displayName id="DeRegister">
            DeRegister()
            </displayName>
            <syntax>
            public void DeRegister()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldCell">
            <summary>
            Represents a tangible cell on the <see cref="T:DeepSpaceLabs.SAM.World" href="World.html">World</see>.
            <para>
            Each World Cell is always associated with a specific Cell on a Streamable Grid and a Cell on an Endless Grid. For non endless/repeating Worlds, 
            these two Cell values will always match, but for endless Worlds (with one or more endless Axis), these Cells may or may not match. As such, the primary 
            identificator of a World Cell is it's CellOnEndlessGrid, as this is gauranteed to be unique across all loaded World Cells.
            </para>
            <para>
            In 99% of cases, each World Cell will have one or more Asset Chunks stored in it, which is typically determined by the Streamable Grid Cell and active LOD of the 
            World Cell. World Cell's can trade up or down in LODs, moving from using the Asset Chunks of a lower quality LOD Group to a higher quality LOD Group, or vice 
            versa. When this happens, a new World Cell is used to store the new LODs Asset Chunks, and internally this new World Cell 
            replaces the old World Cell that used the previous LODs chunks.
            </para>
            <para>
            If the World Cell's active LOD is associated with an LOD Group that uses Unity Terrain, the World Cell will actually be a 
            <see cref="T:DeepSpaceLabs.SAM.WorldCellWithTerrain" href="WorldCellWithTerrain.html">WorldCellWithTerrain</see> 
            object, which allows it to store Unity Terrain and perform other operations required for Terrain Neighboring to work.
            </para>
            <para>
            Your primary interaction with World Cells will come in custom 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controllers</see> and 
            <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">World Grouping Listeners</see>, though there are 
            several other components that interact with them as well.
            </para>
            </summary>
            <title>WorldCell Class</title>
            <category>Primary Non Components</category>
            <navigationName>WorldCell</navigationName>
            <fileName>WorldCell.html</fileName>
            <syntax>public class WorldCell</syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.AllChunkAssetsMatchExpectedLOD">
            <summary>
            Whether every chunk asset on this World Cell matches the expected assets for its current active Level of Detail. This will be true in most cases. 
            One situation where it might be false is if using an Addressable Streamer and an asset fails to download properly.
            <para>
            In this situation, 
            a lower quality LOD asset or place holder asset may be loaded instead. If that happens, this value will return false, so long as at least 
            one chunk is using the lower quality LOD or placeholder asset.
            </para>
            <para>
            This is useful in situations where you are using a component (such as a 
            <see cref="T:DeepSpaceLabs.SAM.CellVisualTransitionController" href="CellVisualTransitionController.html">Cell Visual Transition Controllers</see> or 
            <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">World Grouping Listeners</see>) 
            which expects a specific hierarchy format for each LOD. In these cases, the component may not work properly or it may throw an exception if it tries 
            to work with the lower quality LOD or place holder assets as if they were the assets of the World Cell's LOD.
            </para>
            <para>
            So instead, when this property returns false, 
            you can verify whether each chunk asset on the World Cell is a lower quality LOD asset or placeholder by checking its hierarchy (you cannot check 
            the game object name, because all chunks are renamed to match the chunk index and World Cell index, no matter of it is a lower quality LOD or 
            placeholder asset that is loaded for the chunk), or by another means.
            </para>
            <para>
            Also keep in mind that the setter for this property is also public, so that the Addressable Streamers (which exist outside of the .dll) can access 
            this property. In most instances, you should not need to set the value of this property yourself.
            </para>
            <para>
            Finally, this property is queried any time Asset Chunks from one World Cell would be reused by another World Cell on the same LOD, to ensure that the chunks 
            are of the correct LOD. If they are not, the chunks are not transferred, but instead passed to the Chunk Manager for processing.
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.DoesCellHaveMultipleChunks">
            <summary>
            Gets a value indicating whether the cell has multiple Asset Chunks.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.Bounds">
            <summary>
            The bounds of the World Cell in the scene, which is calculated from the CellPosition and dimensions of the cell (as set on the Streamable Grid). 
            <para>
            This may or may not be not equivalent to the bounds of the terrain or chunks  
            associated with the cell, so you should decide which bounds to use if implementing a culling system.
            </para>
            </summary>
            <type link="BoundsDouble.html">BoundsDouble</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.PositionOfChunks">
            <summary>
            Gets the position that Asset Chunks should be placed at. You can position the chunks manually, or 
            let them be automatically positioned by the World (by passing in No or Maybe for chunksPositionedCorrectlyAlready 
            when calling <see cref="M:DeepSpaceLabs.SAM.WorldCell.AttachChunkToCell(System.Object,DeepSpaceLabs.SAM.ChunksPositioned,System.Int32)" href="#AttachChunkToCell">AttachChunkToCell</see>).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.CellPosition">
            <summary>
            Gets the position of the cell in world space within the scene (note, this may be different than the position of the 
            chunk, since the chunk can be offset from the cell).
            <para>
            Cell Position is defined as the minimum point of the cell on each axis.
            </para>
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.CellPositionOnWorldGrid">
            <summary>
            Gets the Cell's position on the imaginary World Grid of the World it is associated with. 
            This World Grid's Row 1, Column 1, Layer 1 Cell is always considered to be at x = 0, y = 0, z = 0. 
            You can use this position when you need an absolute position value that remains constant no matter 
            the current Origin Cell or Origin Position of the World. The only way for this position value to 
            change is by changing the position of the Zone the Cell is part of.
            <para>
            This is primarily useful for procedural generation algorithms that need an absolute/unchanging 
            position as input (the CellPosition cannot be used since that position may change depending on the 
            current Origin Cell of the World).
            </para>
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.CellOnStreamableGrid">
            <summary>
            Gets the cell's index on the Streamable Grid associated with the Zone Grouping this cell belongs to.
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.CellOnEndlessGrid">
            <summary>
            Gets the cell's index on the Endless Grid associated with the Zone Grouping this cell belongs to.
            </summary>
            <type link = "Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.CellOnWorldGrid">
            <summary>
            Gets the cell's index on the World Grid (imaginary grid associated with the World the cell belongs to).
            </summary>
            <type link = "Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.ChunkManager">
            <summary>
            Gets the chunk manager resposible for managing this World Cell.
            </summary>
            <type link="ChunkManager.html">ChunkManager</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.ChunkStreamer">
            <summary>
            Gets the chunk streamer resposible for loading and removing/deactivating the Asset Chunks for this World Cell.
            </summary>
            <type link="ChunkStreamer.html">ChunkStreamer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.CellUsers">
            <summary>
            Gets the number of users of this World Cell across all LODs. The World Cell upgrades to a higher quality LOD whenever a user is added 
            for the higher quality LOD (where no user was present before). It downgrades when the user count for an LOD reaches 0 (and users for a lower 
            quality LOD exists). When the total CellUsers count reaches 0, it is unloaded completely.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.FlattenedStreamableGridIndex">
            <summary>
            Gets the flattened index of the cell on the Streamable Grid it belongs to. The flattened index is the CellOnStreamableGrid value flattened to 
            represent an index in a 1D array of size (StreamableGrid.Rows * StreamableGrid.Columns * StreamableGrid.Layers). 
            <para>
            Note however, if you have a very large world, this value may be larger than int.MaxValue, making 
            it unusable as an index into a real array. In such cases, it's better to use it as the key in a dictionary.
            </para>
            </summary>
            <type>long</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.ZoneID">
            <summary>
            The ID of the Zone this World Cell belongs to.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.ZoneIndex">
            <summary>
            The index of the Zone this World Cell belongs to.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.WorldGroupingID">
            <summary>
            The ID of the World Grouping this World Cell belongs to.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.WorldGroupingIndex">
            <summary>
            Gets the index of the World Grouping this World Cell belongs to.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.LevelOfDetail">
            <summary>
            Gets the active Level of Detail of the World Cell.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.NumChunks">
            <summary>
            Gets the number of Asset Chunks this World Cell has.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.DoesCellHaveUsers">
            <summary>
            Gets a value indicating whether the World Cell currently has any users across all LODs.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.Height">
            <summary>
            Gets the height of the cell.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.Length">
            <summary>
            Gets the length of the cell.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.Width">
            <summary>
            Gets the width of the cell.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.World">
            <summary>
            Get the World this World Cell belongs to.
            </summary>
            <type link="World.html">World</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.StreamableGrid">
            <summary>
            Gets the Streamable Grid this cell was created from.
            </summary>
            <type link = "StreamableGrid.html">StreamableGrid</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.WestNeighbor">
            <summary>
            Gets the World Cell that neighbors this WorldCell to the West (-X axis).
            </summary>
            <type link ="#">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.NorthNeighbor">
            <summary>
            Gets the World Cell that neighbors this WorldCell to the North (+Y for 2D XY Grids, or +Z otherwise).
            </summary>
            <type link ="#">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.EastNeighbor">
            <summary>
            Gets the World Cell that neighbors this WorldCell to the East (+X Axis).
            </summary>
            <type link ="#">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.SouthNeighbor">
            <summary>
            Gets the World Cell that neighbors this WorldCell to the South (-Y for 2D XY Grids, or -Z otherwise).
            </summary>
            <type link ="#">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.TopNeighbor">
            <summary>
            Gets the World Cell that neighbors this WorldCell above (+Y Axis, only present for 3D Worlds).
            </summary>
            <type link ="#">WorldCell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCell.BottomNeighbor">
            <summary>
            Gets the World Cell that neighbors this WorldCell below (-Y Axis, only present for 3D Worlds).
            </summary>
            <type link ="#">WorldCell</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCell.AttachChunkToCell(System.Object,DeepSpaceLabs.SAM.ChunksPositioned,System.Int32)">
            <summary>
            Attaches an Asset Chunk to the cell. If creating a custom Chunk Streamer or Chunk Manager class, 
            you should either let the World position the chunk correctly by 
            passing in 'No' for chunksPositionedCorrectlyAlready, or position the chunks manually (or instantiate it 
            at the correct position) and pass in 'Yes'. If you are unsure whether it's positioned correctly, you can pass in Maybe instead.
            <para>
            It's assumed that all chunks attached for a World Cell during a given operation will have the same value for chunksPositionedCorrectlyAlready. 
            As such, only the value passed in for the last chunk will actually be used.
            </para>
            <para>
            The chunks are not positioned immediately. 
            If you require them to be positioned immediately in whatever is calling this method, you should position them manually and pass 
            in Yes for the chunksPositionedCorrectlyAlready value.
            </para>
            <para>
            If you have some chunks that are positioned already and others that are not, 
            pass in Maybe to have the World evaluate all of the chunks.
            </para>
            </summary>
            <param name="chunk" type = "object">
            The Asset Chunk to attach to the cell. While you can pass in any object, the object should match the Chunk Type you set on the LOD Group of 
            your Streamable Grid.
            </param>
            <param name="chunksPositionedCorrectlyAlready" type="ChunksPositioned" link="ChunksPositioned.html">
            Whether the Asset Chunks attached to the World Cell are already positioned correctly. 
            If 'No', the chunks will be moved to PositionOfChunks (at a later time) by the World.
            <para>
            If you've already positioned the chunks at the correct 
            location (PositionOfChunks), you can pass in 'Yes'.
            </para>
            <para>
            If you are unsure whether the chunks are positioned, or are attaching a 
            combination of positioned and non-positioned chunks, pass in 'Maybe'. Only the value passed in for the last chunk attached will always be used!
            </para>
            </param>
            <param name="chunkIndex" type="int">
            The index of the chunk. 1 should be passed in if not using multi-chunking. Cannot be larger than 
            <see cref="P:DeepSpaceLabs.SAM.WorldCell.NumChunks" href="#NumChunks">NumChunks</see>.
            </param>
            <displayName id = "AttachChunkToCell">
            AttachChunkToCell(object, ChunksPositioned, int)
            </displayName>
            <syntax>
            public void AttachChunkToCell(object chunk, ChunksPositioned chunksPositionedCorrectlyAlready, int chunkIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCell.DetachChunksFromCell(System.Int32)">
            <summary>
            Detaches the Asset Chunk at the specified index from the cell and returns it.
            <para>
            The object returned and no longer associated with the World Cell (i.e., the World Cell no longer holds a reference to it).
            </para>
            </summary>
            <param name="chunkIndex" type="int">The index of the chunk to detatch (one based). 
            If you are not using chunks (i.e., there is only 1 chunk), then pass in 1. Cannot be larger than 
            <see cref="P:DeepSpaceLabs.SAM.WorldCell.NumChunks" href="#NumChunks">NumChunks</see>.
            </param>
            <displayName id="DetachChunksFromCell">DetachChunksFromCell(int)</displayName>
            <syntax>public object DetachChunksFromCell(int chunkIndex)</syntax>
            <returns type="object">The chunk that was detached from the World Cell.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCell.GetChunkBelongingToCell(System.Int32)">
            <summary>
            Gets the Asset Chunk at chunkIndex belonging to the cell. Unlike DetachChunksFromCell, this does not disassociate the chunk 
            from the World Cell (i.e., the World Cell will still hold a reference to the chunk after this method is called).
            </summary>
            <param name="chunkIndex" type="int">The index of the chunk you wish to get. 
            If you are not using multi-chunking (i.e., there is only 1 chunk), then pass in 1. Cannot be larger than 
            <see cref="P:DeepSpaceLabs.SAM.WorldCell.NumChunks" href="#NumChunks">NumChunks</see>.
            </param>
            <returns type="object">
            The chunk at chunkIndex.
            </returns>
            <displayName id = "GetChunkBelongingToCell">
            GetChunkBelongingToCell(int chunkIndex)
            </displayName>
            <syntax>
            object GetChunkBelongingToCell(int)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.WorldCellWithTerrain">
            <summary>
            Represents a WorldCell with a single Unity Terrain Asset Chunk. This type is created automatically in place of the base World Cell class when 
            a World Cell's active LOD is associated with an LOD Group that uses the Unity Terrain Chunk Type.
            <para>
            While there are some methods available in this class, we generally advise not calling these methods yourself, as SAM automates 
            Terrain Neighboring so that calling the methods is not necessary.
            </para>
            <para>
            You may have a need to access the Terrain component of the World Cell however, from a custom World Grouping Listener, for instance. In that case, 
            you can access the Terrain via the <see cref="P:DeepSpaceLabs.SAM.WorldCellWithTerrain.Terrain" href="#Terrain">Terrain</see> property.
            </para>
            </summary>
            <title>WorldCellWithTerrain Class</title>
            <category>Primary Non Components</category>
            <navigationName>WorldCellWithTerrain</navigationName>
            <fileName>WorldCellWithTerrain.html</fileName>
            <syntax>public class WorldCellWithTerrain : <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">WorldCell</see></syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCellWithTerrain.ClearNeighborsAndTerrain">
            <summary>
            Calls Terrain.SetNeighbors(null, null, null, null) and sets the internal terrain reference of this World 
            Cell to null.
            <para>
            Generally speaking, the Streamable Asset Manager will call this method automatically at the 
            appropriate time; you shouldn't need to call it yourself and should only do so if you absolutely 
            understand the consequences and know what you are doing!
            </para>
            </summary>
            <displayName id="ClearNeighborsAndTerrain">
            ClearNeighborsAndTerrain()
            </displayName>
            <syntax>
            public void ClearNeighborsAndTerrain()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.WorldCellWithTerrain.ResetNeighbors">
            <summary>
            Checks each World Cell Neighbor of this World Cell and gets a terrain for each if the neighbor is a 
            valid terrain neighbor. Then calls Terrain.SetNeighbors using each terrain neighbor as input. 
            Generally speaking, the Streamable Asset Manager will call this method automatically at the 
            appropriate time; you shouldn't need to call it yourself and should only do so if you absolutely 
            understand the consequences and know what you are doing!
            </summary>
            <displayName id="ResetNeighbors">
            ResetNeighbors()
            </displayName>
            <syntax>
            public void ResetNeighbors()
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldCellWithTerrain.Terrain">
            <summary>
            Gets the Terrain associted with this WorldCellWithTerrain.
            </summary>
            <type>Terrain</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.NonPoolingChunkManager">
            <summary>
            Provides an implementation for a <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">Chunk Manager</see> 
            that does not pool chunks. Note that this component is usable with  
            both Game Objects and non Game Object Chunks, however there are certain methods of the Chunk Manager class 
            that are by default configured to work with Game Objects. Those methods include:
            <para>
            GetChunkPosition - For retrieving the Vector3Double position of a chunk. Only called if the LOD using this manager has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkPosition - For setting the chunk position to a Vector3Double value. Only called if the LOD using this manager has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkActiveState - For setting the state of the chunk to active or deactive. This method is called only if Auto Activate/Deactivate 
            Cell Chunks is enabled in your World inspector, for any LODs that use this manager.
            </para>
            <para>
            If you anticipate any of these methods being called, you will need to create a custom class deriving from this one, and in that class override 
            the methods that will be called, so that they function correctly with your custom chunks.
            </para>
            </summary>
            <title>NonPoolingChunkManager Class</title>
            <category>Chunk Managers</category>
            <navigationName>NonPoolingChunkManager</navigationName>
            <fileName>NonPoolingChunkManager.html</fileName>
            <syntax>public sealed class NonPoolingChunkManager : <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">ChunkManager</see></syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PoolingChunkManager">
            <summary>
            Provides a base implementation for a pooling based <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">Chunk Manager</see>.
            <para>
            The pooling system is very simple, so you may wish to create your own manager class that implements a more 
            advanced system, though also note that using a pooling system with a streaming solution may be counter productive in 
            some cases, as the point of using a streaming solution is generally to reduce memory usage.
            </para>
            <para>
            This is an overridable class, so you can inherit from it to provide custom 
            pooling behaviour. When doing so, all you should need to do is override the 
            <see cref="M:DeepSpaceLabs.SAM.PoolingChunkManager.ShouldAddChunkSetToPool(DeepSpaceLabs.SAM.WorldCell,DeepSpaceLabs.SAM.PoolingChunkManager.PoolingChunkManagerUser)" href="PoolingChunkManager.html#ShouldAddChunkSetToPool">ShouldAddChunkSetToPool</see> method. 
            When queried, this method should return a value indicating if the 
            <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell's</see> chunk set should be added to the pool.
            </para>
            <para>
            In some instances, you may want to remove chunk sets that have been added to the pool yourself. The pool object can be accessed via the 
            user object, which can be accessed via the RegisteredUsers property and the userID given to the user when it registered with the 
            Chunk Manager (make sure to cast the user object to PoolingChunkManagerUser). For information on how to interact with the pool, take a look at 
            the <see cref="T:DeepSpaceLabs.SAM.ChunkSetPool" href="ChunkSetPool.html">ChunkSetPool</see> class.
            </para>
            <para>
            When removing chunk sets from a pool, you should make sure that the manager isn't already in the middle of an action
            that manipulates a pool, as it may cause problems. To do this, query the 
            <see cref="P:DeepSpaceLabs.SAM.PoolingChunkManager.PoolManipulationInProgress" href="#PoolManipulationInProgress">PoolManipulationInProgress</see> property 
            and if it returns true, yield for at least one frame. Keep performing this check until it returns false. Once that happens, set the PoolManipulationInProgress 
            property to true so that the base methods for attaching and detaching chunks will halt execution until you 
            finish your removal operation. Once you finish removing the chunks, set PoolManipulationInProgress back to false.
            </para>
            <para>
            This pooling class and any other ones based off it will not utilize the ChunkReuseJudge in the pooling logic, therefore 
            the objects will only be pooled and reused with cells that utilize the same Streamable Grid Cell. If you want your pool to 
            make use of the ChunkReuseJudge, you will need to make a custom pooling Chunk Manager that does not 
            derive from this class.
            </para>
            <para>
            This component is usable with  
            both Game Objects and non Game Object Chunks, however there are certain methods of the Chunk Manager class 
            that are by default, configured to work with Game Objects. Those methods include:
            </para>
            <para>
            GetChunkPosition - For retrieving the Vector3Double position of a chunk. Only called if the LOD using this controller has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkPosition - For setting the chunk position to a Vector3Double value. Only called if the LOD using this controller has 'Chunks Use 
            Positional Data' enabled (this setting can be found on your Streamable Grid asset).
            </para>
            <para>
            SetChunkActiveState - For setting the state of the chunk to active or deactive. This method is called only if Auto Activate/Deactivate 
            Cell Chunks is enabled in your World inspector, for any LODs that use this controller.
            </para>
            <para>
            If you anticipate any of these methods being called, you will need to create a custom class deriving from this one, and in that class override 
            the methods that will be called, so that they function correctly with your custom chunks.
            </para>
            <para>
            Additional Note: This component contains its own special class (PoolingChunkManagerUser) which enables multiple 
            users to use the pooling manager at the same time. The data associated with each user is stored in this user object and retrieved
            using the userID passed into each method.
            </para>
            <para>
            This user object contains information pertaining to the user, such as the 
            <see cref="T:DeepSpaceLabs.SAM.IZoneLODGroup" href="IZoneGrouping.html">IZoneGrouping</see> object associated with the user, the chunkStreamerUserID of 
            the user (in reference to the Chunk Streamer it uses), and the pool of the user. You can access the user object via the  
            <see cref="P:DeepSpaceLabs.SAM.ChunkManager.RegisteredUsers" href = "ChunkManager.html#RegisteredUsers">RegisteredUsers</see> property and userID, 
            like so: RegisteredUsers[userID], however you will need to cast it to a PoolingChunkManagerUser or a custom user class that 
            derives from it in order to access the pool.
            </para>
            <para>
            You may also create your own custom user object class which
            derives from PoolingChunkManagerUser, in order to store custom data or add custom methods.
            </para>
            <para>
            In fact, this strategy is utilized by some of the other Chunk Managers in the kit. Simply override the
            <see cref="M:DeepSpaceLabs.SAM.PoolingChunkManager.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32)" href = "#CreateNewUser">CreateNewUser</see> method and return your custom user object.
            </para>
            <para>
            The properties, methods, and constructors of this PoolingChunkManagerUser class have been included on this webpage along side 
            the other members of the PoolingChunkManager class. You can easily identify them as their member names include 
            a PoolingChunkManagerUser prefix. You can use these as a reference when creating custom PoolingChunkManagerUser classes.
            </para>
            </summary>
            <title>PoolingChunkManager Class</title>
            <category>Chunk Managers</category>
            <navigationName>PoolingChunkManager</navigationName>
            <fileName>PoolingChunkManager.html</fileName>
            <syntax>
            public class PoolingChunkManager : <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">ChunkManager</see>
            </syntax>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PoolingChunkManager.PoolManipulationInProgress">
             <summary>
            Gets a value indicating whether an operation is Currently in progress that manipulates the underlying 
            pool. Any action you perform that manipulates the pool (removes or adds objects from it) should be performed 
            in a coroutine, so that you can yield the execution of your action until this property returns false. 
            <para>
            If your action takes longer than a single frame, you should set this property to true while it is executing, then 
            false once it finishes, so that the underlying Add/Remove object methods do not run while you are manipulating 
            the pool.
             </para>
             </summary>
             <type>bool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PoolingChunkManager.CreateNewUser(DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32)">
            <summary>
            Creates a new PoolingChunkManagerUser, which is a custom type which derives 
            from ChunkManagerUser. This user object contains an object pool used specifically by this class.
            <para>
            If you create a class that derives from PoolingChunkManager, you may want to create a custom 
            user type that holds more data, depending on your needs. In that case, your custom user type should inherit from 
            PoolingChunkManagerUser and you should override this method to return an instance of 
            your custom type.
            </para>
            </summary>
            <param name="zoneGrouping" type="IZoneGrouping" link="IZoneGrouping.html">
            The Zone Grouping being registered.
            </param>
            <param name="chunkStreamerUserID" type="int">When the Zone Grouping registered with the manager, the manager automatically registered the 
            Zone Grouping with the Chunk Streamer associated with it. This is the user ID assigned to the Zone Grouping by that Chunk Streamer.
            </param>
            <displayName id = "CreateNewUser">CreateNewUser(IZoneGrouping, int)</displayName>
            <syntax>protected sealed override ChunkManagerUser CreateNewUser(IZoneGrouping zoneGrouping, int chunkStreamerUserID)</syntax>
            <returns type = "ChunkManagerUser">A new user object created using the worldAssociatedWithUser as input.</returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PoolingChunkManager.OnUserDeRegistering(DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Overriden to remove pooled objects belonging to the user just before it is de registered.
            </summary>
            <param name="user" type="ChunkManagerUser" ChunkManagerUser="Name.html">
            The user that is about to be de registered
            </param>
            <displayName id="OnUserDeRegistering">
            OnUserDeRegistering(ChunkManagerUser)
            </displayName>
            <syntax>
            public sealed override void OnUserDeRegistering(ChunkManagerUser user)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PoolingChunkManager.AttachChunksAlreadyInSceneToCellsInSingleFrame(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Searches for existing scene object in a pool, and if it finds all scene objects belonging to a cell, it attaches 
            them and removes the cell from the list.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells whose objects need to be attached.
            </param>
            <param name="user" type="ChunkManagerUser">
            The user requesting the attachment.
            </param>
            <displayName id="AttachChunksAlreadyInSceneToCellsInSingleFrame">
            AttachChunksAlreadyInSceneToCellsInSingleFrame(List&lt;WorldCell&gt;, ChunkManagerUser)
            </displayName>
            <syntax>
            protected sealed override void AttachChunksAlreadyInSceneToCellsInSingleFrame(List&lt;WorldCell&gt; cells, ChunkManagerUser user)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PoolingChunkManager.AttachChunksAlreadyInSceneToCells(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Searches for existing scene object in a pool, and if it finds all scene objects belonging to a cell, it attaches 
            them and removes the cell from the list.
            </summary>
            <param name="cells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells whose objects need to be attached.
            </param>
            <param name="user" type = "ChunkManagerUser">
            The user requesting the attachment.
            </param>
            <displayName id = "AttachChunksAlreadyInSceneToCells">
            AttachChunksAlreadyInSceneToCells(List&lt;WorldCell&gt;, ChunkManagerUser)
            </displayName>
            <syntax>
            protected sealed override IEnumerator&lt;YieldInstruction&gt; AttachChunksAlreadyInSceneToCells(List&lt;WorldCell&gt; cells, ChunkManagerUser user)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PoolingChunkManager.DetachAndProcessChunksToKeepInScene(System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell},DeepSpaceLabs.SAM.ChunkManager.ChunkManagerUser)">
            <summary>
            Detaches and pools the objects associated with the input cells over a period of frames. If there is not enough room 
            in the pool for all of a cell's objects, they are not removed (so will be unloaded by the Chunk Streamer). 
            Cells with objects that are sucessfully pooled are removed from the list.
            passed in list.
            </summary>
            <param name="deactivatedCells" type = "List&lt;WorldCell&gt;" link="WorldCell.html">
            The cells whose objects need to be detached and processed.
            </param>
            <param name="user" type = "ChunkManagerUser">
            The user requesting the detachment and processing.
            </param>
            <displayName id = "DetachAndProcessChunksToKeepInScene">
            DetachAndProcessChunksToKeepInScene(List&lt;WorldCell&gt;, ChunkManagerUser)
            </displayName>
            <syntax>
            protected sealed override IEnumerator&lt;YieldInstruction&gt; DetachAndProcessChunksToKeepInScene(List&lt;WorldCell&gt; cells, ChunkManagerUser user)
            </syntax>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PoolingChunkManager.ShouldAddChunkSetToPool(DeepSpaceLabs.SAM.WorldCell,DeepSpaceLabs.SAM.PoolingChunkManager.PoolingChunkManagerUser)">
            <summary>
            Queried to determine if the input cell's Asset Chunk Set should be added to the pool. This method is only queried when 
            there is room in the pool for the Asset Chunk Set (i.e., it is not at capacity), so if you return true from the method, you can be 
            guaranteed that the chunks will be added. If not overriden, it will always return true.
            </summary>
            <param name="cell" type = "WorldCell" link="WorldCell.html">
            The cell which needs to be processed.
            </param>
            <param name="userCellBelongsTo" type="PoolingChunkManagerUser">
            The user the cell belongs to.
            </param>
            <displayName id = "ShouldAddChunkSetToPool">
            ShouldAddChunkSetToPool(WorldCell, PoolingChunkManagerUser)
            </displayName>
            <syntax>
            public virtual void ShouldAddChunkSetToPool(WorldCell cell, PoolingChunkManagerUser userCellBelongsTo)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.PoolingChunkManager.PoolingChunkManagerUser">
            <summary>
            Stores LOD Group user related data. You can create a custom class deriving 
            from this type in order to store additional data or provide user specific 
            properties/methods. If you do, you need to override the CreateNewUser method 
            in your custom Chunk Manager to return an instance of this new class.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.PoolingChunkManager.PoolingChunkManagerUser.Pool">
            <summary>
            A ChunkSetPool object for this user. This pool is actually a container for a 
            set of pools, with one pool per Streamable Grid Cell.
            </summary>
            <type link="ChunkSetPool.html">ChunkSetPool</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.PoolingChunkManager.PoolingChunkManagerUser.#ctor(DeepSpaceLabs.SAM.ChunkManager,DeepSpaceLabs.SAM.IZoneLODGroup,System.Int32,System.Int32)">
            <summary>
            Creates an instance of this user object. If you are overriding the PoolingChunkManager class and 
            not overriding the PoolingChunkManagerUser, you can create a new instance of this user object via this 
            constructor, which can be returned in the ChunkManager's CreateNewUser method.
            <para>
            If you are overriding PoolingChunkManagerUser, your custom user class will need constructors with at least these parameters 
            (but can also have more), and they must also call the base constructor, which is accomplished by placing
            : (chunkManager, zoneGrouping, chunkStreamerUserID, maxChunkSetsPerPool) after your constructor declaration.
            </para>
            <para>
            Note, this constructor can only be used from a class deriving from PoolingChunkManager or PoolingChunkManagerUser.
            </para>
            </summary>
            <param name="chunkManager" type="ChunkManager" link="ChunkManager.html">
            The parent Chunk Manager instance creating the user object
            </param>
            <param name="zoneLODGroup" type="IZoneLODGroup" link="IZoneLODGroup.html">
            The Zone LOD Group the user object is being created for.
            </param>
            <param name="chunkStreamerUserID" type="int">
            The User ID of the LOD Group that was assigned to it by the 
            Chunk Streamer when it was registered with it. 
            </param>
            <param name="maxChunkSetsPerPool" type="int">
            The maximum number of Chunk Sets allowed in each pool, i.e., its capacity.
            </param>
            <displayName id="PoolingChunkManagerUser.PoolingChunkManagerUser">
            PoolingChunkManagerUser.PoolingChunkManagerUser(ChunkManager, IZoneLODGroup, int, int)
            </displayName>
            <syntax>
            public PoolingChunkManagerUser(ChunkManager chunkManager, IZoneLODGroup zoneLODGroup, int chunkStreamerUserID, int maxChunkSetsPerPool) : base(chunkManager, zoneGrouping, chunkStreamerUserID)
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.World">
            <summary>
            Represents a World, which combines one or more 
            <see cref="T:DeepSpaceLabs.SAM.StreamableGrid" href="StreamableGrid.html">Streamable Grids</see> together to form a complex game world. 
            Whereas Streamable Grids are simply data containers, 
            Worlds have position within the scene and are made up of Asset Chunks belonging to 
            <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cells</see> (which directly correspond to the Streamable 
            Grid Cells on Streamable Grids). The World's position can either be fixed or be based on a floating origin system. On a Fixed Position based World, 
            each World Cell and its Asset Chunks has a position that will never change through the lifetime of the game.
            <para>
            Floating Origin based Worlds use a fixed point in space as the Origin Point, 
            but the Origin Cell can be changed (either explicitly or automatically as a result of the player moving a certain distance from the origin point), which 
            effectively shifts the World Cells and Asset Chunks loaded by the World in an attempt 
            to keep them close to the Origin Point.
            </para>
            <para>
            Worlds can either be endless on one or more Axes or non endless. When an Axis is endless, the world repeats itself on that axis 
            over and over again endlessly, which simulates a "spherical" World.
            </para>
            <para>
            A World does not typically decide what should be loaded on its own (the exception is Auto-Loaded World Regions configured in the inspector). Instead, 
            it receives commands to add and remove users for World Cells from external sources (such as 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">Active Grids</see>). It processes these add/remove user requests, 
            cancelling out competing requests (i.e., an add and remove requests comes in for the same World Cell) and tallying the number of users for each LOD 
            of a World Cell. It then loads, unloads, or transitions World Cells from one LOD to another based on those requests (for example, if remove requests 
            come in for a World Cell and after processing them, the World Cell does not have any users for any LODs, the World Cell is unloaded).
            </para>
            <para>
            The World operations within Update Cycles. After processing add/remove requests, if any changes to the makeup of World Cells is required, it 
            initiates a World Update. While a World Update is in progress, any incoming add/remove requests are queued and only processed after the 
            current World Update has finished.
            </para>
            <para>
            Worlds do not load or unload the Asset Chunks associated with World Cells. They delegate this duty to 
            <see cref="T:DeepSpaceLabs.SAM.ChunkManager" href="ChunkManager.html">Chunk Managers</see> and 
            <see cref="T:DeepSpaceLabs.SAM.ChunkStreamer" href="ChunkStreamer.html">Chunk Streamers</see>, which 
            manage the lifetime of Asset Chunks and load/unload chunks into/out of the scene respectively.
            </para>
            <para>
            A World should only be disabled (or its game object disabled) if it is being used as a prototype to create Worlds 
            at runtime via the <see cref="T:DeepSpaceLabs.SAM.ComponentManager" href="ComponentManager.html">Component Manager</see>. 
            Do not disable a World with the intention of enabling/using it at a later time, 
            as this will not work properly. Instead, you should create the World via the Component Manager, 
            and destroy it when it is no longer needed.
            </para>
            <para>
            Alternatively, you can modify the World's <b>World Sleep Mode</b> setting to allow the World to sleep under certain conditions, such as when it 
            has no loaded World Cells.
            </para>
            <para>
            Methods that begin with "PreInitialize" in their name can only be used before the World has been initialized. Methods that end 
            with "PreInitSafe" in their name are safe to use before or after the World has been intialized. Methods without either of these words can only be 
            used after the World has been initialized.
            </para>
            <para>
            For properties, we have indiciated in the property descriptions those that are safe to use both before and/or after the 
            World has been initialized. All other properties are only safe to access after the World is initialized.
            </para>
            </summary>
            <title>World Class</title>
            <category>Primary Components</category>
            <navigationName>World</navigationName>
            <fileName>World.html</fileName>
            <syntax>
            public sealed class World : MonoBehaviour, <see cref="T:DeepSpaceLabs.SAM.IIdentifiable" href="IIdentifiable.html">IIdentifiable</see>
            </syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.World.CURRENT_EDITOR_VERSION">
            <summary>
            Current version of the the World for use in the editor.
            </summary>
            <type>int</type>
        </member>
        <member name="F:DeepSpaceLabs.SAM.World.PERSISTENT_DATA_VERSION">
            <summary>
            Current version of the world's persistent data.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.ActiveGridReCenteringAllowed">
            <summary>
            Gets a value indicating the 'Allow Active Grid Re-Centering' option is enabled in the inspector.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.AreColumnsEndless">
            <summary>
            Gets a value indicating whether the World's columns repeat to form an endless looping axis.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.AreLayersEndless">
            <summary>
            Gets a value indicating whether the World's layers repeat to form an endless looping axis.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.AreRowsEndless">
            <summary>
            Gets a value indicating whether the World's rows repeat to form an endless looping axis.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.ChunkManager">
            <summary>
            Gets the chunk manager assigned to this World's Default Chunk Manager field (if any). Remember that this manager 
            may be overriden on a per World Grouping basis or per LOD basis.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type link="ChunkManager.html">ChunkManager</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.ChunkStreamer">
            <summary>
            Gets the ChunkStreamer assigned to this World's Default Chunk Streamer field (if any). Remember that this manager 
            may be overriden on a per World Grouping basis or per LOD basis.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type link="ChunkStreamer.html">ChunkStreamer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.CreatedAtRuntime">
            <summary>
            Gets a value indicating whether the World was created at runtime. If false, it means the World was added 
            in the inspector by the dev (not as a prototype).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.EndingRow">
            <summary>
            The Ending Row of this World in reference to its World Grid. This is basically the largest row that any zone is in plus North Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.EndingColumn">
            <summary>
            The Ending Column of this World in reference to its World Grid. This is basically the largest column that any zone is in plus East Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.EndingLayer">
            <summary>
            The Ending Layer of this World in reference to its World Grid. This is basically the largest layer that any zone is in plus Top Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.HierarchyOrganizer">
            <summary>
            Gets the Hierarchy Organizer associated with the world, as assigned in the inspector.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type link="HierarchyOrganizer.html">HierarchyOrganizer</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.ID">
            <summary>
            Gets the unique ID of the World.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IDOfPrototypeConstructedFrom">
            <summary>
            Returns the Prototype this runtime created World was constructed from. If the world is an inspector 
            created World rather than a Runtime created one, this will return int.MinValue.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.InitialOriginCell">
            <summary>
            The initial Origin Cell (as set in the inspector of the World) of this World (in reference to the Base Grouping).
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IsExplicitOriginCellChangeBlocked">
            <summary>
            Gets a value indicating whether an explicit Origin Cell change is currently blocked (will block Origin Cell changes initiated via 
            LoadWorldRegion and ChangeOriginCell, so query this property before calling these methods if you want to ensure they succeed).
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IsSleeping">
            <summary>
            Gets a value indicating whether the world is sleeping (Update cycle not running).
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IsInitialized">
            <summary>
            Gets a value indicating whether the World has been initialized.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IsOriginCellUpdateInProgress">
            <summary>
            Gets a value indicating whether an Origin Cell Update (either explicit or a natural
            World Reset) is currently in progress. Does not return true if an update is queued; use 
            <see cref="P:DeepSpaceLabs.SAM.World.IsOriginCellUpdateQueuedOrInProgress" href="World.html#IsOriginCellUpdateQueuedOrInProgress">IsOriginCellUpdateQueuedOrInProgress</see> 
            if you need to know that.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IsOriginCellUpdateQueuedOrInProgress">
            <summary>
            Gets a value indicating if an Origin Cell Update is currently in progress or has been queued. If you 
            only want to know if an update is in progress, use 
            <see cref="P:DeepSpaceLabs.SAM.World.IsOriginCellUpdateInProgress" href="World.html#IsOriginCellUpdateInProgress">IsOriginCellUpdateInProgress</see> istead.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IsUpdateInProgress">
            <summary>
            Gets a value indicating whether a World update is in progress. This will return true 
            if WorldState is >= WorldState.PerformingSecondaryOperation.
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.IsWorldPersistent">
            <summary>
            Gets a value indicating whether the World is persistent between game sessions. Non prototype Worlds added in the 
            editor are always persistent!
            </summary>
            <type>bool</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.OriginCell">
            <summary>
            The current Origin Cell of the World, which will always be a Cell on the World's Grid.
            <para>Not valid until after the Component Manager has been initialized.</para>
            <para>
            Remember that the Origin Cell of Zone Groupings will not usually be the same as this value. You 
            can find out the Origin Cell of a Zone Grouping after the World has been initialized using the 
            <see cref="M:DeepSpaceLabs.SAM.World.GetOriginCellOfZoneGrouping(System.Int32,System.Int32)" href="#GetOriginCellOfZoneGrouping">GetOriginCellOfZoneGrouping</see> method.
            </para>
            </summary>
            <type link="Cell.html">Cell</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.OriginCellPosition">
            <summary>
            Gets the position of the Origin Cell (associated with World Grouping 1), which is always equal to the world origin configured 
            in the inspector (or the position of the game object the World is on if 'Use this Game Object's Positoin as World Origin Position' 
            is enabled.
            <para>Not valid until after the Component Manager has been initialized.</para>
            <para>
            Remember that the Origin Cell position of Sub Groupings (Groupings 2+) is not necessarily the same as this value. You 
            can find out the Origin Cell position of a Sub Grouping after the World has been initialized using the 
            <see cref="M:DeepSpaceLabs.SAM.World.GetOriginCellPositionOfZoneGrouping(System.Int32,System.Int32)" href="#GetOriginCellPositionOfWorldGrouping"></see> method.
            </para>
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.OriginCellPosition_PreInitSafe">
            <summary>
            Gets the position of the Origin Cell (associated with World Grouping 1), which is always equal to the world origin configured 
            in the inspector (or the position of the game object the World is on if 'Use this Game Object's Positoin as World Origin Position' 
            is enabled.
            <para>This can be used in the editor or at any other time when you are not sure if the World has been initialized. However, if you know 
            that the World has been initialized, use <see cref="P:DeepSpaceLabs.SAM.World.OriginCellPosition" href="#OriginCellPosition">OriginCellPosition</see> instead, as it is much faster!</para>
            <para>
            Remember that the Origin Cell position of Sub Groupings (Groupings 2+) is not necessarily the same as this value. You 
            can find out the Origin Cell position of a Sub Grouping after the World has been initialized using the 
            <see cref="M:DeepSpaceLabs.SAM.World.GetOriginCellPositionOfZoneGrouping(System.Int32,System.Int32)" href="#GetOriginCellPositionOfWorldGrouping"></see> method.
            </para>
            </summary>
            <type link="Vector3Double.html">Vector3Double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.OriginColumnPosition">
            <summary>
            The position of the Origin Cell column (associated with World Grouping 1). It will always be the x value of the OriginCellPosition.
            <para>Not valid until after the Component Manager has been initialized.</para>
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.OriginLayerPosition">
            <summary>
            The position of the Origin Cell layer (associated with World Grouping 1). For 3D and 2D XZ Base Groupings, it will be the y component of 
            the OriginCellPosition. For 2D XY Base Groupings, it will be the z component of the OriginCellPosition.
            <para>Not valid until after the Component Manager has been initialized.</para>
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.OriginRowPosition">
            <summary>
            The position of the Origin Cell row (associated with World Grouping 1). For 3D and 2D XZ Base Groupings, will be the z value of the 
            OriginCellPosition. For 2D XY Base Groupings, will be the y value of the OriginCellPosition.
            <para>Not valid until after the Component Manager has been initialized.</para>
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.StartingRow">
            <summary>
            The Starting Row of this World in reference to its World Grid. This is basically the smallest row that any zone is in minus South Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.StartingColumn">
            <summary>
            The Starting Column of this World in reference to its World Grid. This is basically the smallest column that any zone is in minus West Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.StartingLayer">
            <summary>
            The Starting Layer of this World in reference to its World Grid. This is basically the smallest layer that any zone is in minus Bottom Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.TotalRows">
            <summary>
            The Total Rows on this World in reference to its World Grid. This is equal to EndingRow - StartingRow + 1;
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.TotalColumns">
            <summary>
            The Total Column on this World in reference to its World Grid. This is equal to EndingColumn - StartingColumn + 1;
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.TotalLayers">
            <summary>
            The Total Layers on this World in reference to its World Grid. This is equal to EndingLayer - StartingLayer + 1;
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.EnabledZoneGroupings">
            <summary>
            Gets the number of enabled Zone Groupings. A Zone Grouping is Enabled if a Streamable Grid has been 
            assigned to the Zone Grouping Grid field on each Zone (via the World inspector), and if the Zone it is a part of is enabled.
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.WorldGroupings">
            <summary>
            Gets a value indicating how many World Groupings this world uses.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.WorldRegions">
            <summary>
            Gets the number of World Regions stored on this World.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.WorldLength">
            <summary>
            The length of the World as measured from its Starting Row to its Ending Row.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.WorldWidth">
            <summary>
            The width of the World as measured from its Starting Column to its Ending Column.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.WorldHeight">
            <summary>
            The height of the World as measured from its Starting Layer to its Ending Layer.
            </summary>
            <type>double</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.WorldSleepMode">
            <summary>
            Gets or Sets the World Sleep Mode used by this World. This controls under what conditions the World is put to sleep (see WorldSleepMode page for more info).
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type link="WorldSleepMode.html">WorldSleepMode</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.WorldState">
            <summary>
            Gets the Current WorldState of the World.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type link="WorldState.html">WorldState</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.Zones">
            <summary>
            Gets a value indicating how many Zones this world uses.
            <para>
            Pre Init Safe
            </para>
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.StartingRow_ZeroBased">
            <summary>
            The Starting Row of this World in reference to its World Grid. This is basically the smallest row that any zone is in minus South Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.StartingColumn_ZeroBased">
            <summary>
            The Starting Column of this World in reference to its World Grid. This is basically the smallest column that any zone is in minus West Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.StartingLayer_ZeroBased">
            <summary>
            The Starting Layer of this World in reference to its World Grid. This is basically the smallest layer that any zone is in minus Bottom Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.EndingRow_ZeroBased">
            <summary>
            The Ending Row of this World in reference to its World Grid. This is basically the largest row that any zone is in plus North Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.EndingColumn_ZeroBased">
            <summary>
            The Ending Column of this World in reference to its World Grid. This is basically the largest column that any zone is in plus East Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.World.EndingLayer_ZeroBased">
            <summary>
            The Ending Layer of this World in reference to its World Grid. This is basically the largest layer that any zone is in plus Top Gap Cells.
            </summary>
            <type>int</type>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ChangeOriginCell(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Changes the Origin Cell of the World. The update does not occur immediately but rather during the natural World Update cycle. If you need 
            to know when the world update containing the Origin Cell update has finished, you can register a callback method with the World via the 
            <see cref="M:DeepSpaceLabs.SAM.World.RegisterOnUserRequestsFulfilledCallback(System.Action{DeepSpaceLabs.SAM.World})" href="World.html#RegisterOnUserRequestsFulfilledCallback">RegisterOnUserRequestsFulfilledCallback</see> 
            method. The callback method will be invoked once the Origin Cell change has been completed.
            <para>
            In order to ensure the change can be made, you should query the 
            <see cref="P:DeepSpaceLabs.SAM.World.IsExplicitOriginCellChangeBlocked" href="World.html#IsExplicitOriginCellChangeBlocked">IsExplicitOriginCellChangeBlocked</see> 
            property and ensure it is false before calling the method. If you decide to forsake this strategy and the update fails, a warning message will be printed to the 
            console and the method will return false.
            </para>
            <para>
            Setting the Origin Cell manually may have unintended consequences, especially when using an Active Grid. Therefore, it is recommended for 
            advanced users only! Generally it is better to let the Active Grid change the Origin Cell, either automatically when the player crosses 
            a reset boundary, or manually as a result of one its other methods being called, like 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerAndChangeOriginCellOfWorld(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Double,System.Boolean)" href="ActiveGrid.html#TryMovePlayerAndChangeOriginCellOfWorld">TryMovePlayerAndChangeOriginCellOfWorld</see>
            </para>
            </summary>
            <param name="newOriginCell" type="Cell" link="Cell.html">
            The new Origin Cell.
            </param>
            <returns type="bool">
            True if Origin Cell will be changed, false otherwise. If true, remember that the actual change does not occur immediately, but rather 
            will be caried out during a normal World update cycle.
            </returns>
            <displayName id="ChangeOriginCell">
            ChangeOriginCell(Cell)
            </displayName>
            <syntax>
            public bool ChangeOriginCell(Cell newOriginCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.Register(DeepSpaceLabs.SAM.IWorldUser,System.Int32@)">
            <summary>
            Register an IWorldUser user with the World. Users may register in order to receive callbacks when the Origin Cell is 
            changed or clamped, when the World is destroyed, or if they need to delay Origin Cell changes. 
            See the <see cref="T:DeepSpaceLabs.SAM.IWorldUser" href="IWorldUser.html">IWorldUser</see> page for more information.
            </summary>
            <param name="user" type="IWorldUser" link="IWorldUser.html">
            The user to register.
            </param>
            <param name="registrationID" type="int">
            An ID that is assigned to the user upon registration. You must store this ID so that you can pass it into the 
            <see cref="M:DeepSpaceLabs.SAM.World.DeRegister(System.Int32)" href="#DeRegister">DeRegister</see> method later (if you plan on de-registering as a World User).
            </param>
            <displayName id="Register">
            Register(IWorldUser, out int)
            </displayName>
            <syntax>
            public void Register(IWorldUser user, out int registrationID)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.DeRegister(System.Int32)">
            <summary>
            Deregister a World User from the World. Note that if the user is Currently "prepared" for an 
            Origin Cell change, they will NOT receive notification from the World once the Origin Cell change is completed.
            </summary>
            <param name="registrationID" type="int">The ID of the user that should be de registered. This ID was 
            assigned to you when you registered with the World via the <see cref="M:DeepSpaceLabs.SAM.World.Register(DeepSpaceLabs.SAM.IWorldUser,System.Int32@)" href="#Register">Register</see> method.</param>
            <displayName id="DeRegister">DeRegister(int)</displayName>
            <syntax>public void DeRegister(int registrationID)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetWorldRegionName_PreInitSafe(System.Int32)">
            <summary>
            Gets the name of the World Region whose number in the World inspector matches the worldRegionNumber passed in. For performance 
            reasons this method does not do any error checking, therefore please be absolutely sure that the number passed in is valid (not less than 1 
            and not greater than the number of World Regions on this world).
            </summary>
            <param name="worldRegionNumber" type="int">
            The number of the World Region whose name you want to retrieve (you can find this number in the World Inspector, before each World Region Name).
            </param>
            <returns type="string">
            The name of the World Region.
            </returns>
            <displayName id="GetWorldRegionName">
            GetWorldRegionName(int)
            </displayName>
            <syntax>
            public string GetWorldRegionName(int worldRegionNumber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetWorldRegionOriginCell_PreInitSafe(System.Int32)">
            <summary>
            Gets the one based Origin Cell of the World Region whose number in the World inspector matches the worldRegionNumber passed in. For performance 
            reasons this method does not do any error checking, therefore please be absolutely sure that the number passed in is valid (not less than 1 
            and not greater than the number of World Regions on this world).
            </summary>
            <param name="worldRegionNumber" type="int">
            The number of the World Region whose Origin Cell you want to retrieve (you can find this number in the World Inspector, before each World Region Name).
            </param>
            <returns type="Cell" link="Cell.html">
            The Origin Cell of the World Region.
            </returns>
            <displayName id="GetWorldRegionOriginCell">
            GetWorldRegionOriginCell(int)
            </displayName>
            <syntax>
            public Cell GetWorldRegionOriginCell(int worldRegionNumber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.LoadWorldRegion(System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Loads the World Region matching the input worldRegionNumber.
            <para>
            This method will not give you any insight into when the cells are actually loaded. If you need 
            to know when the World has processed the World Region and updated itself to reflect changes resulting from the 
            World Region being loaded, you can register a callback method with the World via the 
            <see cref="M:DeepSpaceLabs.SAM.World.RegisterOnUserRequestsFulfilledCallback(System.Action{DeepSpaceLabs.SAM.World})" href="World.html#RegisterOnUserRequestsFulfilledCallback">RegisterOnUserRequestsFulfilledCallback</see> 
            method. The callback method will be invoked once the World has completed an update cycle containing changes that resulted from the load operation.
            </para>
            <para>
            This strategy also allows you to load and unload multiple regions in one World Update cycle, and be notified when all regions are loaded and/or 
            unloaded. To do so, simply call the LoadWorldRegion and UnloadWorldRegion methods for each region that you want to load or 
            unload before calling the WaitForUpdateThatIncludesRequests method (all must be called in the same frame).
            </para>
            </summary>
            <param name="worldRegionNumber" type="int">
            The number of the World Region to load (you can find this number in the World Inspector, before each World Region Name).
            </param>
            <param name="changeOriginCell" type="bool">
            If true, an attempt will be made to set the Origin Cell of the World to the Origin Cell set in the World Region. If false, the Origin Cell will 
            remain what it currently is. Note that while using this method, the change operation may fail for several different reasons.
            <para>
            In order to ensure the change is successful, you should query the 
            <see cref="P:DeepSpaceLabs.SAM.World.IsExplicitOriginCellChangeBlocked" href="World.html#IsExplicitOriginCellChangeBlocked">IsExplicitOriginCellChangeBlocked</see> 
            property and ensure it is false before calling the method. If you decide to forsake this strategy and the change fails, a warning message will be printed to the 
            console.
            </para>
            <para>
            If the Origin Cell change can be changed, note that the actual change does not occur until the next natural World Update. Between this method call and the 
            World Update, it is possible for the Origin Cell change to be overwritten if LoadWorldRegion, ChangeOriginCell, or some other methods that explicitly changes the 
            Origin Cell are called.
            </para>
            </param>
            <param name="clearLoadedWorldRegions" type="bool">
            If true, any World Regions loaded previously (including auto-loaded ones) will be unloaded during the same World Update that loads the new World Region.
            </param>
            <displayName id="LoadWorldRegion1">
            LoadWorldRegion(int, bool, bool)
            </displayName>
            <syntax>
            public void LoadWorldRegion(int worldRegionNumber, bool changeOriginCell, bool clearLoadedWorldRegions)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when worldRegionNumber is not valid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.LoadWorldRegion(System.String,System.Boolean,System.Boolean)">
            <summary>
            Loads the World Region matching the input worldRegionName.
            <para>
            This method will not give you any insight into when the cells are actually loaded. If you need 
            to know when the World has processed the World Region and updated itself to reflect changes resulting from the 
            World Region being loaded, you can register a callback method with the World via the 
            <see cref="M:DeepSpaceLabs.SAM.World.RegisterOnUserRequestsFulfilledCallback(System.Action{DeepSpaceLabs.SAM.World})" href="World.html#RegisterOnUserRequestsFulfilledCallback">RegisterOnUserRequestsFulfilledCallback</see> 
            method. The callback method will be invoked once the World has completed an update cycle containing changes that resulted from the load operation.
            </para>
            <para>
            This strategy also allows you to load and unload multiple regions in one World Update cycle, and be notified when all regions are loaded and/or 
            unloaded. To do so, simply call the LoadWorldRegion and UnloadWorldRegion methods for each region that you want to load or 
            unload before calling the WaitForUpdateThatIncludesRequests method (all must be called in the same frame).
            </para>
            </summary>
            <param name="worldRegionName" type="string">
            The name of the World Region to load.
            </param>
            <param name="changeOriginCell" type="bool">
            If true, an attempt will be made to set the Origin Cell of the World to the Origin Cell set in the World Region. If false, the Origin Cell will 
            remain what it currently is. Note that while using this method, the change operation may fail for several different reasons.
            <para>
            In order to ensure the change is successful, you should query the 
            <see cref="P:DeepSpaceLabs.SAM.World.IsExplicitOriginCellChangeBlocked" href="World.html#IsExplicitOriginCellChangeBlocked">IsExplicitOriginCellChangeBlocked</see> 
            property and ensure it is false before calling the method. If you decide to forsake this strategy and the change fails, a warning message will be printed to the 
            console.
            </para>
            <para>
            If the Origin Cell change can be changed, note that the actual change does not occur until the next natural World Update. Between this method call and the 
            World Update, it is possible for the Origin Cell change to be overwritten if LoadWorldRegion, ChangeOriginCell, or some other methods that explicitly changes the 
            Origin Cell are called.
            </para>
            </param>
            <param name="clearLoadedWorldRegions" type="bool">
            If true, any World Regions loaded previously (including auto-loaded ones) will be unloaded during the same World Update that loads the new World Region.
            </param>
            <displayName id="LoadWorldRegion2">
            LoadWorldRegion(string, bool, bool)
            </displayName>
            <syntax>
            public void LoadWorldRegion(string worldRegionName, bool changeOriginCell, bool clearLoadedWorldRegions)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when worldRegionName is not valid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.UnloadWorldRegion(System.Int32)">
            <summary>
            Unloads the World Region matching the input worldRegionNumber.
            <para>
            This method will not give you any insight into when the cells are actually unloaded. If you need 
            to know when the World has processed the World Region and updated itself to reflect changes resulting from the 
            World Region being unloaded, you can register a callback method with the World via the 
            <see cref="M:DeepSpaceLabs.SAM.World.RegisterOnUserRequestsFulfilledCallback(System.Action{DeepSpaceLabs.SAM.World})" href="World.html#RegisterOnUserRequestsFulfilledCallback">RegisterOnUserRequestsFulfilledCallback</see> 
            method. The callback method will be invoked once the World has completed an update cycle containing changes that resulted from the unload operation.
            </para>
            <para>
            This strategy also allows you to load and unload multiple regions in one World Update cycle, and be notified when all regions are loaded and/or 
            unloaded. To do so, simply call the LoadWorldRegion and UnloadWorldRegion methods for each region that you want to load or 
            unload before calling the WaitForUpdateThatIncludesRequests method.
            </para>
            </summary>
            <param name="worldRegionNumber" type="int">
            The number of the World Region to unload (you can find this number in the World Inspector, before each World Region Name).
            </param>
            <displayName id="UnloadWorldRegion1">
            UnloadWorldRegion(int)
            </displayName>
            <syntax>
            public void UnloadWorldRegion(int worldRegionNumber)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.UnloadWorldRegion(System.String)">
            <summary>
            Unloads the cells in the World Region matching the input worldRegionName.
            <para>
            This method will not give you any insight into when the cells are actually unloaded. If you need 
            to know when the World has processed the World Region and updated itself to reflect changes resulting from the 
            World Region being unloaded, you can register a callback method with the World via the 
            <see cref="M:DeepSpaceLabs.SAM.World.RegisterOnUserRequestsFulfilledCallback(System.Action{DeepSpaceLabs.SAM.World})" href="World.html#RegisterOnUserRequestsFulfilledCallback">RegisterOnUserRequestsFulfilledCallback</see> 
            method. The callback method will be invoked once the World has completed an update cycle containing changes that resulted from the unload operation.
            </para>
            <para>
            This strategy also allows you to load and unload multiple regions in one World Update cycle, and be notified when all regions are loaded and/or 
            unloaded. To do so, simply call the LoadWorldRegion and UnloadWorldRegion methods for each region that you want to load or 
            unload before calling the WaitForUpdateThatIncludesRequests method.
            </para>
            </summary>
            <param name="worldRegionName" type="string">
            The name of the World Region to unload.
            </param>
            <displayName id="UnloadWorldRegion2">
            UnloadWorldRegion(string)
            </displayName>
            <syntax>
            public void UnloadWorldRegion(string worldRegionName)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.RegisterOnUserRequestsFulfilledCallback(System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            You can use this method to register a callback method that will be invoked after any outside requests to 
            add/remove users (including loading/unloading World Regions) or change the Origin Cell have been fulfilled by the World. Basically, once a World Updated 
            is completed that has taken into account the requests or Origin Cell change, the callback will be invoked.
            <para>
            In order to use the method for that use case, it is imperative that you call this method immediately after 
            sending in all add/remove requests (using AddCellUsers and RemoveCellUsers), load world region calls, or change the Origin Cell, 
            within the same frame. Otherwise there is no gaurantee 
            that the method will be able to track the update that includes those requests.
            </para>
            <para>
            When used correctly, the callback will only be invoked once a World update including the add/remove requests and/or origin 
            cell change has been run, or after processing the add/remove requests and the World determines no World Update is needed.
            </para>
            <para>
            This use case is also a replacement for the 
            AddCellUsersAndWaitForChunksToBeLoaded and RemoveChunksAndWaitForChunksToBeUnloaded
            methods that were previously present.
            </para>
            </summary>
            <param name="OnRequestsFulfilledCallback" type="Action&lt;World&gt;">
            The callback that will be invoked once the requests have been fulfilled.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="RegisterOnUserRequestsFulfilledCallback">
            RegisterOnUserRequestsFulfilledCallback(Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void RegisterOnUserRequestsFulfilledCallback(Action&lt;World&gt; OnRequestsFulfilledCallback)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.AddCellUsers(System.Collections.Generic.IList{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sends in a request to add users to the list of specified cells. This method should only be used by 
            advanced users, as in 99% of cases you should let the Active Grid class control the addition of 
            cell users. If you do decide to use this method, keep the following in mind:
            <para>
            The World tallies all user requests (either add or remove) for World Cells. If the Active Grid sends in an add requests 
            for a specific cell, then you send in an add requests for the same cell, a tally of 2 will exists for the cell. The cell 
            is then loaded and will not be unloaded until the tally reaches 0. In this way, multiple users can lay claim to a cell, 
            and rather than loading that cell multiple times, it is only loaded once.
            </para>
            <para>
            This strategy introduces errors if you do not keep track of the users you have added to a cell, however. For every user you add, 
            you will typically want to remove a user for the same cell at a later time. If you do not, the cell will likely never be unloaded.
            </para>
            </summary>
            <param name="cells" type="IList&lt;Cell&gt;" link="Cell.html">
            The list of cells to add users to.
            </param>
            <param name="zoneIndex">
            The index of the Zone the cells are associated with.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping the cells are associated with.
            </param>
            <param name="lodIndex" type="int"> 
            The index of the LOD the cells are associated with.
            </param>
            <displayName id="AddCellUsers1">
            AddCellUsers(IList&lt;Cell&gt;, int, int, int)
            </displayName>
            <syntax>
            public void AddCellUsers(IList&lt;Cell&gt; cells, int zoneIndex, int groupingIndex, int lodIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called while the world is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the groupingIndex or lodIndex passed in are invalid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.AddCellUsers(System.Collections.Generic.IList{DeepSpaceLabs.SAM.LODCell},System.Int32,System.Int32)">
            <summary>
            Sends in a request to add users to the list of specified cells, in the form of a list of 
            <see cref="T:DeepSpaceLabs.SAM.LODCell" href="LODCell.html">LODCells</see>. 
            This method should only be used by advanced users, as in 99% of cases you should let the Active Grid 
            class control the addition of cell users. If you do decide to use this method, keep the following in mind:
            <para>
            The World tallies all user requests (either add or remove) for World Cells. If the Active Grid sends in an add requests 
            for a specific cell, then you send in an add requests for the same cell, a tally of 2 will exists for the cell. The cell 
            is then loaded and will not be unloaded until the tally reaches 0. In this way, multiple users can lay claim to a cell, 
            and rather than loading that cell multiple times, it is only loaded once.
            </para>
            <para>
            This strategy introduces errors if you do not keep track of the users you have added to a cell, however. For every user you add, 
            you will typically want to remove a user for the same cell at a later date. If you do not, the cell will likely never be unloaded.
            </para>
            </summary>
            <param name="cells" type="IList&lt;LODCell&gt;" link="LODCell.html">
            The list of LOD cells to add users to.
            </param>
            <param name="zoneIndex">
            The index of the Zone the cells are associated with.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping the cells are associated with.
            </param>
            <displayName id="AddCellUsers2">
            AddCellUsers(IList&lt;LODCell&gt;, int, int)
            </displayName>
            <syntax>
            public void AddCellUsers(IList&lt;LODCell&gt; cells, int zoneIndex, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called while the world is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the groupingIndex passed in is invalid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.AddCellUsers(System.Collections.Generic.IList{DeepSpaceLabs.SAM.ZoneGroupingLODCell})">
            <summary>
            Sends in a request to add World Cell users for the passed in cells, in the form of a list of 
            <see cref="T:DeepSpaceLabs.SAM.ZoneGroupingLODCell" href="WorldGroupingCell.html">WorldGroupingCells</see>. 
            This method should only be used by advanced users, as in 99% of cases you should let the Active Grid 
            class control the addition of cell users. If you do decide to use this method, keep the following in mind:
            <para>
            The World tallies all user requests (either add or remove) for World Cells. If the Active Grid sends in an add requests 
            for a specific cell, then you send in an add requests for the same cell, a tally of 2 will exists for the cell. The cell 
            is then loaded and will not be unloaded until the tally reaches 0. In this way, multiple users can lay claim to a cell, 
            and rather than loading that cell multiple times, it is only loaded once.
            </para>
            <para>
            This strategy introduces errors if you do not keep track of the users you have added to a cell, however. For every user you add, 
            you will typically want to remove a user for the same cell at a later date. If you do not, the cell will likely never be unloaded.
            </para>
            <para>
            Please note, to save on performance, no error checking is done on the passed in Zone Indexes, World Grouping or LOD indexes, so please be sure 
            that those values are valid!
            </para>
            </summary>
            <param name="cells" type="IList&lt;WorldGroupingCell&gt;" link="WorldGroupingCell.html">
            The list of cells to add World Cell users to.
            </param>
            <displayName id="AddCellUsers3">
            AddCellUsers(IList&lt;WorldGroupingCell&gt;)
            </displayName>
            <syntax>
            public void AddCellUsers(IList&lt;WorldGroupingCell&gt; cells)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called while the world is in the process of being destroyed.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.RemoveCellUsers(System.Collections.Generic.IList{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Int32)">
            <summary>
            Sends in a request to remove users from the list of specified cells. 
            This method should only be used by 
            advanced users, as in 99% of cases you should let the Active Grid class control the removal of 
            cell users. If you do decide to use this method, keep the following in mind:
            <para>
            The World tallies all user requests (either add or remove) for World Cells. If the Active Grid sends in an add requests 
            for a specific cell, then you send in an add requests for the same cell, a tally of 2 will exists for the cell. The cell 
            is then loaded and will not be unloaded until the tally reaches 0. In this way, multiple users can lay claim to a cell, 
            and rather than loading that cell multiple times, it is only loaded once.
            </para>
            <para>
            This strategy introduces errors if you do not keep track of the users you have added to a cell, however. For every user you add, 
            you will typically want to remove a user for the same cell at a later date. If you do not, the cell will likely never be unloaded.
            </para>
            </summary>
            <param name="cells" type="IList&lt;Cell&gt;" link="Cell.html">
            The list of cells to remove users from.
            </param>
            <param name="zoneIndex">
            The index of the Zone the cells are associated with.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping to remove cell users for.
            </param>
            <param name="lodIndex" type="int"> 
            The index of the LOD to remove cells users for.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="RemoveCellUsers1">
            RemoveCellUsers(IList&lt;Cell&gt;, int, int, int)
            </displayName>
            <syntax>
            public void RemoveCellUsers(IList&lt;Cell&gt; cells, int zoneIndex, int groupingIndex, int lodIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called while the world is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the groupingIndex or lodIndex passed in are invalid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.RemoveCellUsers(System.Collections.Generic.IList{DeepSpaceLabs.SAM.LODCell},System.Int32,System.Int32)">
            <summary>
            Sends in a request to remove users from the list of specified cells in the form of 
            <see cref="T:DeepSpaceLabs.SAM.LODCell" href="LODCell.html">LODCells</see>. 
            This method should only be used by 
            advanced users, as in 99% of cases you should let the Active Grid class control the removal of 
            cell users. If you do decide to use this method, keep the following in mind:
            <para>
            The World tallies all user requests (either add or remove) for World Cells. If the Active Grid sends in an add requests 
            for a specific cell, then you send in an add requests for the same cell, a tally of 2 will exists for the cell. The cell 
            is then loaded and will not be unloaded until the tally reaches 0. In this way, multiple users can lay claim to a cell, 
            and rather than loading that cell multiple times, it is only loaded once.
            </para>
            <para>
            This strategy introduces errors if you do not keep track of the users you have added to a cell, however. For every user you add, 
            you will typically want to remove a user for the same cell at a later date. If you do not, the cell will likely never be unloaded.
            </para>
            </summary>
            <param name="cells" type="IList&lt;LODCell&gt;" link="LODCell.html">
            The list of cells to remove users from.
            </param>
            <param name="zoneIndex">
            The index of the Zone the cells are associated with.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping to remove cell users for.
            </param>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
            <displayName id="RemoveCellUsers2">
            RemoveCellUsers(IList&lt;LODCell&gt;, int, int)
            </displayName>
            <syntax>
            public void RemoveCellUsers(IList&lt;LODCell&gt; cells, int zoneIndex, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called while the world is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown if the groupingIndex passed in is invalid.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.RemoveCellUsers(System.Collections.Generic.IList{DeepSpaceLabs.SAM.ZoneGroupingLODCell})">
            <summary>
            Sends in a request to remove users from the list of specified cells, in the form of 
            <see cref="T:DeepSpaceLabs.SAM.ZoneGroupingLODCell" href="WorldGroupingCell.html">WorldGroupingCells</see>. 
            This method should only be used by advanced users, as in 99% of cases you should let the Active Grid 
            class control the removal of cell users. If you do decide to use this method, keep the following in mind:
            <para>
            The World tallies all user requests (either add or remove) for World Cells. If the Active Grid sends in an add requests 
            for a specific cell, then you send in an add requests for the same cell, a tally of 2 will exists for the cell. The cell 
            is then loaded and will not be unloaded until the tally reaches 0. In this way, multiple users can lay claim to a cell, 
            and rather than loading that cell multiple times, it is only loaded once.
            </para>
            <para>
            This strategy introduces errors if you do not keep track of the users you have added to a cell, however. For every user you add, 
            you will typically want to remove a user for the same cell at a later date. If you do not, the cell will likely never be unloaded.
            </para>
            <para>
            Please note, to save on performance, no error checking is done on the passed in Zone Indexes, World Grouping or LOD indexes, so please be sure 
            that those values are valid!
            </para>
            </summary>
            <param name="cells" type="IList&lt;WorldGroupingCell&gt;" link="WorldGroupingCell.html">
            The list of cells to remove users from.
            </param>
            <displayName id="RemoveCellUsers3">
            RemoveCellUsers(IList&lt;WorldGroupingCell&gt;)
            </displayName>
            <syntax>
            public void RemoveCellUsers(IList&lt;WorldGroupingCell&gt; cells)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown if the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown if the method is called while the world is in the process of being destroyed.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.AddWorldGroupingListener_PreInitSafe(DeepSpaceLabs.SAM.IWorldGroupingListener,System.Int32)">
            <summary>
            Adds the IWorldGroupingListener to the World Grouping indicated by groupingIndex.  Listeners are added/removed on a per Grouping basis, not a per 
            Zone Grouping basis, so when you add/remove a listener for a World Grouping, all Zones that contain a valid Streamable Grid for that Grouping 
            will have the listener added/removed.
            <para>
            DetermineMethodCalls and PrecomputeUseWithLODValues are called automatically when using this method.
            </para>
            </summary>
            <param name="groupingListener" type="IWorldGroupingListener" link="IWorldGroupingListener.html">
            The World Grouping listener to add.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping to add the World Grouping listener to. If you want to add the listener to multiple World Groupings, 
            call this method multiple times, once for each World Grouping.
            </param>
            <displayName id="AddWorldGroupingListener">
            AddWorldGroupingListener(IWorldGroupingListener, int)
            </displayName>
            <syntax>
            public void AddWorldGroupingListener(IWorldGroupingListener groupingListener, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.RemoveWorldGroupingListener(DeepSpaceLabs.SAM.IWorldGroupingListener,System.Int32)">
            <summary>
            Removes the IWorldGroupingListener from the World Grouping indicated by groupingIndex. Listeners are added/removed on a per Grouping basis, not a per 
            Zone Grouping basis, so when you add/remove a listener for a World Grouping, all Zones that contain a valid Streamable Grid for that Grouping 
            will have the listener added/removed.
            <para>
            Removing Listeners can only be achieved after the World has been initialized. You can use this to remove either 
            runtime added Listeners or Listeners added in the World inspector in the editor.
            </para>
            </summary>
            <param name="groupingListener" type="IWorldGroupingListener" link="IWorldGroupingListener.html">
            The World Grouping listener to remove.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping to remove the World Grouping listener from. If you have added the listener to multiple World Groupings 
            on this World, call this method multiple times, once for each World Grouping.
            </param>
            <displayName id="RemoveWorldGroupingListener">
            RemoveWorldGroupingListener(IWorldGroupingListener, int)
            </displayName>
            <syntax>
            public void RemoveWorldGroupingListener(IWorldGroupingListener groupingListener, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetGroupingName_PreInitSafe(System.Int32)">
            <summary>
            Gets the name of a World Grouping as set in the inspector.
            </summary>
            <param name="groupingIndex" type="int">
            The one based index of the World Grouping, as shown in the World's inspector.
            </param>
            <displayName id="GetGroupingName_PreInitSafe">
            GetGroupingName_PreInitSafe(int)
            </displayName>
            <syntax>
            public string GetGroupingName_PreInitSafe(int groupingIndex)
            </syntax>
            <returns type="string">
            The name of the Grouping (as set in the inspector).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetAllLoadedWorldCellsForWorldGrouping(System.Int32,System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            Adds all loaded World Cells across all Zones for the specified World Grouping to the passed in addCellsTo list.
            <para>
            Note that this method gets the currently loaded World Cells as contained in each Zone  
            Grouping's internal dictionary. If a Zone Grouping is in the process of being updated, the World Cells' 
            state cannot be predicted (they may be missing Asset Chunks, or those Asset Chunks may be in a state 
            you do not expect, for example).
            </para>
            <para>
            As such, it is usually best to call this method only when the World is not currently being updated, which 
            you can check using the 
            <see cref="P:DeepSpaceLabs.SAM.World.IsUpdateInProgress" href="World.html#IsUpdateInProgress">IsUpdateInProgress</see> property.
            </para>
            <para>
            However, the best approach for tracking World Cells is to use a 
            <see cref="T:DeepSpaceLabs.SAM.IWorldGroupingListener" href="IWorldGroupingListener.html">World Grouping Listener</see>, as you can 
            be confident about the state of the World Cells (depending on which method you use for the tracking), and can 
            accurately track when World Cells are added and removed.
            </para>
            <para>
            World Cells returned via this method can be removed at a moments notice, so you should only make use of them 
            for a very short period of time.
            </para>
            </summary>
            <param name="groupingIndex" type="int">
            The index of the World Grouping whose World Cells you wish to get.
            </param>
            <param name="addCellsTo" type="List&lt;WorldCell&gt;" link="WorldCell.html">
            The list to add the World Cells to. The list is not cleared automatically, so you will 
            likely want to make sure it is empty before calling this method.
            </param>
            <displayName id="GetAllLoadedWorldCellsForWorldGrouping">
            GetAllLoadedWorldCellsForWorldGrouping(int, List&lt;WorldCell&gt;)
            </displayName>
            <syntax>
            public void GetAllLoadedWorldCellsForWorldGrouping(int groupingIndex, List&lt;WorldCell&gt; addCellsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetAxesTypeUsedByWorldGrouping(System.Int32)">
            <summary>
            Gets the Axes Type used by a particular World Grouping. This just finds the First Streamable Grid for the Grouping across all Zones, and returns 
            its Axes type. This is only possible because all Streamable Grids for a World Grouping must have the same Axes type across all Zones.
            </summary>
            <param name="groupingIndex" type="int">
            The index of the World Grouping.
            </param>
            <displayName id="GetAxesTypeUsedByWorldGrouping">
            GetAxesTypeUsedByWorldGrouping(int)
            </displayName>
            <syntax>
            public Axes GetAxesTypeUsedByWorldGrouping(int groupingIndex)
            </syntax>
            <returns type="Axes" link="Axes.html">
            The Axes type of the World Grouping.
            </returns>
            <exception name="MissingAssetException">
            Thrown if no Streamable Grids have been assigned to this World Grouping (across all Zones).
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetIndexOfWorldGroupingUsingID_PreInitSafe(System.Int32)">
            <summary>
            Gets the current index of the World Grouping identified by the groupingID passed in.
            </summary>
            <param name="groupingID" type="int">
            The ID of the World Grouping.
            </param>
            <displayName id="GetIndexOfWorldGroupingUsingID_PreInitSafe">
            GetIndexOfWorldGroupingUsingID_PreInitSafe(int)
            </displayName>
            <syntax>
            public int GetIndexOfWorldGroupingUsingID_PreInitSafe(int groupingID)
            </syntax>
            <returns type="int">
            The index of the World Grouping on this World (as shown in the inspector).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.DetermineZoneGroupingOriginCellFromWorldOriginCell_PreInitSafe(System.Int32,System.Int32,DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Vector3Double@)">
            <summary>
            Can be used to determine what Origin Cell a Zone Grouping would have if the Origin Cell of the World were changed to the 
            theoreticalOriginCell.
            <para>
            The Zone Grouping Origin Cell is always the Endless Grid Cell on the Zone Grouping that is closest to the Origin Position of the World. Note 
            that it is possibe for multiple Endless Grid Cells on the Zone Grouping to be the same distance from the Origin Position. In these cases, 
            usually the Cell with the smallest position is used.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The one based index of the Zone you are interested in.
            </param>
            <param name="groupingIndex" type="int">
            The one based index of the World Grouping you are interested in.
            </param>
            <param name="theoreticalWorldOriginCell" type="int">
            The one based theoretical Origin Cell of the World to use in the calculation of the Zone Grouping Origin Cell.
            </param>
            <param name="zoneGroupingOriginCellPosition" type="out Vector3Double" link="Vector3Double.html">
            The position of the Zone Grouping Origin Cell within the scene.
            </param>
            <returns type="Cell" link="Cell.html">
            The one based Zone Grouping Origin Cell as determined by the method.
            </returns>
            <displayName id="DetermineZoneGroupingOriginCellFromWorldOriginCell_PreInitSafe">
            DetermineZoneGroupingOriginCellFromWorldOriginCell_PreInitSafe(int, int, Cell, out Vector3Double)
            </displayName>
            <syntax>
            public Cell DetermineZoneGroupingOriginCellFromWorldOriginCell_PreInitSafe(int zoneIndex, int groupingIndex, Cell theoreticalWorldOriginCell, out Vector3Double zoneGroupingOriginCellPosition)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.IsZoneGrouping3D_PreInitSafe(System.Int32,System.Int32)">
            <summary>
            Can be used to query whether a particular Zone Grouping is three dimensional (it's Streamable Grid uses the 
            <see cref="F:DeepSpaceLabs.SAM.Axes.Three_Dimensional">Three_Dimensional</see> Axes type). This method will throw an exception if no Streamable Grid 
            has been assigned to the Zone Grouping!
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone to query.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping to query.
            </param>
            <returns type="bool">True if the World Grouping is 3D, false otherwise.</returns>
            <displayName id="IsZoneGrouping3D_PreInitSafe">
            IsZoneGrouping3D_PreInitSafe(int, int)
            </displayName>
            <syntax>
            public bool IsZoneGrouping3D_PreInitSafe(int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.IsZoneGroupingEnabled_PreInitSafe(System.Int32,System.Int32)">
            <summary>
            Checks whether a Zone Grouping is enabled. Can be used when you know the Zone Index and Grouping Index of a Zone Grouping, but do not know 
            if a Streamable Grid has been assigned to the Zone for the particular World Grouping, or whether the Zone has been disabled via the inspector.
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping.
            </param>
            <displayName id="IsZoneGroupingEnabled_PreInitSafe">
            IsZoneGroupingEnabled_PreInitSafe(int, int)
            </displayName>
            <syntax>
            public bool IsZoneGroupingEnabled_PreInitSafe(int zoneIndex, int groupingIndex)
            </syntax>
            <returns type="bool">
            True if a Streamable Grid has been assigned to the Zone for the input Grouping and the Zone is enabled (via the inspector), false otherwise. Also false if the World has not been initialized.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetStreamableGridOfZoneGrouping_PreInitSafe(System.Int32,System.Int32)">
            <summary>
            Gets the Streamable Grid associated with a specific Zone Grouping.
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone that contains the Streamable Grid you are trying to get.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping whose Streamable Grid you are trying to get.
            </param>
            <returns type="StreamableGrid" link="StreamableGrid.html">
            The Streamable Grid associated with the World Grouping.
            </returns>
            <displayName id="GetStreamableGridOfZoneGrouping_PreInitSafe">
            GetStreamableGridOfZoneGrouping_PreInitSafe(int, int)
            </displayName>
            <syntax>
            public StreamableGrid GetStreamableGridOfZoneGrouping_PreInitSafe(int zoneGrouping, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.IsZoneGroupingUpdatingCells(System.Int32,System.Int32)">
            <summary>
            Queries the World to determine if the given Zone Grouping is currently performing an update to its collection of World Cells. Generally speaking, methods that 
            retrieve World Cells from this World should only be performed for Zone Groupings that this method returns false for. Otherwise, the cell you are trying to 
            retrieve may have been removed from the Worlds internal collection of cells, even though it still 'appears' in the scene, or the cell may have not been 
            fully loaded yet, meaning the cell is retrievable even though it might not 'appear' in the scene. When the value returns true, it means all cells belonging 
            to the given Zone Grouping that exist in the internal collection of cells are in their correct state, and all cells appearing in the scene are correctly 
            contained within the World's internal collection of cells.
            <para>
            Rather than retrieving World Cells directly from the World, however, we recommend using 
            <see cref="T:DeepSpaceLabs.SAM.WorldGroupingListener" href="WorldGroupingListener.html">World Grouping Listeners</see>, as you can 
            be more assured of the World Cells' status.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone to run the query on.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping to run the query on.
            </param>
            <returns type="bool">
            See summary above.
            </returns>
            <displayName id="IsZoneGroupingUpdatingCells">
            IsZoneGroupingUpdatingCells(int, int)
            </displayName>
            <syntax>
            public bool IsZoneGroupingUpdatingCells(int zoneGrouping, int grouping)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetOriginCellOfZoneGrouping(System.Int32,System.Int32)">
            <summary>
            Gets the current Origin Cell of the Zone Grouping associated with the zoneIndex and groupingIndex. 
            Each Origin Cell is the closest Endless Grid Cell to the Origin Position that belongs to the Zone Grouping.
            </summary>
            <param name="zoneIndex" type="int">
            The one based index of the Zone, as shown in the World's inspector.
            </param>
            <param name="groupingIndex" type="int">
            The one based index of the World Grouping, as shown in the World's inspector.
            </param>
            <returns type="Cell" link="Cell.html">
            The one based Origin Cell of the World Grouping.
            </returns>
            <displayName id="GetOriginCellOfZoneGrouping">
            GetOriginCellOfZoneGrouping(int, int)
            </displayName>
            <syntax>
            public Cell GetOriginCellOfZoneGrouping(int zoneIndex, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetOriginCellPositionOfZoneGrouping(System.Int32,System.Int32)">
            <summary>
            Gets the current Origin Cell Position of the Zone Grouping. Note that the World's Origin Cell Position will be equal to either the 
            position of the game object the World is on, or the position set in the World's inspector. The Origin Cell Position of Zone Groupings may be equal to 
            this same position, or it may be different, as there is no gaurantee that a Cell from the Zone Grouping lines up perfectly with the Origin Cell. In 
            these circumstances, SAM uses the closest Endless Grid Cell from the Zone Grouping (to the World's Origin Position).
            </summary>
            <param name="zoneIndex" type="int">
            The one based index of the Zone, as shown in the World's inspector.
            </param>
            <param name="groupingIndex" type="int">
            The one based index of the World Grouping, as shown in the World's inspector.
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The Origin Cell position of the World Grouping.
            </returns>
            <displayName id="GetOriginCellPositionOfZoneGrouping">
            GetOriginCellPositionOfZoneGrouping(int, int)
            </displayName>
            <syntax>
            public Vector3Double GetOriginCellPositionOfZoneGrouping(int zoneIndex, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetLODGroupName(System.Int32,System.Int32,System.Int32)">
            <summary>
            Gets the name of the LOD Group (specified by lodIndex) the Zone Grouping (specified by zoneIndex and groupingIndex) is currently 
            configured to use. If no save data has been loaded or alt group names set via the PreInitialize method, and the World has not been 
            initialized, this will return the Group Name specified for the LOD Group via the Streamable Grid asset.
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone the Zone Grouping belongs to.
            </param>
            <param name="groupingIndex" type="int">The index World Grouping the Zone Grouping belongs to.</param>
            <param name="lodIndex" type="int">The index of the LOD the Group Name is being used with.</param>
            <returns type="string">The Group Name of the LOD.</returns>
            <displayName id="GetLODGroupName">GetLODGroupName(int, int, int)</displayName>
            <syntax>public string GetLODGroupName(int zoneIndex, int groupingIndex, int lodIndex)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetChunkStreamerAndID(System.Int32,System.Int32,System.Int32,DeepSpaceLabs.SAM.ChunkStreamer@,System.Int32@)">
            <summary>
            Gets the Chunk Streamer and User ID for the given LOD Group on the given Zone Grouping. It is very unlikely you will need to access the Streamer  
            for any reason, as SAM already automates all of the interactions with it. In fact, it is discouraged that you interact with it. This method 
            primarily exist to be used by the Addressable Prefab and Scene Streamer, however if you need to use it for some other reason, you can.
            <para>
            Note that while all LOD Groups of the same "level" across the same World Grouping will use the same Chunk Streamer no matter if they are 
            within the same Zone, each LOD Group will have a unique streamerUserID, as each is considered a separate user by the Streamer.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping.
            </param>
            <param name="LOD" type="int">
            The LOD whose Chunk Streamer you are interested in.
            </param>
            <param name="ChunkStreamer" type="ChunkStreamer" link="ChunkStreamer.html">
            The Chunk Streamer used by the LOD that will be set once the method completes.
            </param>
            <param name="streamerUserID" type="int">
            The ID that was assigned to the LOD Group when it registered with the Streamer. This is required for most methods of Chunk Streamers.
            </param>
            <displayName id="GetChunkStreamerAndID">
            GetChunkStreamerAndID(int, int, int, out ChunkStreamer, out int)
            </displayName>
            <syntax>
            public void GetChunkStreamerAndID(int zoneIndex, int groupingIndex, int LOD, out ChunkStreamer ChunkStreamer, out int streamerUserID)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetChunkManagerAndUserID(System.Int32,System.Int32,System.Int32,DeepSpaceLabs.SAM.ChunkManager@,System.Int32@)">
            <summary>
            Gets the Chunk Manager and User ID for the given LOD Group on the given Zone Grouping. It is very unlikely you will need to access the Manager   
            for any reason, as SAM already automates all of the interactions with it. In fact, it is discouraged that you interact with it.
            <para>
            Note that while all LOD Groups of the same "level" across the same World Grouping will use the same Chunk Manager no matter if they are 
            within the same Zone, each LOD Group will have a unique managerUserID, as each is considered a separate user by the Manager.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping.
            </param>
            <param name="LOD" type="int">
            The LOD whose Chunk Manager you are interested in.
            </param>
            <param name="chunkManager" type="ChunkManager" link="ChunkManager.html">
            The Chunk Manager used by the LOD that will be set once the method completes.
            </param>
            <param name="managerUserID" type="int">
            The manager ID for the LOD that will be set once the method completes. This is required to pass in for most methods of Chunk Managers.
            </param>
            <displayName id="GetChunkManagerAndUserID">
            GetChunkManagerAndUserID(int, int, int, out ChunkManager, out int)
            </displayName>
            <syntax>
            public void GetChunkManagerAndUserID(int zoneIndex, int groupingIndex, int LOD, out ChunkManager chunkManager, out int managerUserID)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetAllLoadedWorldCells(System.Int32,System.Int32,System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            Adds all loaded World Cells for the specified Zone Grouping to the passed in addCellsTo list.
            <para>
            Note that this method gets the currently loaded World Cells as contained in the 
            Grouping's internal dictionary. If the Grouping is in the process of being updated, the World Cells' 
            state cannot be predicted (they may be missing Asset Chunks, or those Asset Chunks may be in a state 
            you do not expect, for example).
            </para>
            <para>
            As such, it is usually best to call this method only when the World is not currently being updated, which 
            you can check using the 
            <see cref="P:DeepSpaceLabs.SAM.World.IsUpdateInProgress" href="World.html#IsUpdateInProgress">IsUpdateInProgress</see> property.
            </para>
            <para>
            However, the best approach for tracking World Cells is to use a 
            <see cref="T:DeepSpaceLabs.SAM.IWorldGroupingListener" href="IWorldGroupingListener.html">World Grouping Listener</see>, as you can 
            be confident about the state of the World Cells (depending on which method you use for the tracking), and can 
            accurately track when World Cells are added and removed.
            </para>
            <para>
            World Cells returned via this method can be removed at a moments notice, so you should only make use of them 
            for a very short period of time.
            </para>
            <para>
            If the World has not been initialized or the Zone Grouping is not in use (because no Streamable Grid was assigned to it, nothing 
            will be added to the list.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone whose World Cells you wish to get.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping whose World Cells you wish to get.
            </param>
            <param name="addCellsTo" type="List&lt;WorldCell&gt;" link="WorldCell.html">
            The list to add the World Cells to. The list is not cleared automatically, so you will 
            likely want to make sure it is empty before calling this method.
            </param>
            <displayName id="GetAllLoadedWorldCells">
            GetAllLoadedWorldCells(int, int, List&lt;WorldCell&gt;)
            </displayName>
            <syntax>
            public void GetAllLoadedWorldCells(int zoneIndex, int groupingIndex, List&lt;WorldCell&gt; addCellsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.IsZoneGroupingWithinRangeOfPosition(System.Int32,System.Int32,DeepSpaceLabs.SAM.Vector3Double,System.Double,DeepSpaceLabs.SAM.Vector3Double)">
            <summary>
            Checks whether a reference position is within range of the input Zone Grouping.
            <para>
            This method is intended to be used after calling 
            <see cref="M:DeepSpaceLabs.SAM.World.GetAllZonesWithinRangeOfPosition(System.Collections.Generic.ICollection{DeepSpaceLabs.SAM.InRangeZone},DeepSpaceLabs.SAM.Vector3Double,System.Double)" href="#GetAllZonesWithinRangeOfPosition">GetAllZonesWithinRangeOfPosition</see> or 
            <see cref="M:DeepSpaceLabs.SAM.World.GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell(System.Collections.Generic.ICollection{DeepSpaceLabs.SAM.InRangeZone},DeepSpaceLabs.SAM.Vector3Double,System.Double,DeepSpaceLabs.SAM.Cell)" href="#GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell">GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell</see>, 
            for any 
            InRangeZone's that were found with AllZoneGroupingsGauranteedToBeInRange set to false. It verifies that a Zone Grouping is actually 
            In Range to the same reference position passed to GetAllZonesWithinRangeOfPosition, 
            since when AllZoneGroupingsGauranteedToBeInRange is false, there is no gaurantee that each Zone Grouping in 
            the Zone is actually in range.
            </para>
            <para>
            This is why this method takes the zoneGroupingPosition as input, as that position is provided to the InRangePosition object when 
            calling the methods listed above. Also note that you do not need to provide any Origin Cell when calling this method, because this 
            method only uses the zoneGroupingPosition passed in to determine whether the position is within range. So if you used 
            GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell, the zoneGroupingPosition has already been calculated as if the Origin Cell were 
            set to the origin cell you passed into that method.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The Zone Index of the Zone Grouping.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping Index of the Zone Grouping.
            </param>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The reference position that the Zone Grouping needs to be within range to.
            </param>
            <param name="range" type="double" link="Name.html">
            The defined range that the Zone Grouping needs to be within.
            </param>
            <param name="zoneGroupingPosition" type="Vector3Double" link="Vector3Double.html">
            The current scene position of the Zone Grouping.
            </param>
            <displayName id="IsZoneGroupingWithinRangeOfPosition">
            IsZoneGroupingWithinRangeOfPosition(int, int, Vector3Double, double, Vector3Double)
            </displayName>
            <syntax>
            public bool IsZoneGroupingWithinRangeOfPosition(int zoneIndex, int groupingIndex, Vector3Double position, double range, Vector3Double zoneGroupingPosition)
            </syntax>
            <returns type="bool">
            True if the Zone Grouping is in range of the position, false otherwise.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetZoneGroupingNeighbors(System.Int32,System.Int32,System.Int32[])">
            <summary>
            
            </summary>
            <param name="zoneIndex" type="int">
            Description
            </param>
            <param name="groupingIndex" type="int">
            Description
            </param>
            <param name="neighborZones" type="int[]">
            The indices of the Zones which are neighboring the input Zone Grouping. Must be initialized to a length of 6 before calling the method, or else an 
            exception will be thrown!
            <para>
            Each index stores the Index of a neighboring Zone (as shown in the inspector), or 0 if there is no neighbor in that direction..
            </para>
            <para>
            West/East 
            refer to the -/+ X Axis respectively, while North/South refers to either the Z -/+ or Y -/+ Axis respectively 
            (depending on the Axes Type of the underlying Streamable Grid of the input
            Zone Grouping). Bottom/Top is only used for 3D Zone Groupings (and thus will be set to 0 for 2D Axes), and always refers to the Y -/+ Axis respectively.
            </para>
            <para>
            Index 0 is the West Neighbor.
            <br></br>
            Index 1 is the North Neighbor.
            <br></br>
            Index 2 is the East Neighbor.
            <br></br>
            Index 3 is the South Neighbor.
            <br></br>
            Index 4 is the Bottom Neighbor.
            <br></br>
            Index 5 is the Top Neighbor.
            </para>
            <para>
            This array can be reused for repeated calls to stop memory from being created each time it is called.
            </para>
            </param>
            <displayName id="GetZoneGroupingNeighbors">
            GetZoneGroupingNeighbors(int, int, int[])
            </displayName>
            <syntax>
            public void GetZoneGroupingNeighbors(int zoneIndex, int groupingIndex, int[] neighborZones)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.IsZoneEnabled(System.Int32)">
            <summary>
            Returns whether a Zone is enabled (as set via the inspector).
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone, as shown in the inspector.
            </param>
            <displayName id="IsZoneEnabled">
            IsZoneEnabled(int)
            </displayName>
            <syntax>
            public bool IsZoneEnabled(int zoneIndex)
            </syntax>
            <returns type="bool">
            True if the zone is enabled, false otherwise.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetAllLoadedWorldCellsInZone(System.Int32,System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            Adds all loaded World Cells for the specified Zone (across all World Groupings) to the passed in addCellsTo list.
            <para>
            Note that this method gets the currently loaded World Cells as contained in the 
            Grouping's internal dictionary. If the Grouping is in the process of being updated, the World Cells' 
            state cannot be predicted (they may be missing Asset Chunks, or those Asset Chunks may be in a state 
            you do not expect, for example).
            </para>
            <para>
            As such, it is usually best to call this method only when the World is not currently being updated, which 
            you can check using the 
            <see cref="P:DeepSpaceLabs.SAM.World.IsUpdateInProgress" href="World.html#IsUpdateInProgress">IsUpdateInProgress</see> property.
            </para>
            <para>
            However, the best approach for tracking World Cells is to use a 
            <see cref="T:DeepSpaceLabs.SAM.IWorldGroupingListener" href="IWorldGroupingListener.html">World Grouping Listener</see>, as you can 
            be confident about the state of the World Cells (depending on which method you use for the tracking), and can 
            accurately track when World Cells are added and removed.
            </para>
            <para>
            World Cells returned via this method can be removed at a moments notice, so you should only make use of them 
            for a very short period of time.
            </para>
            <para>
            If the World has not been initialized, nothing will be added to the list.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone whose World Cells you wish to get.
            </param>
            <param name="addCellsTo" type="List&lt;WorldCell&gt;" link="WorldCell.html">
            The list to add the World Cells to. The list is not cleared automatically, so you will 
            likely want to make sure it is empty before calling this method.
            </param>
            <displayName id="GetAllLoadedWorldCellsInZone">
            GetAllLoadedWorldCellsInZone(int, List&lt;WorldCell&gt;)
            </displayName>
            <syntax>
            public void GetAllLoadedWorldCellsInZone(int zoneIndex, List&lt;WorldCell&gt; addCellsTo)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetAllZonesWithinRangeOfPosition(System.Collections.Generic.ICollection{DeepSpaceLabs.SAM.InRangeZone},DeepSpaceLabs.SAM.Vector3Double,System.Double)">
            <summary>
            Gets all Zones in range of the position, where range is the passed in value. This is a highly efficient method that uses a Bounding Volume 
            Hierarchy type structure under the hood to efficiently sort the Zones into discreet areas for faster identification of in range zones.
            <para>
            Whether the Zone is in range is based on that Zones bounding volume within the World. Because a Zone can have variable sized Streamable Grids 
            across different World Groupings, this bounding volume's max position is based on the largest Streamable Grid in the zone. This means that although 
            a Zone may be within range to the position, an individual Zone Grouping may not actually be in range.
            </para>
            <para>
            On the other hand, if the input position is less than the Zone's min position on all three axes, all Zone Groupings will be in range if the 
            Zone is in range, since the min position of each Zone Grouping is equal to the Zone's min position.
            </para>
            <para>
            Check each InRangeZone's AllZoneGroupingsGauranteedToBeInRange value to see if this latter case has occured. If 
            AllZoneGroupingsGauranteedToBeInRange is true, you do not need to do anything else. All Zone Groupings for the Zone will 
            be in range. If AllZoneGroupingsGauranteedToBeInRange is false, you will need to perform a more precise check for each Zone Grouping you care about, which you 
            can do using the <see cref="M:DeepSpaceLabs.SAM.World.IsZoneGroupingWithinRangeOfPosition(System.Int32,System.Int32,DeepSpaceLabs.SAM.Vector3Double,System.Double,DeepSpaceLabs.SAM.Vector3Double)" href="#IsZoneGroupingWithinRangeOfPosition">IsZoneGroupingWithinRangeOfPosition</see> method. Pass in each Zone's ZonePosition (found on each inRangeZone object).
            </para>
            <para>
            Finally, it is VERY IMPORTANT to note that when using an endless/repeating World, the same Zone can be added multiple times using this method, as 
            the method will take into account whether the World has been repeated on each axis. If it has, the Zone's position may fall in the repeated 
            portion of the World rather than the original unrepeated portion. In these cases, the RepeatedWorldIndices value on each InRangeZone will tell you 
            if the zone is from a repeated portion of the World (0 means it falls on an unrepeated section, while +/- values indicate it falls on a 
            repeated section - for example +1 means it is on the first repeated portion on the + axis in relation to the original/unrepeated portion).
            </para>
            <para>
            Since the player can travel freely on each each axis, note that the Row, Column, and/or Layer value for the RepeatedWorldIndices may be 
            different. If not using any repeating/endless axes, RepeatedWorldIndices will always be equal to Cell.Zero.
            </para>
            </summary>
            <param name="inRangeZones" type="ICollection&lt;InRangeZone&gt;" link="InRangeZone.html">
            All Zones that are within range. See the summary for more information/caveats.
            <para>
            Note that collection is cleared automatically when the method is called, so you should 
            store the results from earlier calls if you don't want to lose that information.
            </para>
            </param>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The reference position that each Zone needs to be within range to.
            </param>
            <param name="range" type="double">
            The range that a zone needs to be within to be added to inRangeZones.
            </param>
            <displayName id="GetAllZonesWithinRangeOfPosition">
            GetAllZonesWithinRangeOfPosition(ICollection&lt;InRangeZone&gt;, Vector3Double, double)
            </displayName>
            <syntax>
            public void GetAllZonesWithinRangeOfPosition(ICollection&lt;InRangeZone&gt; inRangeZones, Vector3Double position, double range)
            </syntax>
            <exception name="UninitializedSAMObjectException">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell(System.Collections.Generic.ICollection{DeepSpaceLabs.SAM.InRangeZone},DeepSpaceLabs.SAM.Vector3Double,System.Double,DeepSpaceLabs.SAM.Cell)">
            <summary>
            Gets all Zones in range of the position, but with the World projected using the passed in theoreticalOriginCell, where range is the passed in value. This is a highly efficient method that uses a Bounding Volume 
            Hierarchy type structure under the hood to efficiently sort the Zones into discreet areas for faster identification of in range zones.
            <para>
            Whether the Zone is in range is based on that Zones bounding volume within the World. Because a Zone can have variable sized Streamable Grids 
            across different World Groupings, this bounding volume's max position is based on the largest Streamable Grid in the zone. This means that although 
            a Zone may be within range to the position, an individual Zone Grouping may not actually be in range.
            </para>
            <para>
            On the other hand, if the input position is less than the Zone's min position on all three axes, all Zone Groupings will be in range if the 
            Zone is in range, since the min position of each Zone Grouping is equal to the Zone's min position.
            </para>
            <para>
            Check each InRangeZone's AllZoneGroupingsGauranteedToBeInRange value to see if this latter case has occured. If 
            AllZoneGroupingsGauranteedToBeInRange is true, you do not need to do anything else. All Zone Groupings for the Zone will 
            be in range. If AllZoneGroupingsGauranteedToBeInRange is false, you will need to perform a more precise check for each Zone Grouping you care about, which you 
            can do using the <see cref="M:DeepSpaceLabs.SAM.World.IsZoneGroupingWithinRangeOfPosition(System.Int32,System.Int32,DeepSpaceLabs.SAM.Vector3Double,System.Double,DeepSpaceLabs.SAM.Vector3Double)" href="#IsZoneGroupingWithinRangeOfPosition">IsZoneGroupingWithinRangeOfPosition</see> method. Pass in each Zone's ZonePosition (found on each inRangeZone object).
            </para>
            <para>
            Finally, it is VERY IMPORTANT to note that when using an endless/repeating World, the same Zone can be added multiple times using this method, as 
            the method will take into account whether the World has been repeated on each axis. If it has, the Zone's position may fall in the repeated 
            portion of the World rather than the original unrepeated portion. In these cases, the RepeatedWorldIndices value on each InRangeZone will tell you 
            if the zone is from a repeated portion of the World (0 means it falls on an unrepeated section, while +/- values indicate it falls on a 
            repeated section - for example +1 means it is on the first repeated portion on the + axis in relation to the original/unrepeated portion).
            </para>
            <para>
            Since the player can travel freely on each each axis, note that the Row, Column, and/or Layer value for the RepeatedWorldIndices may be 
            different. If not using any repeating/endless axes, RepeatedWorldIndices will always be equal to Cell.Zero.
            </para>
            </summary>
            <param name="inRangeZones" type="ICollection&lt;InRangeZone&gt;" link="InRangeZone.html">
            All Zones that are within range. See the summary for more information/caveats. 
            <para>
            Note that collection is cleared automatically when the method is called, so you should 
            store the results from earlier calls if you don't want to lose that information.
            </para>
            </param>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The reference position that each Zone needs to be within range to.
            </param>
            <param name="range" type="double">
            The range that a zone needs to be within to be added to inRangeZones.
            </param>
            <param name="theoreticalOriginCell">
            The one based theoretical origin cell.
            </param>
            <displayName id="GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell">
            GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell(ICollection&lt;InRangeZone&gt;, Vector3Double, double, Cell)
            </displayName>
            <syntax>
            public void GetAllZonesWithinRangeOfPositionUsingTheoreticalOriginCell(ICollection&lt;InRangeZone&gt; inRangeZones, Vector3Double position, double range, Cell theoreticalOriginCell)
            </syntax>
            <exception name="UninitializedSAMObjectException">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetIndexOfZoneUsingID_PreInitSafe(System.Int32)">
            <summary>
            Gets the current index of the zone identified by the zoneID passed in.
            </summary>
            <param name="zoneID" type="int">
            The ID of the zone.
            </param>
            <displayName id="GetIndexOfZoneUsingID_PreInitSafe">
            GetIndexOfZoneUsingID_PreInitSafe(int)
            </displayName>
            <syntax>
            public int GetIndexOfZoneUsingID_PreInitSafe(int zoneID)
            </syntax>
            <returns type="int">
            The index of the Zone on this World (as shown in the inspector), or -1 if a Zone with the input ID does not exist.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetIndexOfZoneUsingName_PreInitSafe(System.String)">
            <summary>
            Gets the current index of the zone identified by the zoneName passed in. This method is slower than the version that uses 
            the ID of the Zone, so it is recommended to use that instead when possible.
            </summary>
            <param name="zoneName" type="string">
            The name of the zone.
            </param>
            <displayName id="GetIndexOfZoneUsingName_PreInitSafe">
            GetIndexOfZoneUsingName_PreInitSafe(string)
            </displayName>
            <syntax>
            public int GetIndexOfZoneUsingName_PreInitSafe(string zoneName)
            </syntax>
            <returns type="int">
            The index of the Zone on this World (as shown in the inspector), or -1 if a Zone does not exist with the input name.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetZoneName_PreInitSafe(System.Int32)">
            <summary>
            Gets the name of a Zone as assigned in the World inspector.
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone.
            </param>
            <displayName id="GetZoneName_PreInitSafe">
            GetZoneName_PreInitSafe(int)
            </displayName>
            <syntax>
            public string GetZoneName_PreInitSafe(int zoneIndex)
            </syntax>
            <returns type="string">
            The name of the Zone.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.CalculateShiftResultingFromNewOriginCell(DeepSpaceLabs.SAM.Cell)">
            <summary>
            Calculates the amount the world would be shifted if the Origin Cell of the world was changed to a new Origin Cell. Note that 
            this does not actually perform an Origin Cell Change.
            <para>
            This method merely calculates how much the world would be shifted if the passed in cell were made the Origin Cell.
            </para>
            <para>
            This Origin Cell is always in reference to the World Grid.
            </para>
            </summary>
            <param name="newOriginCell" type="Cell" link="Cell.html">
            The new Origin Cell of the World to use in the calculation (on Grouping 1).
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The amount of shift that would result from the Origin Cell change.
            </returns>
            <displayName id="CalculateShiftResultingFromNewOriginCell">
            CalculateShiftResultingFromNewOriginCell(Cell)
            </displayName>
            <syntax>
            public Vector3Double CalculateShiftResultingFromNewOriginCell(Cell newOriginCell)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.UpdateLoadCushion(System.Single)">
            <summary>
            Updates the Load Cushion used by the World.
            <para>
            The load cushion is the amount of time the World will wait after it 
            receives cell add/remove request or a 
            world origin reset order before proceeding with a World Update or Origin Reset. Increasing 
            the load cushion time gives your player time cross additional boundaries before the world is updated, or to cross 
            back over a boundary that they just crossed.
            This can reduce some loading/unloading that occurs as the result of a very fast moving player 
            or small terrain/object sizes.
            </para>
            </summary>
            <param name="newLoadCushion" type="double">
            The new load cushion, in seconds.
            </param>
            <displayName id="UpdateLoadCushion">
            UpdateLoadCushion(double)
            </displayName>
            <syntax>
            public void UpdateLoadCushion(double newLoadCushion)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ClampOriginCells(System.Boolean,System.Boolean,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Clamps the world's Origin Cells. Clamping can only occur when the world utilizes one or more endless axes.
            <para>
            The process of clamping takes the current World's Origin Cell value and translates it to a value that falls between the normal  
            Starting and Ending Cell of the World (which is determined by the layout of your Zones). 
            Each Zone Grouping's Origin Cell is also translated in a way that is consistent with the translation of the  
            World's Origin Cell. All loaded World Cells on each Zone Grouping have their Cell On Endless Grid value adjusted during the clamp.
            </para>
            <para>
            For example, imagine you have a World with a single Zone Grouping, that is using a Streamable Grid with only 2 Rows. 
            On a world with non endless rows, cells in this Zone Grouping (upon being loaded into the scene) 
            can only have a row value of 1 or 2, which match perfectly with their Streamable Grid indexes.
            However, on an world with endless rows, once the world repeats on the row axis, the cells will have values 3 and 4, 5 and 6, 7 and 8, 
            and so on, until infinity. And of course the world can repeat 
            in the opposite direciton as well and have values like 0 and -1, -2 and -3, and so on. 
            The Origin Cell of the World uses a similar Endless World Grid, for many reasons.
            </para>
            <para>
            Origin Cells of course cannot reach into infinity, since they are represented by a fixed max/min value 
            data type (in this case, integer), so astute observers 
            will note that this system of handling things has the (incredibly minute) chance of causing issues 
            in some rare cases (when the player plays the game for a long, long time). 
            As such, Origin Clamping is an option to rectify the problem (and please, do consider your particular 
            use case to determine if this problem is even possible!!).
            </para>
            <para>
            If our Origin Cell has a Row of 5 and the World's Rows range between -2 and 2, we can note that this row 5 cell 
            is equivalent to a row 0 cell. The goal of clamping, then, is to take 
            the row 5 World Origin Cell and shift it so its value is 0. In this case, we must shift 5 by -5 to get it to 0. Easy, right?
            </para>
            <para>
            Yes and no. While the Origin Cell has been shifted, any data that is dependent on the Origin Cell is now 
            invalidated, as the data is dependent on the Origin Cell having a row value of 5. 
            Therefore, we must also shift (by -5) any data that was dependent on the origin row being 5, in order 
            to bring that data in line with our Origin Cell shift. 
            </para>
            <para>
            As such, this method will automatically notify World Users (registered with the World via the 
            <see cref="M:DeepSpaceLabs.SAM.World.Register(DeepSpaceLabs.SAM.IWorldUser,System.Int32@)" href="#Register">Register</see> method) of the clamping, so that 
            data can be updated (notification occurs in full before the call back is triggered).
            </para>
            <para>
            Because the clamping operation can only be initiated manually by you, the developer, World Users are not 
            queried to make sure the clamping operation can proceed. This differs from how normal Origin Cell changes occur. This decision was made 
            because you should be in full control of all World Users in your game; therefore, you should know if the clamping operation would interfere 
            with any operations the users have in progress, and you can delay the clamping operation until after those operations complete. For example, it 
            is usually a bad idea to perform a clamping operation while a save is in progress!
            </para>
            </summary>
            <param name="updateHiearchyOrganizers" type="bool">
            If true, when a hierarchy organizer is assigned to this World, all World Chunks will be removed and then re-added to the organizer after modifying 
            the World Cell data each object belongs to. This should only be necessary if you are using the Endless Grid Cell indexes of the World Cell to 
            organize the objects, for example when using a Standard Hiearchy Organizer with the "Group Objects From Same Base Cell" option and/or 
            "Group Objects From Same World Cell" options enabled.
            </param>
            <param name="notifyUsersInSingleFrame" type="bool">
            Whether registered users should be notified in a single frame. If false, a single user will be notified and after the World will query the Execution Controller 
            to determine if it should yield. Note that depending on your execution controller, multiple (or even all 
            users) may be notified in a single frame. If true, all users are notified in a single frame instead.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional call back action that will be triggered after the operation completes.
            </param>
            <displayName id="ClampOriginCells">
            ClampOriginCells(bool, bool, [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public ClampingOperationInfo ClampOriginCells(bool updateHiearchyOrganizers, bool notifyUsersInSingleFrame, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
            <returns type="ClampingOperationInfo" link="ClampingOperationInfo.html">
            Information about the Clamping Operation. Only valid after the onCompletedCallback has triggered! The same object is reused for each Clamping Operation, 
            which means the data in the Info will be cleared automatically each time a Clamping Operation is executed.
            <para>
            Do note, however, that the origin cell 
            data should only be relied upon in the short time after onCompletedCallback is triggered, since the Origin Cell may change as a result of an 
            Origin Cell change operation.
            </para>
            <para>
            If you want to free up memory, you can call the 
            <see cref="M:DeepSpaceLabs.SAM.ClampingOperationInfo.ClearMemory" href="ClampingOperationInfo.html#ClearMemory">ClearMemory</see> method on this object, but only after 
            onCompletedCallback is triggered and you have used the object's data as you need.
            </para>
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetBoundsOfEndlessGridCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Get the bounds of an Endless Grid Cell (can be any value).
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell whose bounds should be retrieved.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <returns type="Bounds">
            The bounds of the cell.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="GetBoundsOfEndlessGridCell">
            GetBoundsOfEndlessGridCell(Cell, int, int)
            </displayName>
            <syntax>
            public Bounds GetBoundsOfEndlessGridCell(Cell endlessGridCell, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetDimensionsOfEndlessGridCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Get the cell dimensions of an Endless Grid Cell (can be any value).
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell whose dimensions should be retrieved.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <returns type="CellDimensions" link="CellDimensions.html">
            The cell dimensions of the cell.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="GetDimensionsOfEndlessGridCell">
            GetDimensionsOfEndlessGridCell(Cell, int, int)
            </displayName>
            <syntax>
            public CellDimensions GetDimensionsOfEndlessGridCell(Cell endlessGridCell, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetPositionOfEndlessGridCell_PreInitSafe(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Retrieves the position of an Endless Grid Cell on a Zone Grouping. Unlike Streamable Grid cells, 
            the indexes of this cell can be any value.
            <para>
            This method is safe to use at runtime before the World has been initialized. It is NOT SAFE to use outside of the editor!
            </para>
            <para>
            The method uses the current World Origin Cell in its calculation. If SAM has not been initialized, this should be the 
            Origin Cell set in the inspector, unless you call the method after loading save data.
            </para>
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The cell whose position should be retrieved.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The position of the cell.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="GetPositionOfEndlessGridCell_PreInitSafe">
            GetPositionOfEndlessGridCell_PreInitSafe(Cell, int, int)
            </displayName>
            <syntax>
            public Vector3Double GetPositionOfEndlessGridCell_PreInitSafe(Cell endlessGridCell, int zoneIndex, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetPositionOfEndlessGridCellUsingInitialOriginCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Gets the position of an Endless Grid Cell as if the Origin Cell of the World were still the initial Origin Cell (as set 
            in the inspector of your World).
            <para>
            Note that the Endless Grid Cell is in reference to the World Grouping you specify via groupingIndex, 
            but the Origin Cell is always in reference to the Base Grouping (Grouping 1).
            </para>
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell whose position will be returned.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <returns type ="Vector3Double">The position of the Endless Grid Cell.</returns>
            <displayName id="GetPositionOfEndlessGridCellUsingInitialOriginCell">
            GetPositionOfEndlessGridCellUsingInitialOriginCell(Cell, int, int)
            </displayName>
            <syntax>
            public Vector3Double GetPositionOfEndlessGridCellUsingInitialOriginCell(Cell endlessGridCell, int zoneIndex, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetPositionOfEndlessGridCellUsingTheoreticalOriginCell(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Gets the position that an Endless Grid Cell would be at if the Origin Cell of the Base Grouping/World were set to 
            a theoreticaly Origin Cell.
            <para>
            Note that the Endless Grid Cell is in reference to the World Grouping you specify via groupingIndex, 
            but the Origin Cell is always in reference to the Base Grouping.
            </para>
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell whose (theoretical) position will be returned.
            </param>
            <param name="theoreticalOriginCell" type="Cell" link="Cell.html">
            The theoretical Origin Cell to base the Endless Grid cells position on.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <returns type ="Vector3Double">The (theoretical) position of the Endless Grid Cell.</returns>
            <displayName id="GetPositionOfEndlessGridCellUsingTheoreticalOriginCell">
            GetPositionOfEndlessGridCellUsingTheoreticalOriginCell(Cell, Cell, int, int)
            </displayName>
            <syntax>
            public Vector3Double GetPositionOfEndlessGridCellUsingTheoreticalOriginCell(Cell endlessGridCell, Cell theoreticalOriginCell, int zoneIndex, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetPositionAndDimensionsOfEndlessGridCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,DeepSpaceLabs.SAM.Vector3Double@,DeepSpaceLabs.SAM.CellDimensions@)">
            <summary>
            Retrieves the position and dimensions of an Endless Grid Cell.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell whose position and dimensions should be retrieved.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <param name="positionOfCell" type="Vector3Double" link="Vector3Double.html">
            The position of the cell (will be set when the method returns).
            </param>
            <param name="dimensionsOfCell" type="CellDimensions" link="CellDimensions.html">
            The cell dimensions of the cell (will be set when the method returns).
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="GetPositionAndDimensionsOfEndlessGridCell">
            GetPositionAndDimensionsOfEndlessGridCell(Cell, int, int, out Vector3Double, out CellDimensions)
            </displayName>
            <syntax>
            public void GetPositionAndDimensionsOfEndlessGridCell(Cell endlessGridCell, int zoneIndex, int groupingIndex, out Vector3Double positionOfCell, out CellDimensions dimensionsOfCell))
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetRowAndLayerPositionOfCell(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,System.Double@,System.Double@)">
            <summary>
            Get the row and layer position of a Cell (can be a World Cell, Endless Grid Cell, or Streamable Grid Cell) given it position in the scene. 
            This is useful because the row and layer positions may be using the y or z components of the Vector3Double, 
            depending on the Axes set on the World Grouping's Streamable Grid.
            <para>
            When the Axes are set to 
            <see cref="F:DeepSpaceLabs.SAM.Axes.Two_Dimensional_On_XZ_Axes">Two_Dimensional_On_XZ_Axes</see> or 
            <see cref="F:DeepSpaceLabs.SAM.Axes.Three_Dimensional">Three_Dimensional</see>, the row position uses the z component and 
            layer position uses y component of cellPosition.
            </para>
            <para>
            When the Axes are set to <see cref="F:DeepSpaceLabs.SAM.Axes.Two_Dimensional_On_XY_Axes">Two_Dimensional_On_XY_Axes</see> 
            the row position uses y component and layer position uses the z component of cellPosition.
            </para>
            </summary>
            <param name="cellPosition" type="Vector3Double" link="Vector3Double.html">The world space position of the cell.</param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the cell whose row and layer position we want to 
            extract from input position.
            </param>
            <param name="rowPosition" type="double">
            The position of the cell's row (will be set after this method returns).
            </param>
            <param name="layerPosition" type="double">
            The position of the cell's layer (will be set after this method returns).
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="GetRowAndLayerPositionOfCell">
            GetRowAndLayerPositionOfCell(Vector3Double, int, int, out double, out double)
            </displayName>
            <syntax>
            public void GetRowAndLayerPositionOfCell(Vector3Double cellPosition, int zoneIndex, int groupingIndex, out double rowPosition, out double layerPosition)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellPositionIsInOrClosestToUsingInitialOriginCell(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Finds the Endless Grid Cell that the input position would be in or be closest to if the Origin Cell of this world 
            were equal to its initial Origin Cell (as set in the inspector of your World).
            <para>
            Note that if you use clamping, the endless cell indexes will be adjusted, so you cannot rely on 
            the cell indexes remaining constant. For a non endless world clamping cannot be used therefore it is not an issue.
            </para>
            <para>
            Finally, keep in mind that the Endless Grid Cell is in reference to the World Grouping you specify via 
            groupingIndex, but the Origin Cell is always in reference to the World's Grid.
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <returns type="Cell" link="Cell.html">
            The Endless Grid Cell the position would be in if the initial Origin Cell was the 
            Origin Cell of this world.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsInOrClosestToUsingInitialOriginCell">
            FindEndlessGridCellPositionIsInOrClosestToUsingInitialOriginCell(Vector3Double, int)
            </displayName>
            <syntax>
            public Cell FindEndlessGridCellPositionIsInOrClosestToUsingInitialOriginCell(Vector3Double position, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellPositionIsInOrClosestToUsingTheoreticalOriginCell(DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Finds the Endless Grid Cell that the input position would be in if the Origin Cell of this world 
            were equal to the theoretical Origin Cell provided.
            <para>
            This is useful if you're about to change the Origin Cell via the Active Grid's 
            <see cref="M:DeepSpaceLabs.SAM.ActiveGrid.TryMovePlayerAndChangeOriginCellOfWorld(DeepSpaceLabs.SAM.Cell,DeepSpaceLabs.SAM.Vector3Double,System.Boolean,System.Double,System.Boolean)" href="ActiveGrid.html#TryMovePlayerAndChangeOriginCellOfWorld">TryMovePlayerAndChangeOriginCellOfWorld</see>
            method and need to calculate some data based on the new Origin Cell.
            </para>
            <para>
            Finally, keep in mind that the Endless Grid Cell is in reference to the World Grouping you specify via 
            groupingIndex, but the Origin Cell is always in reference to the Base Grouping (Grouping 1).
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="theoreticalOriginCell">
            The theoretical Origin Cell (from the Base Grouping) to use to find the Endless Grid Cell.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <returns type="Cell" link="Cell.html">
            The Endless Grid Cell the position would be in if the theoretical Origin Cell was the 
            Origin Cell of this world.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell">
            FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell(Vector3Double, Cell, int)
            </displayName>
            <syntax>
            public Cell FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell(Vector3Double position, Cell theoreticalOriginCell, int groupingIndex)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellPositionIsInOrClosestTo(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Finds the Endless Grid Cell that the specified position falls within on this World (given the current Origin Cell of the World), for the 
            specified Zone and World Grouping. If the position does not fall in an actual Cell of the Zone, the returned Cell will be the closest Cell to 
            the position instead.
            <para>
            Bear in mind that if the Zone Grouping is Two Dimensional, the position will always be considered 
            inside of Layer 1, even if technically it falls outside of the Layer's Bounds as set on your 
            Streamable Grid.
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <param name="positionIsInCell" type="out bool">Whether the position is in the return Cell. If false, it means the position is outside of the Cell/Zone 
            but that the returned Cell is the closest Cell to the position.</param>
            <returns type="Cell" link="Cell.html">The Endless Grid Cell the position falls within or is closest to.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsInOrClosestTo1">FindEndlessGridCellPositionIsInOrClosestTo(Vector3Double, int, int, out bool)</displayName>
            <syntax>public Cell FindEndlessGridCellPositionIsInOrClosestTo(Vector3Double position, int zoneIndex, int groupingIndex, out bool positionIsInCell)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellPositionIsInOrClosestTo(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,System.Boolean@,DeepSpaceLabs.SAM.Vector3Double@)">
            <summary>
            Finds the Endless Grid Cell (and it's position) that the specified position falls within on this World (given the current Origin Cell of the World), for the 
            specified Zone and World Grouping. If the position does not fall in an actual Cell of the Zone, the returned Cell will be the closest Cell to 
            the position instead.
            <para>
            Bear in mind that if the Zone Grouping is Two Dimensional, the position will always be considered 
            inside of Layer 1, even if technically it falls outside of the Layer's Bounds as set on your 
            Streamable Grid.
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping which contains the Endless Grid Cell in question.
            </param>
            <param name="positionIsInCell" type="out bool">Whether the position is in the return Cell. If false, it means the position is outside of the Cell/Zone 
            but that the returned Cell is the closest Cell to the position.</param>
            <param name="endlessGridCellPosition" type="out Vector3Double" link="Vector3Double.html">
            The position in the scene of the returned Endless Grid Cell.
            </param>
            <returns type="Cell" link="Cell.html">The Endless Grid Cell the position falls within or is closest to.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsInOrClosestTo1">FindEndlessGridCellPositionIsInOrClosestTo(Vector3Double, int, int, out bool, out Vector3Double)</displayName>
            <syntax>public Cell FindEndlessGridCellPositionIsInOrClosestTo(Vector3Double position, int zoneIndex, int groupingIndex, out bool positionIsInCell, out Vector3Double endlessGridCellPosition)</syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellPositionIsInOrClosestTo(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,DeepSpaceLabs.SAM.Vector3Double@,System.Boolean@)">
            <summary>
            Finds the Endless Grid Cell that the specified position falls within on this World (given the current Origin Cell of the World), for the 
            specified Zone and World Grouping. If the position does not fall in an actual Cell of the Zone, the returned Cell will be the closest Cell to 
            the position instead.
            <para>
            Also outputs the position of the returned Cell.
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="endlessGridCellPosition" type="out Vector3Double" link="Vector3Double.html">
            The position of the Endless Grid Cell within the scene.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Endless Grid Cell you want to find.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping which contains the Endless Grid Cell you want to find.
            </param>
            <param name="positionIsInCell" type="out bool">
            Whether the position is in the return Cell. If false, it means the position is outside of the Cell/Zone 
            but that the returned Cell is the closest Cell to the position.
            </param>
            <returns type="Cell" link="Cell.html">The Endless Grid Cell the position falls within.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindEndlessGridCellPositionIsInOrClosestTo2">
            FindEndlessGridCellPositionIsInOrClosestTo(Vector3Double, int, int, out Vector3Double, out bool)
            </displayName>
            <syntax>
            public Cell FindEndlessGridCellPositionIsInOrClosestTo(Vector3Double position, int zoneIndex, int groupingIndex, out Vector3Double endlessGridCellPosition, out bool positionIsInCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindStreamableGridCellPositionIsInOrClosestTo(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,System.Boolean@)">
            <summary>
            Finds the Streamable Grid Cell that the specified position falls within on this World (given the current Origin Cell of the World).
            <para>
            This uses the current Origin Cell of the World in the calculation. If you need to use the initial Origin Cell of the World, or a theoretical 
            Origin Cell, use 
            <see cref="!:FindEndlessGridCellPositionIsInUsingInitialOriginCell" href="#FindEndlessGridCellPositionIsInUsingInitialOriginCell">FindEndlessGridCellPositionIsInUsingInitialOriginCell</see> or 
            <see cref="!:FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell" href="#FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell">FindEndlessGridCellPositionIsInUsingTheoreticalOriginCell</see>, then covert the Endless Grid Cell returned to a Streamable Grid Cell using 
            the Streamable Grid's 
            <see cref="M:DeepSpaceLabs.SAM.StreamableGrid.ConvertCellOnEndlessGridToCellOnStreamableGrid(DeepSpaceLabs.SAM.Cell)" href="StreamableGrid.html#ConvertCellOnEndlessGridToCellOnStreamableGrid">ConvertCellOnEndlessGridToCellOnStreamableGrid</see> method.
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the Streamable Grid Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the Streamable Grid Cell in question.
            </param>
            <param name="positionIsInCell" type="out bool">
            True if the position is inside the returned Cell, false otherwise.
            </param>
            <returns type="Cell" link="Cell.html">
            The Streamable Grid Cell the position falls within.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <displayName id="FindStreamableGridCellPositionIsIn">
            FindStreamableGridCellPositionIsIn(Vector3Double, int, int, out bool)
            </displayName>
            <syntax>
            public Cell FindStreamableGridCellPositionIsIn(Vector3Double position, int zoneIndex, int groupingIndex, out bool positionIsInCell)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellsPositionIsInAcrossAllZones(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Collections.Generic.List{DeepSpaceLabs.SAM.ZoneGroupingCell})">
            <summary>
            Finds all Endless Grid Cells that a position is in across all Zones for a given World Grouping.
            <para>
            This is useful if you don't care what Zone the position is in. 
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the Streamable Grid Cell in question.
            </param>
            <param name="cells" type="List&lt;ZoneGroupingCell&gt;" link="ZoneGroupingCell.html">
            The list to add the cells to. ZoneGroupingCell is used so that you will know which Zone each Cell is in.
            </param>
            <displayName id="FindEndlessGridCellsPositionIsInAcrossAllZones">
            FindEndlessGridCellsPositionIsInAcrossAllZones(Vector3Double, int, List&lt;ZoneGroupingCell&gt;)
            </displayName>
            <syntax>
            public void FindEndlessGridCellsPositionIsInAcrossAllZones(Vector3Double position, int groupingIndex, List&lt;ZoneGroupingCell&gt; cells)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellsPositionIsInAcrossAllZonesAndGroupings(DeepSpaceLabs.SAM.Vector3Double,System.Collections.Generic.List{DeepSpaceLabs.SAM.ZoneGroupingCell})">
            <summary>
            Finds all Endless Grid Cells that a position is in across all Zones and World Groupings.
            <para>
            This is useful if you don't care what Zone or World Grouping the position is in. 
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space.
            </param>
            <param name="cells" type="List&lt;ZoneGroupingCell&gt;" link="ZoneGroupingCell.html">
            The list to add the cells to. ZoneGroupingCell is used so that you will know which Zone and World Grouping each Cell is in.
            </param>
            <displayName id="FindEndlessGridCellsPositionIsInAcrossAllZonesAndGroupings">
            FindEndlessGridCellsPositionIsInAcrossAllZonesAndGroupings(Vector3Double, List&lt;ZoneGroupingCell&gt;)
            </displayName>
            <syntax>
            public void FindEndlessGridCellsPositionIsInAcrossAllZonesAndGroupings(Vector3Double position, List&lt;ZoneGroupingCell&gt; cells)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindEndlessGridCellsPositionsAreInOrClosestTo(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},Unity.Collections.NativeArray{System.Boolean},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Can be used to find the endless grid cells that a batch of positions fall within. You can either queue up another Job 
            that is dependent on the returned JobHandle, or use JobHandle.IsCompleted to ensure the 
            job is completed (and then call JobHandle.Complete() after). The cells array data will only be valid after the job has completed!
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            The batch of positions to process. It should be initialized with either the TempJob Allocator or Persistent Allocator (if TempJob 
            results in errors).
            <para>
            Remember to dispose of the array after you are finished using the data (usually after calling this method).
            </para>
            </param>
            <param name="cells" type="NativeArray&lt;Cell&gt;" link="Cell.html">
            Contains the Endless Grid Cell each position is in after the job completes. 
            It should be initialized before calling this method with either the TempJob Allocator or Persistent 
            Allocator (if TempJob results in errors). You can also initialize the array with UninitializedMemory for a bit faster code.
            <para>
            Remember to dispose of this array after you have finished using the data!
            </para>
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping that the Endless Grid Cells are associated with.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the endless grid identification will be scheduled and started before the job is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <returns type="JobHandle">
            A Job Handle that will have been scheduled. Use IsCompleted to check if it is complete, then call Complete afterwards before 
            accessing the data in the cells array.
            </returns>
            <displayName id="FindEndlessGridCellsPositionsAreIn">
            FindEndlessGridCellsPositionsAreIn(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, [bool])
            </displayName>
            <syntax>
            public JobHandle FindEndlessGridCellsPositionsAreIn(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; cells, int groupingIndex, bool initializeWorkImmediately)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindStreamableGridCellsPositionsAreInOrClosestTo(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},Unity.Collections.NativeArray{System.Boolean},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Can be used to find the streamable grid cells that a batch of positions fall within. You can either queue up another Job 
            that is dependent on the returned JobHandle, or use JobHandle.IsCompleted to ensure the 
            job is completed (and then call JobHandle.Complete() after). The cells array data will only be valid after the job has completed!
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            The batch of positions to process. It should be initialized with either the TempJob Allocator or Persistent Allocator (if TempJob 
            results in errors).
            <para>
            Remember to dispose of the array after you are finished using the data (usually after calling this method).
            </para>
            </param>
            <param name="cells" type="NativeArray&lt;Cell&gt;" link="Cell.html">
            Contains the Streamable Grid Cell each position is in after the job completes. 
            It should be initialized before calling this method with either the TempJob Allocator or Persistent 
            Allocator (if TempJob results in errors). You can also initialize the array with UninitializedMemory for a bit faster code.
            <para>
            Remember to dispose of this array after you have finished using the data!
            </para>
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping that the Streamable Grid Cells are associated with.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the streamable grid identification will be scheduled and started before the job is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <returns type="JobHandle">
            A Job Handle that will have been scheduled. Use IsCompleted to check if it is complete, then call Complete afterwards before 
            accessing the data in the cells array.
            </returns>
            <displayName id="FindStreamableGridCellsPositionsAreIn">
            FindStreamableGridCellsPositionsAreIn(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, [bool])
            </displayName>
            <syntax>
            public JobHandle FindStreamableGridCellsPositionsAreIn(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; cells, int groupingIndex, bool initializeWorkImmediately)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetWorldCellsPositionIsIn(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            Gets any and all <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cells</see> that the 
            position is in for the specified World Grouping, across all Zones. 
            If no World Cells can be identified, the input worldCells list will be empty.
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space. Note that for 2D World Groupings, 
            the position on the third unused axis is still taken into account with this method, and the position must 
            fall within the dimensions of the single Layer of the Zone Grouping.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the World Cells in question.
            </param>
            <param name="worldCells" type="List&lt;WorldCell&gt;" link="WorldCell.html">
            When this method returns, will contain the World Cells that contain the position, if any, across 
            all zones, but only for world cells associated with the input groupingIndex.
            </param>
            <returns type="bool">A bool indicating whether the World Cell was able to be retrieved.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <syntax>
            public bool GetWorldCellsPositionIsIn(Vector3Double position, int groupingIndex, List&lt;WorldCell&gt; worldCells)
            </syntax>
            <displayName id="GetWorldCellsPositionIsIn">
            GetWorldCellsPositionIsIn(Vector3Double, int, List&lt;WorldCell&gt;)
            </displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TryGetWorldCellPositionIsIn(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,DeepSpaceLabs.SAM.WorldCell@,DeepSpaceLabs.SAM.NullWorldCellError@)">
            <summary>
            Tries to get the <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> that the 
            position is in. If no World Cell can be identified, false will be returned and worldCell will be null. 
            In this case, reasonForFailure can tell you important information on why the World Cell could not be 
            found, such as the position was outside the bounds of the Streamable Grid or fell within the 
            bounds of a disabled Streamable Grid Cell.
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space. Note that for 2D World Groupings, 
            the position on the third unused axis is still taken into account with this method, and the position must 
            fall within the dimensions of the single Layer of the Zone Grouping.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the World Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the World Cell in question.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the World Cell associated with the Endless Grid Cell, or null 
            if a World Cell cannot be identified
            </param>
            <param name="reasonForFailure" type="NullWorldCellError" link="NullWorldCellError.html">
            If a World Cell cannot be retrieved, this will tell you why.
            </param>
            <returns type="bool">A bool indicating whether the World Cell was able to be retrieved.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <syntax>
            public bool TryGetWorldCellPositionIsIn(Vector3Double position, int groupingIndex, out WorldCell worldCell, out NullWorldCellError reasonForFailure)
            </syntax>
            <displayName id="TryGetWorldCellPositionIsIn1">
            TryGetWorldCellPositionIsIn(Vector3Double, int, out WorldCell, out NullWorldCellError)
            </displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TryGetWorldCellPositionIsIn(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,DeepSpaceLabs.SAM.WorldCell@)">
            <summary>
            Tries to get the <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> that the 
            position is in. This method may fail to identify a World Cell for several reasons. If you are 
            having trouble identifing the reason, you can use the alternative method with the out 
            string reasonForFailure parameter.
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position in world space. Note that for 2D World Groupings, 
            the position on the third unused axis is still taken into account with this method, and the position must 
            fall within the dimensions of the single Layer of the Zone Grouping.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the World Cell in question.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the World Cell associated with the Endless Grid Cell, or null 
            if a World Cell cannot be identified
            </param>
            <returns type="bool">A bool indicating whether the World Cell was able to be retrieved.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <syntax>
            public bool TryGetWorldCellPositionIsIn(Vector3Double position, int, out WorldCell worldCell)
            </syntax>
            <displayName id="TryGetWorldCellPositionIsIn2">
            TryGetWorldCellPositionIsIn(Vector3Double, int groupingIndex, out WorldCell)
            </displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TryGetWorldCellAssociatedWithEndlessGridCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,DeepSpaceLabs.SAM.WorldCell@,DeepSpaceLabs.SAM.NullWorldCellError@)">
            <summary>
            Tries to get the <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> associated with 
            the Endless Grid Cell. If no World Cell can be identified, false will be returned and 
            worldCell will be null. 
            In this case, reasonForFailure can tell you important information on why the World Cell could not be 
            found, such as the Endless Grid Cell was outside the bounds of the Streamable Grid 
            or was associated with an disabled Streamable Grid Cell.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell to use to find the World Cell.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone which contains the World Cell in question.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the World Cell in question.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the World Cell associated with the Endless Grid Cell, or null 
            if a World Cell cannot be identified.
            </param>
            <param name="reasonForFailure" type="NullWorldCellError" link="NullWorldCellError.html">
            If a World Cell was not located, this will tell you why the retrieval failed.
            </param>
            <returns type="bool">A bool indicating whether the World Cell was able to be retrieved.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
            <syntax>
            public bool TryGetWorldCellAssociatedWithEndlessGridCell(Cell endlessGridCell, int groupingIndex, out WorldCell worldCell, out NullWorldCellError reasonForFailure)
            </syntax>
            <displayName id="TryGetWorldCellAssociatedWithEndlessGridCell1">
            TryGetWorldCellAssociatedWithEndlessGridCell(Cell, int, out WorldCell, out NullWorldCellError)
            </displayName>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TryGetWorldCellAssociatedWithEndlessGridCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,DeepSpaceLabs.SAM.WorldCell@)">
            <summary>
            Tries to get the <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> that the 
            position is in. This method may fail to identify a World Cell for several reasons. If you are 
            having trouble identifing the reason, you can use the alternative method with the out 
            string parameter.
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell to use to find the World Cell.
            </param>
            <param name="groupingIndex" type="int"> 
            The index of the World Grouping which contains the World Cell in question.
            </param>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            When this method returns, contains the World Cell associated with the Endless Grid Cell, or null 
            if a World Cell cannot be identified.
            </param>
            <syntax>
            public bool TryGetWorldCellAssociatedWithEndlessGridCell(Cell endlessGridCell, int groupingIndex, out WorldCell worldCell)
            </syntax>
            <displayName id="TryGetWorldCellAssociatedWithEndlessGridCell2">
            TryGetWorldCellAssociatedWithEndlessGridCell(Cell, int, out WorldCell)
            </displayName>
            <returns type="bool">A bool indicating whether the World Cell was able to be retrieved.</returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetWorldCellsInAxisAlignedBoundingCube(System.Int32,DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.Vector3Double,System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            Gets all World Cells on the indicated World Grouping that fall within an axis aligned bounding cube within the scene. This can be used to 
            determine which cells fall within an area of the scene, such as within the Camera's view point (obviously it will be approximate, since 
            the camera viewport is not a cube).
            <para>
            Unlike the other GetWorldCellsInAxisAlignedBoundingCube method, this one is LOD agnostic. All World Cells belonging to the World Grouping 
            will be added to the list, regardless of which LOD they have in use (so long as they fall within the cube's area).
            </para>
            <para>
            Also note that this method is Zone agnostic. Cells will be returned so long as they are associated with the input World Grouping, no matter 
            which Zone they fall within.
            </para>
            </summary>
            <param name="groupingIndex" type="int">
            The World Grouping which contains the cells we care about. Only world cells from this World Grouping are added to the worldCellsInArea list.
            </param>
            <param name="min" type="Vector3Double" link="Vector3Double.html">
            The lower left point on the cube.
            </param>
            <param name="max" type="Vector3Double" link="Vector3Double.html">
            The upper right point on the cube.
            </param>
            <param name="worldCellsInArea" type="List&lt;WorldCell&gt;" link="WorldCell.html">
            The list which the world cells will be added to. The method will not clear this list, so be cautious if it is not empty to begin with.
            </param>
            <displayName id="GetWorldCellsInAxisAlignedBoundingCube1">
            GetWorldCellsInAxisAlignedBoundingCube(int, Vector3Double, Vector3Double, List&lt;WorldCell&gt;)
            </displayName>
            <syntax>
            public void GetWorldCellsInAxisAlignedBoundingCube(int groupingIndex, Vector3Double min, Vector3Double max, List&lt;WorldCell&gt; worldCellsInArea)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetWorldCellsInAxisAlignedBoundingCube(System.Int32,System.Int32,DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.Vector3Double,System.Collections.Generic.List{DeepSpaceLabs.SAM.WorldCell})">
            <summary>
            Gets all World Cells on the indicated World Grouping and LOD that fall within an axis aligned bounding cube within the scene. This can be used to 
            determine which cells fall within an area of the scene, such as within the Camera's view point (obviously it will be approximate, since 
            the camera viewport is not a cube).
            </summary>
            <param name="groupingIndex" type="int">
            The World Grouping which contains the cells we care about. Only world cells from this World Grouping are added to the worldCellsInArea list.
            </param>
            <param name="LOD" type="int">
            The LOD whose cells we care about. Only world cells that are part of this LOD will be added to the worldCellsInArea list.
            </param>
            <param name="min" type="Vector3Double" link="Vector3Double.html">
            The lower left point on the cube.
            </param>
            <param name="max" type="Vector3Double" link="Vector3Double.html">
            The upper right point on the cube.
            </param>
            <param name="worldCellsInArea" type="List&lt;WorldCell&gt;" link="WorldCell.html">
            The list which the world cells will be added to. The method will not clear this list, so be cautious if it is not empty to begin with.
            </param>
            <displayName id="GetWorldCellsInAxisAlignedBoundingCube2">
            GetWorldCellsInAxisAlignedBoundingCube(int, int, Vector3Double, Vector3Double, List&lt;WorldCell&gt;)
            </displayName>
            <syntax>
            public void GetWorldCellsInAxisAlignedBoundingCube(int groupingIndex, int LOD, Vector3Double min, Vector3Double max, List&lt;WorldCell&gt; worldCellsInArea)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.GetEndlessGridCellsInAxisAlignedBoundingCube(System.Int32,DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.Vector3Double,System.Collections.Generic.List{DeepSpaceLabs.SAM.CellAndIndex})">
            <summary>
            Gets all Endless Grid Cells on the indicated World Grouping that fall within an axis aligned bounding cube within the scene. This can be used to 
            determine which cells fall within an area of the scene, such as within the Camera's view port (obviously it will be approximate, since 
            the camera viewport is not a cube).
            <para>
            Unlike the GetWorldCellsInAxisAlignedBoundingCube method, this one deals with Endless Grid Cells rather than World Cells, so it is not concerned with 
            what cells are currently loaded, but instead which cells (loaded or unloaded) fall within the given area.
            </para>
            <para>
            If you need additional information about the cells you can query the World. For instance, if you want to know the dimensions of one of the cells, you 
            can use the <see cref="M:DeepSpaceLabs.SAM.World.GetBoundsOfEndlessGridCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)" href="#GetBoundsOfEndlessGridCell">GetBoundsOfEndlessGridCell</see> method.
            </para>
            <para>
            Each cell is a CellAndIndex that contains the endless grid cell and the zone that cell is a party of. Since gaps can exist between Zones, it is 
            possible that the bounding box does not overlap any cells!
            </para>
            </summary>
            <param name="groupingIndex" type="int">
            The World Grouping which contains the cells we care about. Only world cells from this World Grouping are added to the endlessGridCellsInArea list.
            </param>
            <param name="min" type="Vector3Double" link="Vector3Double.html">
            The lower left point on the cube.
            </param>
            <param name="max" type="Vector3Double" link="Vector3Double.html">
            The upper right point on the cube.
            </param>
            <param name="endlessGridCellsInArea" type="List&lt;CellAndIndex&gt;" link="CellAndIndex.html">
            The list which the endless grid cells will be added to. The method will not clear this list, so be cautious if it is not empty to begin with.
            <para>
            CellAndIndex is used in order that you can identify the Zone that each cell is in (Index property).
            </para>
            </param>
            <displayName id="GetEndlessGridCellsInAxisAlignedBoundingCube">
            GetEndlessGridCellsInAxisAlignedBoundingCube(int, Vector3Double, Vector3Double, List&lt;CellAndIndex&gt;)
            </displayName>
            <syntax>
            public void GetEndlessGridCellsInAxisAlignedBoundingCube(int groupingIndex, Vector3Double min, Vector3Double max, List&lt;CellAndIndex&gt; endlessGridCellsInArea)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_SingleImmediate(DeepSpaceLabs.SAM.Vector3Double)">
            <summary>
            Translates a position relative to the scene (World Space) to a position relative to the Origin Cell of this World.
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            Truthfully, you can use any Endless Grid Cell for this purpose, including the cell that the position actually falls within, however in some 
            instances using the Origin Cell as the reference is easier.
            </para>
            <para>
            <b>Note, if your World Origin Position 0,0,0</b>, then the Origin Cell relative position will be equivalent to the position within the scene, 
            so calling this method is redundant. Just save the scene position along with the current Origin Cell.
            </para>
            <para>
            In either case, when the position is saved for reuse or sent somewhere else, the Origin Cell needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via one of the 
            cell relative to scene relative position conversion methods. You can use the <see cref="P:DeepSpaceLabs.SAM.World.OriginCell" href="#OriginCell">Origin Cell</see> property for this purpose. Note that you must record 
            the Origin Cell that is set at the time of saving/sending the position, since this Origin Cell may change in the future.
            </para>
            <para>
            <bold>Note regarding performance critical code: </bold>If you wish to perform batch 
            conversions of scene relative positions to Origin Cell relative positions, you are 
            better off not using this method and instead using the batch conversion methods.
            </para>
            <para>
            <bold>Final Note!</bold> Use of this method is only recommended if your game layout is stable, which is to say your Zone positions within the 
            game world will not move in the future. If your zones are not stable and might be moved, you should use one of the methods that gives you a 
            Zone Cell relative position. If you do not heed this advice, when you move your Zone, the position will not move in conjuction with the zone 
            position change!
            </para>
            </summary>
            <param name="sceneRelativePosition" type="Vector3Double" link="Vector3Double.html">
            The scene relative position to translate.
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The translated World Origin Cell relative position.
            </returns>
            <displayName id="TranslateSceneRelativePositionToOriginCellRelativePosition_SingleImmediate">
            TranslateSceneRelativePositionToOriginCellRelativePosition_SingleImmediate(Vector3Double)
            </displayName>
            <syntax>
            public Vector3Double TranslateSceneRelativePositionToOriginCellRelativePosition_SingleImmediate(Vector3Double sceneRelativePosition)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double})">
            <summary>
            Uses a single frame approach to translate an array of positions relative to the scene (World Space) to positions relative 
            to the Origin Cell of World Grouping 1 on this world. 
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            Truthfully, you can use any Endless Grid Cell for this purpose, including the cell that the position actually falls within, however in some 
            instances using the Origin Cell as the reference is easier.
            </para>
            <para>
            <b>Note, if your World Origin Position 0,0,0</b>, then the Origin Cell relative position will be equivalent to the position within the scene, 
            so calling this method is redundant. Just save the scene position along with the current Origin Cell.
            </para>
            <para>
            In either case, when the position is saved for reuse or sent somewhere else, the Origin Cell needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via one of the 
            cell relative to scene relative position conversion methods. You can use the <see cref="P:DeepSpaceLabs.SAM.World.OriginCell" href="#OriginCell">Origin Cell</see> property for this purpose. Note that you must record 
            the Origin Cell that is set at the time of saving/sending the position, since this Origin Cell may change in the future.
            </para>
            <para>
            <bold>Note regarding performance critical code: </bold>If you wish to perform batch 
            conversions of scene relative positions to Origin Cell relative positions, you are 
            better off not using this method and instead using the batch conversion methods.
            </para>
            <para>
            <bold>Final Note!</bold> Use of this method is only recommended if your game layout is stable, which is to say your Zone positions within the 
            game world will not move in the future. If your zones are not stable and might be moved, you should use one of the methods that gives you a 
            Zone Cell relative position. If you do not heed this advice, when you move your Zone, the position will not move in conjuction with the zone 
            position change!
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the method completes, will contain the translated origin relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <displayName id="TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediate">
            TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;)
            </displayName>
            <syntax>
            public Vector3Double TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell[],System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double})" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediate">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell[],System.Int32)" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediateEnumerator">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated origin relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="originCellPositionsAreRelativeTo" type ="Cell[]" link="Cell.html">
            An array initialized with at least a lenght of 1. After onCompletedCallback is invoked, index 0 of this array will contain the Origin Cell of 
            the World at the time of the conversion. You should store this Origin Cell along with the positions so that they can be converted back to 
            scene relative positions at a later time.
            </param>
            <param name="minConversionsProcessedPerFrame" type = "int">
            The mininum number of positions that will be converted each frame. Once this limit is reached, the World will query the 
            Execution Controller to determine if it should yield or continue converting more positions.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the originCellRelativePositions and 
            originCellPositionsAreRelativeTo will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateSceneRelativePositionToOriginCellRelativePosition_BatchDelayedEnumerator">
            TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell[], int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell[] originCellPositionsAreRelativeTo, int minConversionsProcessedPerFrame, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell[],System.Int32)">
            <summary>
            Similar to 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double})" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediate">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames using an iterator whose execution you must drive.
            <para>
            This means the execution of the batch conversion starts, continues, and finishes only if you drive it, usually using 
            StartCoroutine or from another iterator based method that has been started using that method (although technically this 
            method only yield returns null, so you can also drive it from a regular Update method as well).
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, you should use <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell[],System.Int32,System.Action{DeepSpaceLabs.SAM.World})" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchDelayedEnumerator">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see>
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated origin relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="originCellPositionsAreRelativeTo" type ="Cell[]" link="Cell.html">
            An array initialized with at least a lenght of 1. After onCompletedCallback is invoked, index 0 of this array will contain the Origin Cell 
            that was used to perform the conversion. You should store this Origin Cell along with the positions so that they can be converted back to 
            scene relative positions at a later time.
            </param>
            <param name="maxConversionsProcessedPerFrame" type = "int">
            The maximum number of positions that will be converted each frame. Once this limit is reached, the enumerator will yield for a frame.
            </param>
            <displayName id="TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediateEnumerator">
            TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell[], int)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell[] originCellPositionsAreRelativeTo, int maxConversionsProcessedPerFrame)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double})" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediate">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Boolean)" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediateJobs">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated origin relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed.
            </param>
            <param name="originCellPositionsAreRelativeTo" type ="NativeArray&lt;Cell&gt;" link="Cell.html">
            An NativeArray initialized with at least a lenght of 1. After onCompletedCallback is invoked, index 0 of this array will contain the Origin Cell 
            that was used to perform the conversion. You should store this Origin Cell along with the positions so that they can be converted back to 
            scene relative positions at a later time.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the originCellRelativePositions and 
            originCellPositionsAreRelativeTo will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateSceneRelativePositionToOriginCellRelativePosition_BatchDelayedJobs">
            TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; originCellPositionsAreRelativeTo, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Boolean)">
            <summary>
            Similar to 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double})" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediate">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, you should use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Action{DeepSpaceLabs.SAM.World})" href="#TranslateSceneRelativePositionToOriginCellRelativePosition_BatchDelayedJobs">TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated origin relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed.
            </param>
            <param name="originCellPositionsAreRelativeTo" type ="NativeArray&lt;Cell&gt;" link="Cell.html">
            An NativeArray initialized with at least a lenght of 1. After onCompletedCallback is invoked, index 0 of this array will contain the Origin Cell 
            that was used to perform the conversion. You should store this Origin Cell along with the positions so that they can be converted back to 
            scene relative positions at a later time.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the translation will be scheduled and started before the JobHandle is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <displayName id="TranslateSceneRelativePositionToOriginCellRelativePosition_BatchImmediateJobs">
            TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, [bool])
            </displayName>
            <syntax>
            public JobHandle TranslateSceneRelativePositionToOriginCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; originCellPositionsAreRelativeTo, bool initializeWorkImmediately = true)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            <returns>
            The scheduled Job Handle. Use IsCompleted to check if the jobs are finished, then when it is true call 
            JobHandle.Complete to finalize the data (not strictly sure if this is necessary but it shouldn't hurt anything to do it).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateOriginCellRelativePositionToSceneRelativePosition(DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.Cell)">
            <summary>
            Translates a position relative to the input Endless Grid Cell (cellInputPositionIsRelativeTo) to a position relative to the scene (World Space). The input cell 
            is associated with a World Grouping, which is specified via groupingIndex.
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            These positions can be used along with the cell they are relative to in order to produce a scene relative position, which you can then use to 
            position the objects correctly.
            </para>
            <para>
            When the position is saved for reuse or sent somewhere else, the input cell needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via this method.
            </para>
            <para>
            If you wish to translate multiple positions, you may wish to use one of the BatchConversion methods instead.
            </para>
            </summary>
            <param name="cellRelativePosition" type="Vector3Double" link="Vector3Double.html">
            The cell relative position to translate.
            </param>
            <param name="originCellInputPositionIsRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input position is relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionIsRelativeTo is on.
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The position relative to the scene (World Space).
            </returns>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_SingleImmediate">
            TranslateCellRelativePositionToSceneRelativePosition(Vector3Double, Cell, int)
            </displayName>
            <syntax>
            public Vector3Double TranslateCellRelativePositionToSceneRelativePosition(Vector3Double cellRelativePosition, Cell cellInputPositionIsRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateOriginCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell)">
            <summary>
            Uses a single frame approach to translate multiple positions relative to a single Endless Grid Cell (cellInputPositionIsRelativeTo) to positions relative to the scene (World Space). 
            The input cell is associated with a World Grouping, which is specified via groupingIndex.
            <para>
            This methods uses a single list for the positions to save on space. After 
            the method runs, each position in the positions list will be replaced by the translated scene relative position. If for some reason you need to make 
            use of the cell relative positions after the method is run, you will need to make a copy of the list before calling this method.
            </para>
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            These positions can be used along with the cell they are relative to in order to produce a scene relative position, which you can then use to 
            position the objects correctly.
            </para>
            <para>
            When the position is saved for reuse or sent somewhere else, the input cell needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via this method.
            </para>
            <para>
            This method is carried out in a single frame, and when you have a large number of positions to translate this may cause a performance hitch. 
            In that situation, you should use one of the other batch conversion methods.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the method completes, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="originCellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input position is relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellPositionsAreRelativeTo is on.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediate">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateOriginCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediateEnumerator">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="originCellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            <param name="minConversionsProcessedPerFrame" type = "int">
            The mininum number of positions that will be converted each frame. Once this limit is reached, the World will query the 
            Execution Controller to determine if it should yield or continue converting more positions.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the sceneRelativePositions 
            will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchDelayedEnumerator">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, int minConversionsProcessedPerFrame, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateOriginCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32)">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames using an iterator whose execution you must drive.
            <para>
            This means the execution of the batch conversion starts, continues, and finishes only if you drive it, usually using 
            StartCoroutine or from another iterator based method that has been started using that method (although technically this 
            method only yield returns null, so you can also drive it from a regular Update method as well).
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int, Action&lt;World&gt;)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchDelayedEnumerator">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="originCellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            /// <param name="maxConversionsProcessedPerFrame" type = "int">
            The maximum number of positions that will be converted each frame. Once this limit is reached, the enumerator will yield for a frame.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediateEnumerator">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, int maxConversionsProcessedPerFrame)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateOriginCellRelativePositionToSceneRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            </para>
            <para>
            In these instances, use 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, bool)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchImmediateJobs">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed.
            </param>
            <param name="originCellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the sceneRelativePositions 
            will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_BatchDelayedJobs">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateOriginCellRelativePositionToSceneRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Boolean)">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, Action&lt;World&gt;)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchDelayedJobs">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish
            before 4 frames have passed.
            </param>
            <param name="originCellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the translation will be scheduled and started before the JobHandle is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediateJobs">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, [bool])
            </displayName>
            <syntax>
            public JobHandle TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, bool initializeWorkImmediately = true)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns>
            The scheduled Job Handle. Use IsCompleted to check if the jobs are finished, then when it is true call 
            JobHandle.Complete to finalize the data (not strictly sure if this is necessary but it shouldn't hurt anything to do it).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition(DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Translates a single position relative to the scene (World Space) to a position relative to the input Endless Grid Cell (cellOutputPositionIsRelativeTo) on the World Grouping specified.
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position.
            </para>
            <para>
            When the position is saved for reuse or sent somewhere else, the input cell needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via one of the cell relative to 
            scene relative position conversion methods.
            </para>
            <para>
            If you need to convert multiple positions you may be better off using one of the BatchConversion methods of the same name.
            </para>
            </summary>
            <param name="sceneRelativePosition" type="Vector3Double" link="Vector3Double.html">
            The scene relative position to translate.
            </param>
            <param name="cellOutputPositionIsRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the output position will be relative to.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionIsRelativeTo belongs to.
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The position relative to cellOutputPositionIsRelativeTo.
            </returns>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_SingleImmediate">
            TranslateSceneRelativePositionToCellRelativePosition(Vector3Double, Cell, int)
            </displayName>
            <syntax>
            public Vector3Double TranslateSceneRelativePositionToCellRelativePosition(Vector3Double sceneRelativePosition, Cell cellOutputPositionIsRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Uses a single frame conversion process to translate an list of positions relative to the scene (World Space) to positions relative 
            to a specific Endless Grid Cell on the World Grouping specified.
            <para>
            This methods uses a single list for the positions to save on space. After 
            the method runs, each position in the positions list will be replaced by the translated cell relative position. If for some reason you need to make 
            use of the scene relative positions after the method is run, you will need to make a copy of the list before calling this method.
            </para>
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            Truthfully, you can use any Endless Grid Cell for this purpose, including the Origin Cell, however in some 
            instances using a specific cell (other than the Origin Cell) is easier.
            </para>
            <para>
            In either case, when the position is saved for reuse or sent somewhere else, the reference cell needs to also 
            be recorded or sent so that the positions can be translated back into scene relative positions via one of the 
            cell relative to scene relative positions batch conversion methods.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the method runs, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellOutputPositionsAreRelativeTo" type="Cell" link="Cell.html">
            The reference Endless Grid Cell to use to find the relative position. All positions in cellRelativePositions will be relative to this cell, i.e., a value of 
            x = 100, y = 200 means the position is 100/200 units away from the x/y position of the cell.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediate">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellOutputPositionsAreRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)" href="#TranslateCellRelativePositionToSceneRelativePosition_RCK_BatchImmediateEnumerator">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
             When passed in, contains the scene relative positions to translate. Once the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellOutputPositionsAreRelativeTo" type="Cell" link="Cell.html">
            The reference Endless Grid Cell to use to find the relative position. All positions in cellRelativePositions will be relative to this cell, i.e., a value of 
            x = 100, y = 200 means the position is 100/200 units away from the x/y position of the cell.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <param name="minConversionsProcessedPerFrame" type = "int">
            The mininum number of positions that will be converted each frame. Once this limit is reached, the World will query the 
            Execution Controller to determine if it should yield or continue converting more positions.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the cellRelativePositions 
            will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchDelayedEnumerator">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellOutputPositionsAreRelativeTo, int groupingIndex, int minConversionsProcessedPerFrame, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32)">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames using an iterator whose execution you must drive.
            <para>
            This means the execution of the batch conversion starts, continues, and finishes only if you drive it, usually using 
            StartCoroutine or from another iterator based method that has been started using that method (although technically this 
            method only yield returns null, so you can also drive it from a regular Update method as well).
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int, Action&lt;World&gt;)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchDelayedEnumerator">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
             When passed in, contains the scene relative positions to translate. Once the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellOutputPositionsAreRelativeTo" type="Cell" link="Cell.html">
            The reference Endless Grid Cell to use to find the relative position. All positions in cellRelativePositions will be relative to this cell, i.e., a value of 
            x = 100, y = 200 means the position is 100/200 units away from the x/y position of the cell.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <param name="maxConversionsProcessedPerFrame" type = "int">
            The maximum number of positions that will be converted each frame. Once this limit is reached, the enumerator will yield for a frame.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediateEnumerator">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellOutputPositionsAreRelativeTo, int groupingIndex, int maxConversionsProcessedPerFrame)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, bool)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediateJobs">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellOutputPositionsAreRelativeTo" type="Cell" link="Cell.html">
            The reference Endless Grid Cell to use to find the relative position. All positions in cellRelativePositions will be relative to this cell, i.e., a value of 
            x = 100, y = 200 means the position is 100/200 units away from the x/y position of the cell.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the cellRelativePositions 
            will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchDelayedJobs">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, Cell cellOutputPositionsAreRelativeTo, int groupingIndex, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, Action&lt;World&gt;)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchDelayedJobs">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellOutputPositionsAreRelativeTo" type="Cell" link="Cell.html">
            The reference Endless Grid Cell to use to find the relative position. All positions in cellRelativePositions will be relative to this cell, i.e., a value of 
            x = 100, y = 200 means the position is 100/200 units away from the x/y position of the cell.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the translation will be scheduled and started before the JobHandle is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCK_BatchImmediateJobs">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, [bool])
            </displayName>
            <syntax>
            public JobHandle TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, Cell cellOutputPositionsAreRelativeTo, int groupingIndex, bool initializeWorkImmediately = true)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns>
            The scheduled Job Handle. Use IsCompleted to check if the jobs are finished, then when it is true call 
            JobHandle.Complete to finalize the data (not strictly sure if this is necessary but it shouldn't hurt anything to do it).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition(DeepSpaceLabs.SAM.Vector3Double,System.Int32,System.Int32,DeepSpaceLabs.SAM.Cell@)">
            <summary>
            This method first identifies the Endless Grid Cell on the Zone and World Grouping specified that the input scene relative position is in, then translates the 
            scene relative position to a position relative to this cell (and returns it).
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position.
            </para>
            <para>
            When the position is saved for reuse or sent somewhere else, the cell the position is relative to also needs to  
            be recorded or sent so that the position can be translated back into a scene relative position via one of the cell relative to 
            scene relative position conversion methods.
            </para>
            <para>
            If you need to convert multiple positions you may be better off using one of the BatchConversion methods of the same name.
            </para>
            </summary>
            <param name="sceneRelativePosition" type="Vector3Double" link="Vector3Double.html">
            The scene relative position to translate.
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionIsRelativeTo belongs to.
            </param>
            <param name="cellOutputPositionIsRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the output position will be relative to (will be set after method returns).
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The position relative to cellOutputPositionIsRelativeTo.
            </returns>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCU_SingleImmediate">
            TranslateSceneRelativePositionToCellRelativePosition(Vector3Double, int, out Cell)
            </displayName>
            <syntax>
            public Vector3Double TranslateSceneRelativePositionToCellRelativePosition(Vector3Double sceneRelativePosition, int groupingIndex, out Cell cellOutputPositionIsRelativeTo)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32)">
            <summary>
            Uses a single frame based approach to identify the Endless Grid Cell each scene relative position is in, and then translate each scene relative position 
            to a position relative to that cell. 
            <para>
            This methods uses a single list for the positions to save on space. After 
            the method runs, each position in the positions list will be replaced by the translated cell relative position. If for some reason you need to make 
            use of the scene relative positions after the method is run, you will need to make a copy of the list before calling this method.
            </para>
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            Truthfully, you can use any Endless Grid Cell for this purpose, including the Origin Cell, however in some 
            instances using a specific cell (other than the Origin Cell) is easier.
            </para>
            <para>
            In either case, when the positions are saved for reuse or sent somewhere else, the cells the position are relative to also need to  
            be recorded or sent so that the positions can be translated back into scene relative positions via one of the cell relative to 
            scene relative positions batch conversion methods.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the method runs, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellsOutputPositionsAreRelativeTo" type="List&lt;Cell&gt;" link="Cell.html">
            Once the method completes, will contain the Endless Grid Cells that each input position is in. If you cleared this list before calling the method, the indexes 
            will correspond perfectly with the positions list (otherwise the list is not cleared by this method, so if it contains elements before being called 
            they will still be there!).
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellsOutputPositionsAreRelativeTo belongs to.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediate">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, List&lt;Cell&gt; cellsOutputPositionsAreRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32)" href="#TranslateCellRelativePositionToSceneRelativePosition_RCU_BatchImmediateEnumerator">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
             When passed in, contains the scene relative positions to translate. Once the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellsOutputPositionsAreRelativeTo" type="List&lt;Cell&gt;" link="Cell.html">
            Once the onCompletedCallback action is triggered, will contain the Endless Grid Cells that each input position is in. 
            If you cleared this list before calling the method, the indexes 
            will correspond perfectly with the positions list (otherwise the list is not cleared by this method, so if it contains elements they will remain 
            there!).
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <param name="minConversionsProcessedPerFrame" type = "int">
            The mininum number of positions that will be translated each frame. Once this limit is reached, the World will query the 
            Execution Controller to determine if it should yield or continue translating more positions.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the data will not be valid until it is triggered.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchDelayedEnumerator">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, List&lt;Cell&gt; cellsOutputPositionsAreRelativeTo, int groupingIndex, int minConversionsProcessedPerFrame, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Int32)">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames using an iterator whose execution you must drive.
            <para>
            This means the execution of the batch conversion starts, continues, and finishes only if you drive it, usually using 
            StartCoroutine or from another iterator based method that has been started using that method (although technically this 
            method only yield returns null, so you can also drive it from a regular Update method as well).
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int, int, Action&lt;World&gt;)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchDelayedEnumerator">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see>
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
             When passed in, contains the scene relative positions to translate. Once the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellsOutputPositionsAreRelativeTo" type="List&lt;Cell&gt;" link="Cell.html">
            Once the onCompletedCallback action is triggered, will contain the Endless Grid Cells that each input position is in. 
            If you cleared this list before calling the method, the indexes 
            will correspond perfectly with the positions list (otherwise the list is not cleared by this method, so if it contains elements they will remain 
            there!).
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            /// <param name="maxConversionsProcessedPerFrame" type = "int">
            The maximum number of positions that will be converted each frame. Once this limit is reached, the enumerator will yield for a frame.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediateEnumerator">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int, int)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, List&lt;Cell&gt; cellsOutputPositionsAreRelativeTo, int groupingIndex, int maxConversionsProcessedPerFrame)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, bool)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediateJobs">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellsOutputPositionsAreRelativeTo" type="NativeArray&lt;Cell&gt;" link="Cell.html">
            Once the onCompletedCallback action is triggered, will contain the Endless Grid Cells that each input position is in. 
            If you cleared this list before calling the method, the indexes 
            will correspond perfectly with the positions list (otherwise the list is not cleared by this method, so if it contains elements they will remain 
            there!).
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the cellRelativePositions 
            will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchDelayedJobs">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; cellsOutputPositionsAreRelativeTo, int groupingIndex, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Similar to 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediate">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use 
            <see cref="!:TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, Action&lt;World&gt;)" href="#TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchDelayedJobs">TranslateSceneRelativePositionToCellRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the scene relative positions to translate. After the onCompletedCallback action triggers, will contain the translated cell relative 
            positions. This uses a list so that you can reuse the list over and over again, if you desire.
            </param>
            <param name="cellsOutputPositionsAreRelativeTo" type="NativeArray&lt;Cell&gt;" link="Cell.html">
            Once the onCompletedCallback action is triggered, will contain the Endless Grid Cells that each input position is in. 
            If you cleared this list before calling the method, the indexes 
            will correspond perfectly with the positions list (otherwise the list is not cleared by this method, so if it contains elements they will remain 
            there!).
            </param>
            <param name="groupingIndex" type="int">
            The World Grouping which the cellOutputPositionsAreRelativeTo belongs to.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the translation will be scheduled and started before the JobHandle is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <displayName id="TranslateSceneRelativePositionToCellRelativePosition_RCU_BatchImmediateJobs">
            TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, [bool])
            </displayName>
            <syntax>
            public JobHandle TranslateSceneRelativePositionToCellRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; cellsOutputPositionsAreRelativeTo, int groupingIndex, bool initializeWorkImmediately = true)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            <returns>
            The scheduled Job Handle. Use IsCompleted to check if the jobs are finished, then when it is true call 
            JobHandle.Complete to finalize the data (not strictly sure if this is necessary but it shouldn't hurt anything to do it).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition(DeepSpaceLabs.SAM.Vector3Double,DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Translates a position relative to the input Endless Grid Cell (cellInputPositionIsRelativeTo) to a position relative to the scene (World Space). The input cell 
            is associated with a World Grouping, which is specified via groupingIndex.
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            These positions can be used along with the cell they are relative to in order to produce a scene relative position, which you can then use to 
            position the objects correctly.
            </para>
            <para>
            When the position is saved for reuse or sent somewhere else, the input cell needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via this method.
            </para>
            <para>
            If you wish to translate multiple positions, you may wish to use one of the BatchConversion methods instead.
            </para>
            </summary>
            <param name="cellRelativePosition" type="Vector3Double" link="Vector3Double.html">
            The cell relative position to translate.
            </param>
            <param name="cellInputPositionIsRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input position is relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionIsRelativeTo is on.
            </param>
            <returns type="Vector3Double" link="Vector3Double.html">
            The position relative to the scene (World Space).
            </returns>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_SingleImmediate">
            TranslateCellRelativePositionToSceneRelativePosition(Vector3Double, Cell, int)
            </displayName>
            <syntax>
            public Vector3Double TranslateCellRelativePositionToSceneRelativePosition(Vector3Double cellRelativePosition, Cell cellInputPositionIsRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)">
            <summary>
            Uses a single frame approach to translate multiple positions relative to a single Endless Grid Cell (cellInputPositionIsRelativeTo) to positions relative to the scene (World Space). 
            The input cell is associated with a World Grouping, which is specified via groupingIndex.
            <para>
            This methods uses a single list for the positions to save on space. After 
            the method runs, each position in the positions list will be replaced by the translated scene relative position. If for some reason you need to make 
            use of the cell relative positions after the method is run, you will need to make a copy of the list before calling this method.
            </para>
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            These positions can be used along with the cell they are relative to in order to produce a scene relative position, which you can then use to 
            position the objects correctly.
            </para>
            <para>
            When the position is saved for reuse or sent somewhere else, the input cell needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via this method.
            </para>
            <para>
            This method is carried out in a single frame, and when you have a large number of positions to translate this may cause a performance hitch. 
            In that situation, you should use one of the other batch conversion methods.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the method completes, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="cellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input position is relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellPositionsAreRelativeTo is on.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediate">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediateEnumerator">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="cellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            <param name="minConversionsProcessedPerFrame" type = "int">
            The mininum number of positions that will be converted each frame. Once this limit is reached, the World will query the 
            Execution Controller to determine if it should yield or continue converting more positions.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the sceneRelativePositions 
            will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchDelayedEnumerator">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, int minConversionsProcessedPerFrame, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32)">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames using an iterator whose execution you must drive.
            <para>
            This means the execution of the batch conversion starts, continues, and finishes only if you drive it, usually using 
            StartCoroutine or from another iterator based method that has been started using that method (although technically this 
            method only yield returns null, so you can also drive it from a regular Update method as well).
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int, Action&lt;World&gt;)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchDelayedEnumerator">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="cellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            /// <param name="maxConversionsProcessedPerFrame" type = "int">
            The maximum number of positions that will be converted each frame. Once this limit is reached, the enumerator will yield for a frame.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediateEnumerator">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int, int)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, int maxConversionsProcessedPerFrame)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            </para>
            <para>
            In these instances, use 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, bool)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchImmediateJobs">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed.
            </param>
            <param name="cellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the sceneRelativePositions 
            will not be filled with valid data until this action is called.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_BatchDelayedJobs">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, Cell, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, Action&lt;World&gt;)" href="#TranslateCellRelativePositionToSceneRelativePosition_SRP_BatchDelayedJobs">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish
            before 4 frames have passed.
            </param>
            <param name="cellInputPositionsAreRelativeTo" type ="Cell" link="Cell.html">
            The Endless Grid Cell the input positions are relative to.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellInputPositionsAreRelativeTo is on.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the translation will be scheduled and started before the JobHandle is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_SRC_BatchImmediateJobs">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, Cell, int, [bool])
            </displayName>
            <syntax>
            public JobHandle TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, Cell cellInputPositionsAreRelativeTo, int groupingIndex, bool initializeWorkImmediately = true)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            /// <returns>
            The scheduled Job Handle. Use IsCompleted to check if the jobs are finished, then when it is true call 
            JobHandle.Complete to finalize the data (not strictly sure if this is necessary but it shouldn't hurt anything to do it).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32)">
            <summary>
            Uses a single frame approach to translate multiple positions relative to multiple Endless Grid Cells (cellsInputPositionsAreRelativeTo) to positions relative to the scene (World Space). This is useful when each input position is relative to a different Endless Grid Cell. The input cells are associated with a World Grouping, which is specified via groupingIndex.
            <para>
            This methods uses a single list for the positions to save on space. After 
            the method runs, each position in the positions list will be replaced by the translated scene relative position. If for some reason you need to make 
            use of the cell relative positions after the method is run, you will need to make a copy of the list before calling this method.
            </para>
            <para>
            This method is meant to be used in situations where a floating origin based World is being used (one where its Origin Cell changes). In these situations, raw non static positions cannot 
            be used as normal, because the state of the World at the time the position is being retrieved/used may be different than the state 
            of the World when the position was recorded (i.e., the Origin Cell may be different).
            </para>
            <para>
            The solution to this problem is to save the position value relative to a cell, and then save/send that cell value along with the new relative position. 
            These positions can be used along with the cell they are relative to in order to produce a scene relative position, which you can then use to 
            position the objects correctly.
            </para>
            <para>
            When each position is saved for reuse or sent somewhere else, the cell it is relative to needs to also 
            be recorded or sent so that the position can be translated back into a scene relative position via this method.
            </para>
            <para>
            This method is carried out in a single frame, and when you have a large number of positions to translate this may cause a performance hitch. 
            In that situation, you should use one of the other batch conversion methods.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the method completes, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="cellsInputPositionsAreRelativeTo" type ="List&lt;Cell&gt;" link="Cell.html">
            The Endless Grid Cells the input positions are relative to. Each index from positions is matched to an index from this list, so you need to make sure 
            they match up.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellsInputPositionsAreRelativeTo are on.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediate">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, List&lt;Cell&gt; cellsInputPositionsAreRelativeTo, int groupingIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Using the job based method is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from is not driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. 
            In these instances, use 
            <see cref="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediateEnumerator">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="cellsInputPositionsAreRelativeTo" type ="List&lt;Cell&gt;" link="Cell.html">
            The Endless Grid Cells the input positions are relative to. Each index from positions is matched to an index from this list, so you need to make sure 
            they match up.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellsInputPositionsAreRelativeTo are on.
            </param>
            <param name="minConversionsProcessedPerFrame" type = "int">
            The mininum number of positions that will be converted each frame. Once this limit is reached, the World will query the 
            Execution Controller to determine if it should yield or continue converting more positions.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the positions will not be 
            correctly translated (and thus useable) until the action is triggered.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchDelayedEnumerator">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, List&lt;Cell&gt; cellsInputPositionsAreRelativeTo, int groupingIndex, int minConversionsProcessedPerFrame, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(System.Collections.Generic.List{DeepSpaceLabs.SAM.Vector3Double},System.Collections.Generic.List{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Int32)">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out over multiple frames using an iterator whose execution you must drive.
            <para>
            This means the execution of the batch conversion starts, continues, and finishes only if you drive it, usually using 
            StartCoroutine or from another iterator based method that has been started using that method (although technically this 
            method only yield returns null, so you can also drive it from a regular Update method as well).
            </para>
            <para>
            Using the <see href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediateJobs">job based method</see> is recommend over this one, however this is useful if you wish to avoid jobs for some reason.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int, int, Action&lt;World&gt;)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchDelayedJobs">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="List&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. You can reuse the list over and over again, however you should make sure to clear it first.
            </param>
            <param name="cellsInputPositionsAreRelativeTo" type ="List&lt;Cell&gt;" link="Cell.html">
            The Endless Grid Cells the input positions are relative to. Each index from positions is matched to an index from this list, so you need to make sure 
            they match up.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellsInputPositionsAreRelativeTo are on.
            </param>
            <param name="maxConversionsProcessedPerFrame" type = "int">
            The maximum number of positions that will be converted each frame. Once this limit is reached, the enumerator will yield for a frame.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediateEnumerator">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int, int)
            </displayName>
            <syntax>
            public IEnumerator&lt;YieldInstruction&gt; TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt; positions, List&lt;Cell&gt; cellsInputPositionsAreRelativeTo, int groupingIndex, int maxConversionsProcessedPerFrame)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            <returns type = "IEnumerator&lt;YieldInstruction&gt;">
            An IEnumerator&lt;YieldInstruction&gt; that can be iterated over or used as a coroutine. See the 
            <see href="YieldInstruction.html">YieldInstruction</see> page for more info.
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the scheduling of the batch conversion jobs will be delayed until the current World update (if any) completes. Once the 
            jobs are scheduled, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            Use this method only if the execution of the method you are calling it from IS NOT driven by the World. If the execution is driven 
            by the World (one of the methods of the World Grouping Listener, for example), using this method will stall out the World. In that case, 
            use <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, bool)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediateJobs">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed.
            </param>
            <param name="cellsInputPositionsAreRelativeTo" type ="NativeArray&lt;Cell&gt;" link="Cell.html">
            The Endless Grid Cells the input positions are relative to. Each index from positions is matched to an index from this array, so you need to make sure 
            they match up. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed. You also need to dispose of this array yourself!
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellsInputPositionsAreRelativeTo are on.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;" link="World.html">
            Action which will be triggered after the conversion is complete. You must provide this because the positions 
            will not be correctly translated (and thus useable) until the action is triggered.
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchDelayedJobs">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, Action&lt;World&gt;)
            </displayName>
            <syntax>
            public void TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; cellsInputPositionsAreRelativeTo, int groupingIndex, Action&lt;World&gt; onCompletedCallback)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Vector3Double},Unity.Collections.NativeArray{DeepSpaceLabs.SAM.Cell},System.Int32,System.Int32,System.Boolean)">
            <summary>
            Similar to 
            <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(List&lt;Vector3Double&gt;, List&lt;Cell&gt;, int)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediate">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> except the conversions are carried out using the Jobs system as a World secondary operation.
            <para>
            This means the execution of the batch conversion will be delayed until the current World update (if any) completes. Once the 
            batch conversion starts, all World updates are delayed, which is useful as it ensures the state of the World will remain 
            consistent during the conversion process.
            </para>
            <para>
            You should use this method only if the execution of the method you are calling it from IS driven by the 
            World (one of the methods of the World Grouping Listener, for example). If the execution IS NOT driven 
            by the World, using this method can be dangerous as the World's state may change while the conversion is in progress, if for 
            example an Origin Cell is executed during the conversion process. In that case, use <see cref="!:TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, Action&lt;World&gt;)" href="#TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchDelayedJobs">TranslateCellRelativePositionToSceneRelativePosition_BatchConversion</see> instead.
            </para>
            </summary>
            <param name="positions" type="NativeArray&lt;Vector3Double&gt;" link="Vector3Double.html">
            When passed in, contains the cell relative positions to translate. After the onCompletedCallback action triggers, will contain the scene relative 
            positions. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed.
            </param>
            <param name="cellsInputPositionsAreRelativeTo" type ="NativeArray&lt;Cell&gt;" link="Cell.html">
            The Endless Grid Cells the input positions are relative to. Each index from positions is matched to an index from this array, so you need to make sure 
            they match up. It may be necessary to use Persistent Allocation type with the Native Array, since there is no gaurantee that the job will run and finish 
            before 4 frames have passed. You also need to dispose of this array yourself!
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping the cellsInputPositionsAreRelativeTo are on.
            </param>
            <param name="initializeWorkImmediately" type="bool">
            If true, the jobs which perform the translation will be scheduled and started before the JobHandle is returned, using the 
            <see cref="M:Unity.Jobs.JobHandle.ScheduleBatchedJobs" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.ScheduleBatchedJobs.html">JobHandle.ScheduleBatchedJobs</see> method.
            <para>
            If false, the job will be scheduled but the threads will not actually start working on the jobs. This is useful if you have 
            additional jobs that you would like to schedule that depend on the returned JobHandle, as it is more performant to schedule 
            those jobs and then call ScheduleBatchedJobs yourself.
            </para>
            <para>
            Note that if you do not call ScheduleBatchedJobs after passing in 
            false for this parameter, the returned JobHandle will never be completed!
            </para>
            </param>
            <displayName id="TranslateCellRelativePositionToSceneRelativePosition_MRC_BatchImmediateJobs">
            TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt;, NativeArray&lt;Cell&gt;, int, [bool])
            </displayName>
            <syntax>
            public JobHandle TranslateCellRelativePositionToSceneRelativePosition_BatchConversion(NativeArray&lt;Vector3Double&gt; positions, NativeArray&lt;Cell&gt; cellsInputPositionsAreRelativeTo, int groupingIndex, bool initializeWorkImmediately = true)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initialized.
            </exception>
            <returns>
            The scheduled Job Handle. Use IsCompleted to check if the jobs are finished, then when it is true call 
            JobHandle.Complete to finalize the data (not strictly sure if this is necessary but it shouldn't hurt anything to do it).
            </returns>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.CreateWorldCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> based on the passed in endlessGridCell, 
            LOD, World Grouping index, and Zone index. The data will be properly set, 
            and the World Cell will be setup to be able to receive chunk attachments, however no objects will actually be associated 
            with this Cell. 
            <para>
            There are few use cases where you would need to use this method, one of them being when creating custom 
            Chunk Managers that have pooled objects no longer associated with a World Cell that you need to unload.
            </para>
            <para>
            In that case, in order to unload them properly with an existing Chunk Streamer, you can generate a sort of dummy 
            World Cell using this method, attach your objects to the cell, and then use the DetachAndUnloadChunksFromCells method 
            of the Chunk Streamer to unload the objects.
            </para>
            <para>
            When creating a World Cell using this method, it is not used internallly by SAM at all. It's for your own use only. The 
            objects are generated using the internal pool of World Cells, so the type of the World Cell may be a WorldCellWithTerrain if 
            the LOD and World Grouping index you pass in reference an LOD Group that utilizes terrain.
            </para>
            <para>
            The internal array that stores game objects within the World Cell will be configured properly so that you can attach chunks 
            to the cell via the WorldCell.AttachChunkToCell method.
            </para>
            <para>
            You can return the WorldCell for pooling after you are done with it by calling the 
            <see cref="M:DeepSpaceLabs.SAM.World.ReturnWorldCellForPooling(DeepSpaceLabs.SAM.WorldCell)" href="#ReturnWorldCellForPooling">ReturnWorldCellForPooling</see> method.
            </para>
            <para>
            Note, if you have created a World Cell already for an Endless Grid Cell, and you need another World Cell for the same 
            Endless Grid Cell, it is faster to use the 
            <see cref="M:DeepSpaceLabs.SAM.World.CreateWorldCellCopy(DeepSpaceLabs.SAM.WorldCell)" href="#CreateWorldCellCopy">CreateWorldCellCopy</see> method rather than this one (assuming you have not returned 
            the first World Cell).
            </para>
            </summary>
            <param name="endlessGridCell" type="Cell" link="Cell.html">
            The Endless Grid Cell of the World Cell. This is used to calculate all the data of the World Cell.
            </param>
            <param name="LOD" type="int">
            The LOD of the cell, also used to calculate the data of the World Cell, and set its number of chunks properly.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping you want to use to create the cell, also used to setup data correctly.
            </param>
            <param name="zoneIndex" type="int">
            The Zone you want to use to create the cell, also used to setup data correctly.
            </param>
            <returns type="WorldCell" link="WorldCell.html">
            The created World Cell.
            </returns>
            <displayName id="CreateWorldCell">
            CreateWorldCell(Cell, int, int, int)
            </displayName>
            <syntax>
            public WorldCell CreateWorldCell(Cell endlessGridCell, int LOD, int groupingIndex, int zoneIndex)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            thrown when the method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.CreateWorldCellCopy(DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Creates a <see cref="T:DeepSpaceLabs.SAM.WorldCell" href="WorldCell.html">World Cell</see> 
            as a copy of another World Cell. If there are chunks associated with the World Cell, they will 
            not be copied over to the new cell, however the new cell will be properly setup to be able to store the proper number of 
            Asset Chunks.
            <para>
            There are few use cases where you would need to use this method, one of them being when creating custom 
            Chunk Managers that have pooled objects no longer associated with a World Cell that you need to unload.
            </para>
            <para>
            In that case, in order to unload them properly with an existing Chunk Streamer, you can generate a sort of dummy 
            World Cell using the <see cref="M:DeepSpaceLabs.SAM.World.CreateWorldCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32)" href="World.html#CreateWorldCell">CreateWorldCell</see> method, 
            and then for each additional World Cell you need to represent the same Endless Grid Cell, use this method 
            to generate a new World Cell. This is faster than using CreateWorldCell multiple times for the same Endless Grid Cell.
            </para>
            <para>
            When creating a World Cell using this method, it is not used internallly by SAM at all. It's for your own use only. The 
            World Cell is generated using the internal pool of World Cells, so the type of the World Cell may be a WorldCellWithTerrain if 
            the LOD and World Grouping index you pass in reference an LOD that utilizes terrain.
            </para>
            <para>
            The internal array that stores Asset Chunks within the World Cell will be configured properly so that you can attach chunks 
            to the cell via the WorldCell.AttachChunkToCell method.
            </para>
            <para>
            You can return the WorldCell for pooling after you are done with it by calling the 
            <see cref="M:DeepSpaceLabs.SAM.World.ReturnWorldCellForPooling(DeepSpaceLabs.SAM.WorldCell)" href="World.html#ReturnWorldCellForPooling">ReturnWorldCellForPooling</see> method.
            </para>
            </summary>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            The World Cell to copy.
            </param>
            <returns type="WorldCell" link="WorldCell.html">
            The created World Cell.
            </returns>
            <displayName id="CreateWorldCellCopy">
            CreateWorldCellCopy(WorldCell)
            </displayName>
            <syntax>
            public WorldCell CreateWorldCellCopy(WorldCell worldCell)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            thrown when the method is called before the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ReturnWorldCellForPooling(DeepSpaceLabs.SAM.WorldCell)">
            <summary>
            Returns a WorldCell created using 
            <see cref="M:DeepSpaceLabs.SAM.World.CreateWorldCell(DeepSpaceLabs.SAM.Cell,System.Int32,System.Int32,System.Int32)" href="World.html#CreateWorldCell">CreateWorldCell</see> or 
            <see cref="M:DeepSpaceLabs.SAM.World.CreateWorldCellCopy(DeepSpaceLabs.SAM.WorldCell)" href="World.html#CreateWorldCellCopy">CreateWorldCellCopy</see> 
            so that it can be reused by SAM in order to save on memory.
            </summary>
            <param name="worldCell" type="WorldCell" link="WorldCell.html">
            The World Cell to return. Please do not return a World Cell unless it was created using the methods listed above, as 
            if you return a World Cell created internally by SAM, it will cause major issues!
            </param>
            <displayName id="ReturnWorldCellForPooling">
            ReturnWorldCellForPooling(WorldCell)
            </displayName>
            <syntax>
            public void ReturnWorldCellForPooling(WorldCell worldCell)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World is initalized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_EnableWorldRegionAutoLoad(System.Collections.Generic.List{System.Int32},System.Boolean)">
            <summary>
            You can use this method to enable auto loading of World Regions so that they are loaded when the World is initialized (this is in addition to any 
            Regions that have Auto Load enabled in the World's inspector).
            <para>
            Note that unlike the runtime LoadWorldRegion methods, 
            you cannot set clearLoadedWorldRegions since no World Regions are loaded at this point. The Origin Cell data in the World Regions will also be ignored 
            when using this method, so you must use PreInitialize_SetOriginCell if you want to make use of this data.
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="worldRegionNumbers" type="List&lt;int&gt;">
            The numbers of the World Regions to enable auto loading for (numbers are as shown in the World inspector).
            </param>
            <param name="overwriteRegionsInPersistentData" type="bool">
            When the World's persistent data is saved, the World Regions that are currently loaded are saved with the data so that they can be 
            autoamtically loaded when that data is loaded. 
            <para>
            If you pass in true for this argument, the region data in the persistent data will be ingored (if persistent data is loaded).
            </para>
            <para>
            >If you pass in false, when persistent data is loaded, only the 
            World Regions found in the persistent data will be auto-loaded. Any other regions that you have configured to be auto-loaded with this method 
            will not be auto-loaded!
            </para>
            <para>
            If no persistent data is loaded, this value will have no effect.
            </para>
            </param>
            <displayName id="PreInitialize_EnableWorldRegionAutoLoad">
            PreInitialize_EnableWorldRegionAutoLoad(List&lt;int&gt;, bool)
            </displayName>
            <syntax>
            public void PreInitialize_EnableWorldRegionAutoLoad(List&lt;int&gt; worldRegionNumbers, bool overwriteRegionsInPersistentData)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_EnableWorldRegionAutoLoad(System.Collections.Generic.List{System.String},System.Boolean)">
            <summary>
            You can use this method to enable auto loading of World Regions so that they are loaded when the World is initialized (this is in addition to any 
            Regions that have Auto Load enabled in the World's inspector).
            <para>
            Note that unlike the runtime LoadWorldRegion methods, 
            you cannot set clearLoadedWorldRegions since no World Regions are loaded at this point. The Origin Cell data in the World Regions will also be ignored 
            when using this method, so you must use PreInitialize_SetOriginCell if you want to make use of this data.
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="worldRegionNames" type="List&lt;string&gt;">
            The names of the World Regions to enable auto loading for (names are as shown in the World inspector).
            </param>
            <param name="overwriteRegionsInPersistentData" type="bool">
            When the World's persistent data is saved, the World Regions that are currently loaded are saved with the data so that they can be 
            autoamtically loaded when that data is loaded. 
            <para>
            If you pass in true for this argument, the region data in the persistent data will be ingored (if persistent data is loaded).
            </para>
            <para>
            >If you pass in false, when persistent data is loaded, only the 
            World Regions found in the persistent data will be auto-loaded. Any other regions that you have configured to be auto-loaded with this method 
            will not be auto-loaded!
            </para>
            <para>
            If no persistent data is loaded, this value will have no effect.
            </para>
            </param>
            <displayName id="PreInitialize_EnableWorldRegionAutoLoad">
            PreInitialize_EnableWorldRegionAutoLoad(List&lt;string&gt;, bool)
            </displayName>
            <syntax>
            public void PreInitialize_EnableWorldRegionAutoLoad(List&lt;string&gt; worldRegionNames, bool overwriteRegionsInPersistentData)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_SetWorldOrigin(UnityEngine.Vector3,System.Boolean)">
            <summary>
            Changes the World's Origin Position.
            <para>
            This is the only way to change the World Origin position. Once the World is initialized, it's position cannot be modified.
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="newWorldOrigin" type="Vector3Double" link="Vector3Double.html">
            The new world origin.
            </param>
            <param name="overwriteWorldOriginFromPersistentData" type="bool">
            Should the new world origin overwrite the world origin found in persistent data for this World? 
            Has no effect if persistent data is not loaded.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
            <displayName id="PreInitialize_SetWorldOrigin">
            PreInitialize_SetWorldOrigin(Vector3Double, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetWorldOrigin(Vector3Double newWorldOrigin, bool overwriteWorldOriginFromPersistentData)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_SetGroupName(System.String,System.Boolean)">
            <summary>
            Changes the Group Name of Zone 1, Grouping 1's LOD Group 1, allowing for the initial 
            Asset Chunks that are loaded to be different than what they normally are.
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController class, if you need to save 
            different data in different places (on the server, on a file on the users system, etc.). Note, if all your data is stored in the same place, you are 
            better off using a custom class that derives from IPersistentDataController, and then set it up to save data to that location (as Group Name changes 
            are automatically tracked and saved with persistent data).
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="newGroupName" type="string">
            The new Group Name.
            </param>
            <param name="overwriteNameFromPersistentData" type="bool">
            Should the new Group Name overwrite the Group Name found in persistent data for Grouping 1's LOD Group 1? 
            Has no effect if no persistent data is loaded.
            </param>
            <displayName id="PreInitialize_SetGroupName2">
            PreInitialize_SetGroupName(string, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetGroupName(string newGroupName, bool overwriteNameFromPersistentData)
            </syntax>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
            <exception cref="T:UnityEngine.MissingComponentException">
            Thrown if a Streamable Grid is not assigned to the specified World Grouping.
            </exception>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_SetGroupName(System.Int32,System.Int32,System.Int32,System.String,System.Boolean)">
            <summary>
            Changes the Group Name of the specified World Grouping's LOD Group, allowing for the initial 
            Asset Chunks that are loaded to be different than what they normally are.
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController class, if you need to save 
            different data in different places (on the server, on a file on the users system, etc.). Note, if all your data is stored in the same place, you are 
            better off using a custom class that derives from IPersistentDataController, and then set it up to save data to that location (as Group Name changes 
            are automatically tracked and saved with persistent data).
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone whose LOD Group Name you wish to modify.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping whose LOD Group Name you wish to modify.
            </param>
            <param name="lodIndex" type="int">
            The index of the LOD Group on the World Grouping whose Group Name you wish to change.
            </param>
            <param name="newGroupName" type="string">
            The new Group Name.
            </param>
            <param name="overwriteNameFromPersistentData" type="bool">
            Should the new Group Name overwrite the Group Name found in persistent data 
            for this World Grouping's LOD Group? Has no effect if no persistent data is loaded.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when gropuingIndex and/or lodIndex are not valid.
            </exception>
            <exception cref="T:UnityEngine.MissingComponentException">
            Thrown if a Streamable Grid is not assigned to the specified World Grouping.
            </exception>
            <displayName id="PreInitialize_SetGroupName1">
            PreInitialize_SetGroupName(int, int, int, string, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetGroupName(int zoneIndex, int groupingIndex, int lodIndex, string newGroupName, bool overwriteNameFromPersistentData)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_SetGroupNamesForAllLODGroupsOnZoneGrouping(System.Int32,System.Int32,System.String[],System.Boolean,System.Boolean)">
            <summary>
            Changes the Group Names of all LOD Groups on the specified Zone Grouping, allowing for the initial 
            Asset Chunks that are loaded to be different than what they normally are.
            <para>
            If you only want to update some of the LOD's, set the names of LOD's that you don't want to update to null.
            </para>
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController class, if you need to save 
            different data in different places (on the server, on a file on the users system, etc.). Note, if all your data is stored in the same place, you are 
            better off using a custom class that derives from IPersistentDataController, and then set it up to save data to that location (as Group Name changes 
            are automatically tracked and saved with persistent data).
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="newGroupNames" type="string[]">
            The new group names. Set individual indexes to null to avoid replacing that LOD Group's default/saved name.
            </param>
            <param name="ignoreNamesFromPersistentData" type="bool">
            Should the new group names overwrite the group names found in persistent data 
            for this World Grouping? Has no effect if no persistent data is loaded.
            </param>
            <param name="zoneIndex" type="int">
            The index of the Zone whose LOD Group Names you wish to modify.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping whose LOD Group Names you wish to modify.
            </param>
            <param name="applyOverwriteRuleToNullNames" type="bool">
            Should the value passed in for ignoreNamesFromPersistentData be applied to LOD Groups which you are 
            not passing in names for (i.e., the indexes you have set to null in newGroupNames)?
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when groupingIndex is not valid, or if the length of the newGroupNames array does not match the number of LOD Groups on the World Grouping specified.
            </exception>
            <exception cref="T:UnityEngine.MissingComponentException">
            Thrown if a Streamable Grid is not assigned to the specified World Grouping.
            </exception>
            <displayName id="PreInitialize_SetGroupNamesForAllLODGroupsOnWorldGrouping">
            PreInitialize_SetGroupNamesForAllLODGroupsOnWorldGrouping(int, int, string[], bool, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetGroupNamesForAllLODGroupsOnWorldGrouping(int zoneIndex, int groupingIndex, string[] newGroupNames, bool ignoreNamesFromPersistentData, bool applyOverwriteRuleToNullNames)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_SetGroupNamesForZone(System.Int32,System.String[][],System.Boolean,System.Boolean)">
            <summary>
            Changes the Group Names of all LOD Groups on all World Groupings of the Zone specified, allowing for the initial 
            Asset Chunks that are loaded to be different than what they normally are.
            <para>
            If you only want to update some of the LOD Groups, set the names of LOD Groups that you don't want to update to null (as Group Name changes 
            are automatically tracked and saved with persistent data).
            </para>
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController class, if you need to save 
            different data in different places (on the server, on a file on the users system, etc.). Note, if all your data is stored in the same place, you are 
            better off using a custom class that derives from IPersistentDataController, and then set it up to save data to that location (as Group Name changes 
            are automatically tracked and saved with persistent data).
            </para>
            <para>
            It is possible for a Zone to have some World Groupings not in use (by not supplying a Streamable Grid to it). When such a World Grouping is 
            encountered, no Group Name changes will be applied to it, so it's typically a good idea to set those indexes in the array to null 
            (via newGroupNames[someIndex] = null).
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone whose Group Names you wish to modify.
            </param>
            <param name="newGroupNames" type="string[][]">
            The new group names.
            </param>
            <param name="ignoreNamesFromPersistentData" type="bool">
            Should the new group names overwrite the group names found in persistent data 
            for this World? Has no effect if no persistent data is loaded.
            </param>
            <param name="applyOverwriteRuleToNullNames" type="bool">
            Should the value passed in for ignoreNamesFromPersistentData be applied to LOD's which you are 
            not passing in names for (i.e., the ones you have set to null in newGroupNames)?
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of the newGroupNames array does not match the number of World Groupings on this world, or one or more 
            of the arrays within the main array do not match the number of LOD Groups for that World Grouping (i.e., newGroupNames[0].Length 
            does not match the number of LODs on World Grouping 1 (remember, the 0th index stores World Grouping 1, index 1 stores World Grouping 
            2, etc.)
            </exception>
            <exception cref="T:UnityEngine.MissingComponentException">
            Thrown if a Streamable Grid is not assigned to one of the World Groupings.
            </exception>
            <displayName id="PreInitialize_SetGroupNamesForZone">
            PreInitialize_SetGroupNamesForZone(int, string[][], bool, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetGroupNamesForZone(int zoneIndex, string[][] newGroupNames, bool ignoreNamesFromPersistentData, bool applyOverwriteRuleToNullNames)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.PreInitialize_SetOriginCell(DeepSpaceLabs.SAM.Cell,System.Boolean)">
            <summary>
            Changes the Origin Cell that this World will initially use. This must be called before the World has been initialized. 
            <para>
            The Origin Cell set is the Origin Cell of the base World Grouping. There is no need to set the Origin Cell of each sub World Grouping, 
            as they are automatically set based on the Origin Cell of the base World Grouping.
            </para>
            <para>
            The main use of this will be to implement custom loading rather than making use of the automatic IPersistentDataController 
            class, if you need to save different data in different places (on the server, on a file on the users system, etc.). 
            Note, if all your data is stored in the same place, you are better off using a custom class that derives from 
            IPersistentDataController, and then set it up to save data to that location (as Origin Cell changes 
            are automatically tracked and saved with persistent data)..
            </para>
            <para>
            For methods or features that utilize the starting Origin Cell to calculate data, this Origin Cell will not be used. Instead, the origin 
            Origin Cell as set in the inspector of your World will be used. Such data might be used to calculate the total offset of 
            current world from the original world. For instance, imagine you have a 2D world with 2k x 2k cells at origin 0,0 in the scene, 
            whose starting Origin Cell was ow = 6, column = 6, but whose current Origin Cell is row = 8, column = 8. In order to 
            calculate the total offset of the world, we need to know that cell 6,6 is the starting Origin Cell and is currently positioned at 
            -4000, -4000. Therefore, the total offset of the world is -4000, -4000. This is handy to know when dealing with 3rd part tools that utilize 
            a root transform to track how much the world has been offset.
            </para>
            <para>
            This must be called before the World has been initialized.
            </para>
            </summary>
            <param name="newOriginCell" type="Cell" link="Cell.html">
            The new Origin Cell.
            <para>
            Note, this Origin Cell is 1 based, i.e., the bottom left most cell of the world has an index of row = 1, column = 1, and 
            layer = 1 (for 3D worlds). The Origin Cell in the save data, on the other hand, is 0 based.
            </para>
            <para>
            Also note the layer is only used if the Streamable Grid is Three Dimensional.
            </para>
            </param>
            <param name="overwriteOriginCellFromPersistentData" type="bool">
            Should the new Origin Cell overwrite the Origin Cell found in persistent data for this World? Has no effect if no persistent data is loaded.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.InitializedSAMObjectException" link="InitializedSAMObjectException.html">
            Thrown when this method is called after the World has been initialized.
            </exception>
            <displayName id="PreInitialize_SetOriginCell">
            PreInitialize_SetOriginCell(Cell, bool)
            </displayName>
            <syntax>
            public void PreInitialize_SetOriginCell(Cell newOriginCell, bool overwriteOriginCellFromPersistentData)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ChangeGroupName(System.String,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Changes the Group Name of LOD Group 1 on World Grouping 1 of Zone 1 (change persistent with save data if World is persistent).
            <para>
            A check is performed to ensure the current Group Name is not equal to the passed in Group Name. Nothing will happen if they are 
            the same, although the callback (if provided) will still be invoked.
            </para>
            <para>
            The world is automatically refreshed as a result of the 
            Group Name change, so this method should only be used when the world is hidden from the player (otherwise the player may 
            see the change), and probably when the game is paused (so the player does not fall through the world).
            </para>
            <para>
            Please note, all Group Name changes operate by performing LOD transitions from each World 
            Cell currently belonging to the LOD of the World Grouping to a new World Cell of the same LOD but using the new chunks. 
            This is important, as your custom World Grouping Listeners will only be notified of these updates if their 
            IgnoreLODTransitions property is set to return false.
            </para>
            <para>
            The operation is performed as a secondary operation using the World's update cycle, and as such if the World is currently in the process 
            of being updated, or another secondary operation is in progress, those updates will be completed before this one begins execution. Once the 
            new Group Name has been applied and objects refreshed to use that name, the onCompletedCallback action will be called.
            </para>
            </summary>
            <param name="newGroupName" type="string">
            The new Group Name.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional action that will be called after the Group Name change operation has been completed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <displayName id="ChangeGroupName1">
            ChangeGroupName(string, [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public void ChangeGroupName(string newGroupName, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ChangeGroupName(System.Int32,System.Int32,System.Int32,System.String,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Changes the Group Name of the specified LOD for the specified Zone Grouping (change persistent with save data if World is persistent).
            <para>
            A check is performed to ensure the current Group Name is not equal to the passed in Group Name. Nothing will happen if they are
            the same, although the callback (if provided) will still be invoked.
            </para>
            <para>
            The world is automatically refreshed as a result of the 
            Group Name change, so this method should only be used when the world is hidden from the player (otherwise the player may 
            see the change), and probably when the game is paused (so the player does not fall through the world).
            </para>
            <para>
            Please note, all Group Name changes operate by performing LOD transitions from each World 
            Cell currently belonging to the LOD of the World Grouping to a new World Cell of the same LOD but using the new chunks. 
            This is important, as your custom World Grouping Listeners will only be notified of these updates if their 
            IgnoreLODTransitions property is set to return false.
            </para>
            <para>
            The operation is performed as a secondary operation using the World's update cycle, and as such if the World is currently in the process 
            of being updated, or another secondary operation is in progress, those updates will be completed before this one begins execution. Once the 
            new Group Name has been applied and objects refreshed to use that name, the onCompletedCallback action will be called.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The 1 based index of the Zone whose LOD Group Name you wish to modify.
            </param>
            <param name="groupingIndex" type="int">
            The 1 based index of the World Grouping whose LOD Group Name you wish to modify.
            </param>
            <param name="lodIndex" type="int">
            The 1 based index of the LOD on the World Grouping whose Group Name you wish to modify.
            </param>
            <param name="newGroupName" type="string">
            The new Group Name.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional action that will be called after the Group Name change operation has been completed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <displayName id="ChangeGroupName2">
            ChangeGroupName(int, int, int, string, [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public void ChangeGroupName(int zoneIndex, int groupingIndex, int lodIndex, string newGroupName, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ChangeAllGroupNamesOnZoneGrouping(System.Int32,System.Int32,System.String[],System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Changes the Group Names of all LOD's for the specified Zone Grouping (changes persistent with save data if World is persistent).
            <para>
            A rudimentary check is performed to try to catch instances when this method is called unecessarily. This check adheres to the following rules:
            </para>
            <br></br>
            <para indented="true">
            1) If all LODs on the World Grouping are already using the passed in Group Names, no 
            Group Name change occurs (however the callback, if provided, is still invoked).
            </para>
            <para indented="true">
            2) If only one LOD is not using the passed in Group Name for that LOD, only that LOD's Group Name is changed.
            </para>
            <para indented="true">
            3) If more than one LOD is not using the passed in Group Name for those LODs, Group Names for all LODs on the World Grouping are changed, 
            regardless of whether each LOD is already using the passed in Group Name (as such, this may result in an unecessary refresh of the chunks on those LODs). 
            If you know only a few LODs need to be changed, use multiple calls to the method that target specific LODs on the World Grouping.
            </para>
            <para>
            The world is automatically refreshed as a result of the 
            Group Name changes, so this method should only be used when the world is hidden from the player (otherwise the player may 
            see the change), and probably when the game is paused (so the player does not fall through the world).
            </para>
            <para>
            Please note, all Group Name changes operate by performing LOD transitions from each World 
            Cell currently belonging to the LOD of the World Grouping to a new World Cell of the same LOD but using the new Asset Chunks. 
            This is important, as your custom World Grouping Listeners will only be notified of these updates if their 
            IgnoreLODTransitions property is set to return false.
            </para>
            <para>
            The operation is performed as a secondary operation using the World's update cycle, and as such if the World is currently in the process 
            of being updated, or another secondary operation is in progress, those updates will be completed before this one begins execution. Once the 
            new group names have been applied and objects refreshed to use the new names, the onCompletedCallback action will be called.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The 1 based index of the Zone whose LOD Group Names you wish to modify.
            </param>
            <param name="groupingIndex" type="int">
            The 1 based index of the World Grouping whose LOD Group Names you wish to modify.
            </param>
            <param name="newGroupNames" type="string[]">
            The new group names. Each array index corresponds to an LOD group.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional action that will be called after the Group Name change operation has been completed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of the newGroupNames array does not match the number LODs on the specified World Grouping.
            </exception>
            <displayName id="ChangeAllGroupNamesOnZoneGrouping">
            ChangeAllGroupNamesOnZoneGrouping(int, int, string[], [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public void ChangeAllGroupNamesOnZoneGrouping(int zoneIndex, int groupingIndex, string[] newGroupNames, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ChangeAllGroupNamesOnZone(System.Int32,System.String[][],System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Changes the Group Names of all LOD Groups for all Zone Groupings in the specified Zone (changes persistent with save data if World is persistent).
            <para>
            A rudimentary check is performed to try to catch instances when this method is called unecessarily. The check is performed 
            separately for each World Grouping on the World, according to the following rules:
            <br></br>
            </para>
            <para indented="true">
            1) If all LODs on a Zone Grouping are already using the passed in Group Names, no 
            Group Name change occurs for that Grouping (however the callback, if provided, is still invoked).
            </para>
            <para indented="true">
            2) If only one LOD is not using the passed in Group Name for that LOD, only that LOD's Group Name is changed.
            </para>
            <para indented="true">
            3) If more than one LOD is not using the passed in Group Name for those LODs, all LODs on the Zone Grouping are changed, regardless of whether each 
            LOD is already using the passed in Group Name (as such, this may result in an unecessary refresh of the chunks on those LODs).
            </para>
            <para>
            If you know only a few World Groupings need to be changed, it is better to use the method that targets a specific World Grouping.
            </para>
            <para>
            If you know only a few LODs need to be changed, use the methods that target specific LODs on specific World Groupings.
            </para>
            <para>
            The world is automatically refreshed and Asset Chunks changed out as a result of the 
            Group Name changes, so this method should only be used when the world is hidden from the player (otherwise the player may 
            see the change), and probably when the game is paused (so the player does not fall through the world).
            </para>
            <para>
            Please note, all Group Name changes operate by performing LOD transitions from each World 
            Cell currently belonging to the LOD of the World Grouping to a new World Cell of the same LOD but using the new Asset Chunks. 
            <b>This is important, as your custom World Grouping Listeners will only be notified of these updates if their 
            IgnoreLODTransitions property is set to return false.</b>
            </para>
            <para>
            The operation is performed as a secondary operation using the World's update cycle, and as such if the World is currently in the process 
            of being updated, or another secondary operation is in progress, those updates will be completed before this one begins execution. Once the 
            new group names have been applied and Asset Chunks refreshed to use the new names, the onCompletedCallback action will be called.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone you wish to change.
            </param>
            <param name="newGroupNames" type="string[][]">
            The new group names. The first array index corresponds to the World Grouping, while the second index is the LOD group 
            on that World Grouping. The lengths must match the number of World Groupings on this world, plus the number of LODs on 
            each World Grouping.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional action that will be called after the Group Name change operation has been completed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <exception cref="T:System.ArgumentException">
            Thrown when the length of the newGroupNames array does not match the number of World Groupings on this world, or one or more 
            of the arrays within the main array do not match the number of LODs for that World Grouping (i.e., newGroupNames[0].Length 
            does not match the number of LODs on World Grouping 1 (remember, the 0th index stores World Grouping 1, index 1 stores World Grouping 
            2, etc.)
            </exception>
            <displayName id="ChangeAllGroupNamesOnZone">
            ChangeAllGroupNamesOnZone(int, string[][], [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public void ChangeAllGroupNamesOnZone(int zoneIndex, string[][] newGroupNames, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ResetGroupName(System.Int32,System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Resets the Group Name of the specified LOD Group on the specified Zone Grouping of this World back to the 
            default name set in the inspector (change persistent with save data if World is persistent).
            <para>
            This can be used if you have changed the Group Name in the past to an 
            alternate name but want the LOD to go back to using its default one.
            </para>
            <para>
            A check is performed to ensure the Group Name of the specified World Grouping's LOD Group is not already set to the default one, and 
            nothing will happen if it is, although the callback (if provided) will still be invoked.
            </para>
            <para>
            The world is automatically refreshed as a result of the 
            Group Name change, so this method should only be used when the world is hidden from the player (otherwise the player may 
            see the change), and probably when the game is paused (so the player does not fall through the world).
            </para>
            <para>
            Please note, all Group Name changes operate by performing LOD transitions from each World 
            Cell currently belonging to the LOD of the World Grouping to a new World Cell of the same LOD but using the new chunks. 
            This is important, as your custom World Grouping Listeners will only be notified of these updates if their 
            IgnoreLODTransitions property is set to return false.
            </para>
            <para>
            The operation is performed as a secondary operation using the World's update cycle, and as such if the World is currently in the process 
            of being updated, or another secondary operation is in progress, those updates will be completed before this one begins execution. Once the 
            Group Name has been reset and objects refreshed to use the new name, the onCompletedCallback action will be called.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone whose LOD Group name you wish to reset.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping whose LOD Group Name you wish to reset.
            </param>
            <param name="lodIndex" type="int">
            The index of the LOD Group on the World Grouping whose Group Name you wish to reset.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional action that will be called after the Group Name reset operation has been completed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <displayName id="ResetGroupName">
            ResetGroupName(int, int, [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public void ResetGroupName(int zoneIndex, int groupingIndex, int lodIndex, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ResetAllGroupNamesOnZoneGrouping(System.Int32,System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Resets the Group Names of all LOD Groups on the specified Zone Grouping of this World back to the 
            default names set in the inspector (changes persistent with save data if World is persistent).
            <para>
            This can be used if you have changed the Group Names in the past to an 
            alternate name but want the LOD Groups to go back to using their default ones.
            </para>
            <para>
            A rudimentary check is performed to try to catch instances when this method is called unecessarily. It adheres to the following rules:
            </para>
            <br></br>
            <para indented="true">
            1) If all LOD Groups on the World Grouping are already using their default Group Names, no 
            Group Name reset occurs (however the callback, if provided, is still invoked).
            </para>
            <para indented="true">
            2) If only one LOD Group is not using its default Group Name, only that LOD Group is reset.
            </para>
            <para indented="true">
            3) If more than one LOD Group is not using its default Group Name, all LOD Groups on the World Grouping are reset, regardless of whether each 
            LOD Group is already using its default Group Name (as such, this may result in an unecessary refresh of the World Cell Asset Chunks using those unchanged LODs). 
            If you know only a few LOD Groups need to be reset, use the method that targets specific LOD Groups on the World Grouping instead.
            </para>
            <para>
            The world is automatically refreshed as a result of the 
            Group Name changes, so this method should only be used when the world is hidden from the player (otherwise the player may 
            see the change), and probably when the game is paused (so the player does not fall through the world).
            </para>
            <para>
            Please note, all Group Name changes operate by performing LOD transitions from each World 
            Cell currently belonging to the LOD of the World Grouping to a new World Cell of the same LOD but using the new chunks. 
            This is important, as your custom World Grouping Listeners will only be notified of these updates if their 
            IgnoreLODTransitions property is set to return false.
            </para>
            <para>
            The operation is performed as a secondary operation using the World's update cycle, and as such if the World is currently in the process 
            of being updated, or another secondary operation is in progress, those updates will be completed before this one begins execution. Once the 
            group names have been reset and objects refreshed to use the new name, the onCompletedCallback action will be called.
            </para>
            </summary>
            <param name="zoneIndex" type="int">
            The index of the Zone whose LOD Group Names you wish to reset.
            </param>
            <param name="groupingIndex" type="int">
            The index of the World Grouping whose LOD Group Names you wish to reset.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional action that will be called after the Group Name reset operation has been completed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <displayName id="ResetAllGroupNamesOnZoneGrouping">
            ResetAllGroupNamesOnZoneGrouping(int, int, [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public void ResetAllGroupNamesOnZoneGrouping(int zoneIndex, int groupingIndex, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.ResetAllGroupNamesOnZone(System.Int32,System.Action{DeepSpaceLabs.SAM.World})">
            <summary>
            Resets the Group Names of every LOD Group on every Zone Grouping of the input Zone back to the 
            default names set in the inspector (changes persistent with save data if World is persistent).
            <para>
            This can be used if you have changed the group names in the past to an 
            alternate name but want the World Groupings' LOD Groups to go back to using their default ones.
            </para>
            <para>
            A rudimentary check is performed to try to catch instances when this method is called unecessarily. The check is performed 
            separately for each World Grouping and adheres to the following rules:
            <br></br>
            </para>
            <para indented="true">
            1) If all LOD Groups on a Zone Grouping are already using their default Group Names, no 
            Group Name reset occurs for that Grouping (however the callback, if provided, is still invoked).
            </para>
            <para indented="true">
            2) If only one LOD Group is not using its default Group Name, only that LOD Group name is reset.
            </para>
            <para indented="true">
            3) If more than one LOD Group is not using its default Group Name, all LOD Groups on the Zone Grouping are reset, regardless of whether each 
            LOD Group is already using the default Group Name (as such, this may result in an unecessary refresh of the World Cells' Asset Chunks using the non changed LODs).
            </para>
            <para>
            If you know only a few World Groupings need to be reset, it is better to use the method that targets a specific World Grouping. If you know only a few LOD 
            Groups need to be reset, use the methods that target specific LOD Groups on specific Zone Groupings.
            </para>
            <para>
            The world is automatically refreshed as a result of the 
            Group Name changes, so this method should only be used when the world is hidden from the player (otherwise the player may 
            see the change), and probably when the game is paused (so the player does not fall through the world).
            </para>
            <para>
            Please note, all Group Name changes operate by performing LOD transitions from each World 
            Cell currently belonging to the LOD of the World Grouping to a new World Cell of the same LOD but using the new chunks. 
            This is important, as your custom World Grouping Listeners will only be notified of these updates if their 
            IgnoreLODTransitions property is set to return false.
            </para>
            <para>
            The operation is performed as a secondary operation using the World's update cycle, and as such if the World is currently in the process 
            of being updated, or another secondary operation is in progress, those updates will be completed before this one begins execution. Once the 
            new group names have been reset and objects refreshed to use the new names, the onCompletedCallback action will be called.
            </para>
            </summary>
            <param name="zoneIndex" type ="int">
            The index of the zone whose Grouping LOD Group Names you wish to reset.
            </param>
            <param name="onCompletedCallback" type="Action&lt;World&gt;">
            An optional action that will be called after the Group Name reset operation has been completed.
            </param>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when the method is called before the World has been initialized.
            </exception>
            <exception cref="T:System.InvalidOperationException">
            Thrown when the method is called while the World is in the process of being destroyed.
            </exception>
            <displayName id="ResetAllGroupNamesOnAllWorldGroupings">
            ResetAllGroupNamesOnAllWorldGroupings(int, [Action&lt;World&gt;])
            </displayName>
            <syntax>
            public void ResetAllGroupNamesOnAllWorldGroupings(int zoneIndex, Action&lt;World&gt; onCompletedCallback = null)
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.World.FindUnboundWorldGridCellPositionIsIn(DeepSpaceLabs.SAM.Vector3Double)">
            <summary>
            Finds the Unbound Cell the position is in within the World's imaginary grid, given the current Origin Cell used by the World.
            <para>
            The unbound cell is similar to an endless grid cell, in that its indices are unique for each repeated instance of the World on 
            any axis which have been set to be repeated/endless.
            </para>
            </summary>
            <param name="position" type="Vector3Double" link="Vector3Double.html">
            The position.
            </param>
            <displayName id="FindUnboundWorldGridCellPositionIsIn">
            FindUnboundWorldGridCellPositionIsIn(Vector3Double)
            </displayName>
            <syntax>
            public Cell FindUnboundWorldGridCellPositionIsIn(Vector3Double position)
            </syntax>
            <returns type="Cell" link="Cell.html">
            The Unclamped World Grid Cell the position is in.
            </returns>
            <exception cref="T:DeepSpaceLabs.SAM.UninitializedSAMObjectException" link="UninitializedSAMObjectException.html">
            Thrown when this method is called before the World has been initialized.
            </exception>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingSettings.ChunkManager">
            <summary>
            Gets the chunk manager assigned to this World Grouping (if any), which can be overriden on a per LOD basis.
            </summary>
            <type link="ChunkManager.html">ChunkManager</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.WorldGroupingSettings.ChunkStreamer">
            <summary>
            Gets the chunk streamer assigned to this World Grouping (if any), which can be overriden on a per LOD basis.
            </summary>
            <type link="ChunkStreamer.html">ChunkStreamer</type>
        </member>
        <member name="T:DeepSpaceLabs.SAM.ExecutionController">
            <summary>
            A component based Execution Controller, which is resposible for controlling the execution of SAM related code.
            <para>
            You can create a custom class that derives from this one in order to create custom logic for dictating 
            when exeuction occurs.
            </para>
            </summary>
            <title>
            ExecutionController Class
            </title>
            <category>Execution Controllers</category>
            <navigationName>
            ExecutionController
            </navigationName>
            <fileName>ExecutionController.html</fileName>
            <syntax>
            public abstract class ExecutionController : MonoBehaviour, <see cref="T:DeepSpaceLabs.SAM.IExecutionController" href="IExecutionController.html">IExecutionController</see>
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ExecutionController.ShouldStartExecuting">
            <summary>
            For every frame that the component which uses this execution controller is set to execute, this method will 
            be queried to determine whether the component should execute.
            <para>
            A typical use case would be not letting the component execute if x seconds have already transpired during the frame.
            </para>
            </summary>
            <returns type="bool">
            Return true if the component should start executing its logic in the Current frame, or false if it should not (the 
            next frame this method will be queried again).
            </returns>
            <displayName id="ShouldStartExecuting">
            ShouldStartExecuting()
            </displayName>
            <syntax>
            public abstract bool ShouldStartExecuting()
            </syntax>
        </member>
        <member name="M:DeepSpaceLabs.SAM.ExecutionController.ShouldContinueExecuting">
            <summary>
            When the component which uses the IExecutionController wants to know whether it should yield for a frame or 
            continue executing, this method is queried.
            <para>
            Note there are a lot of methods that don't use this strategy, but instead need to always yield for a frame 
            or on some other property (WaitForSeconds for example)
            </para>
            </summary>
            <returns type="bool">
            Return true if the component should continue executing, false if it should yield for a frame.
            </returns>
            <displayName id="ShouldContinueExecuting">
            ShouldContinueExecuting()
            </displayName>
            <syntax>
            public abstract bool ShouldContinueExecuting()
            </syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldInstructionInfo">
            <summary>
            YieldInstruction is a unity specific class used in conjunction with Unity Coroutines. Even though it is a Unity specific 
            class, it is listed on this API for informational purposes, as the IEnumerator&lt;YieldInstruction&gt; return construct is used 
            throughout this API and it is helpful to have a page dedicated to explaining its use.
            <para>
            The IEnumerator&lt;YieldInstruction&gt; return construct is used extensively in the Streamable Assets Manager, mainly in two ways.
            </para>
            <para>
            The first is in public callable methods, primarily found in the 
            <see cref="T:DeepSpaceLabs.SAM.ComponentManager" href="ComponentManager.html">ComponentManager</see> and 
            <see cref="T:DeepSpaceLabs.SAM.ActiveGrid" href="ActiveGrid.html">ActiveGrid</see> classes.
            </para>
            <para>
            With these methods, you will either need initialize them like other coroutines using StartCoroutine, like so:
            <br></br>
            <br></br>
            void Start()
            <br></br>
            {
            <br></br>
            <tab></tab>StartCoroutine(SampleMethod());
            <br></br>
            }
            </para>
            <para>
            or you will manually run them from a method that has been initialized via StartCoroutine. Example:
            <br></br>
            <br></br>
            void Start()
            <br></br>
            {
            <br></br>
            <tab></tab>StartCoroutine(MyCoroutine());
            <br></br>
            }
            <br></br>
            <br></br>
            IEnumerator MyCoroutine()
            <br></br>
            {
            <br></br>
            <tab></tab>var en = SampleMethod();
                <br></br>
            <tab></tab>while(en.MoveNext())
                <br></br>
            <tab></tab><tab></tab>yield return en.Current;
            <br></br>
            }
            </para>
            <para>
            The second technique is typically more useful, as it allows you to add additional code within the while(en.MoveNext()) loop. It also 
            allows you to track when the enumerator finishes executing so that you can time other actions with its completion.
            </para>
            <para>
            It should also be noted that sometimes, you can run these methods in a single frame (if absolutely necessary). Example: 
            <br></br>
            <br></br>
            void Start()
            <br></br>
            {
            <br></br>
            <tab></tab>var en = SampleMethod();
                <br></br>
            <tab></tab>while(en.MoveNext())
                <br></br>
            <tab></tab><tab></tab>continue;
            <br></br>
            }
            </para>
            <para>
            Do note, not all methods can be run this way!
            </para>
            <para>
            The second way the IEnumerator&lt;YieldInstruction&gt; return construct is used in the Streamable Assets Manager is as 
            the return type for overridable methods found in overridable classes, which you might create to add custom behavior or logic.
            </para>
            <para>
            These methods are run by the World class from a single StartCoroutine initialization (unless otherwise noted), which reduces garbage generation.
            </para>
            <para>
            You have two options for how to implement overridable methods that return IEnumerator&lt;YieldInstruction&gt;:
            </para>
            <para>
            1) Use the normal yield return statements, where the return value is either null or a derivative of YieldInstruction.
            <br></br>
            2) Use our garbage friendly <see cref="T:DeepSpaceLabs.SAM.ReusableEnumerators">ReusableEnumerators</see> class.
            </para>
            <para>
            For the first option, it should be noted that using yield return statements will result in 
            auto generated iterators which will produce garbage. If using this construct, you can either yield return null or a YieldInstruction. 
            Yield return null will cause the method to yield for a single frame and then resume execution.
            </para>
            <para>
            In addition, you can yield return a 
            <see href="https://docs.unity3d.com/ScriptReference/WaitForSeconds.html">WaitForSeconds</see> object, 
            <see href="https://docs.unity3d.com/ScriptReference/WaitForFixedUpdate.html">WaitForFixedUpdate</see> object, or a new 
            <see href="https://docs.unity3d.com/ScriptReference/Coroutine.html">Coroutine</see> by using the 
            yield return StartCoroutine(CoroutineName()) construct.
            </para>
            <para>
            For the second option, you will need to also make use of one of the 
            <see cref="T:DeepSpaceLabs.SAM.YieldEnumerator">YieldEnumerator</see> classes.
            </para>
            <para>
            Use of these classes, as well as the <see cref="T:DeepSpaceLabs.SAM.ReusableEnumerators">ReusableEnumerators</see> class, are only recommended for 
            advanced programmers, as the classes are not heavily documented and if they are not used correctly, major issues can arise. 
            </para>
            <para>
            In fact, the <see cref="T:DeepSpaceLabs.SAM.ReusableEnumerators">ReusableEnumerators</see> class is not documented in the website API, however 
            if you use it from code, you will find some information avaialable when referencing it.
            </para>
            </summary>
            <title>Yield Instruction Class</title>
            <category>Secondary Non Components</category>
            <navigationName>YieldInstruction</navigationName>
            <fileName>YieldInstruction.html</fileName>
            <syntax>public class YieldInstruction</syntax>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldOrContinue">
            <summary>
            A special wrapper for a unity <see href="https://docs.unity3d.com/ScriptReference/YieldInstruction.html">YieldInstruction</see>. In most cases you will not use this 
            class directly. It is used throughout SAM in coroutine methods to indicate to a World or other componenent that makes use of it that the component should query an attached 
            <see cref="T:DeepSpaceLabs.SAM.ExecutionController" href="ExecutionController.html">Execution Controller</see> to see whether the method should yield for a frame or continue executing. This is meant to 
            allow for flexible execution of these methods to account for variations in game perforance in different frames.
            <para>
            If for some reason you have reason to make use of this class, consider using the static Instance field, since a single object can safely be used in as many 
            places as you wish.
            </para>
            </summary>
            <title>
            YieldOrContinue Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>
            YieldOrContinue
            </navigationName>
            <fileName>YieldOrContinue.html</fileName>
            <syntax>
            public sealed class YieldOrContinue : YieldInstruction
            </syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldOrContinue.Instance">
            <summary>
            The YieldOrContinue instance. Return this from World driven IEnumerator methods to indicate that the world should query its Execution Controller to 
            determine if the method should keep running or yield.
            </summary>
        </member>
        <member name="T:DeepSpaceLabs.SAM.YieldUntilJobComplete">
            <summary>
            A special wrapper for a unity <see href="https://docs.unity3d.com/ScriptReference/YieldInstruction.html">YieldInstruction</see> that can be used in 
            combination with the Job System. This can be used in IEnumerator&lt;YieldInstruction&gt; based methods to tell the object driving the methods execution to yield until the 
            job has been completed. This is very useful for adding job based parallelism.
            <para>
            Once the YieldUntilJobComplete is yielded, the jobHandle structure is copied by the World and the copy is referenced. As such, you should be able to freely reuse the YieldUntilJobComplete instance as many times as you wish; just 
            make sure to assign a new JobHandle to it each time.
            </para>
            </summary>
            <title>
            YieldUntilJobComplete Class
            </title>
            <category>Secondary Non Components</category>
            <navigationName>
            YieldOrContinue
            </navigationName>
            <fileName>YieldUntilJobComplete.html</fileName>
            <syntax>
            public sealed class YieldUntilJobComplete : YieldInstruction
            </syntax>
        </member>
        <member name="F:DeepSpaceLabs.SAM.YieldUntilJobComplete.jobHandle">
            <summary>
            The job handle object that the object driving the enumerator method needs to wait to finish.
            </summary>
            <type>JobHandle</type>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneSettings.StartingRow_ZeroBased">
            <summary>
            The World Grid Row the zone starts in
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneSettings.StartingColumn_ZeroBased">
            <summary>
            The World Grid Column the zone starts in
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneSettings.StartingLayer_ZeroBased">
            <summary>
            The World Grid Layer the zone starts in
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneSettings.EndingRow_ZeroBased">
            <summary>
            The World Grid Row the zone ends in
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneSettings.EndingColumn_ZeroBased">
            <summary>
            The World Grid Column the zone ends in
            </summary>
        </member>
        <member name="P:DeepSpaceLabs.SAM.ZoneSettings.EndingLayer_ZeroBased">
            <summary>
            The World Grid Layer the zone ends in
            </summary>
        </member>
    </members>
</doc>
